// Generated by Molecule 0.7.3

use molecule::prelude::*;
#[derive(Clone)]
pub struct Uint64(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Uint64 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Uint64 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Uint64 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl ::core::default::Default for Uint64 {
    fn default() -> Self {
        let v: Vec<u8> = vec![0, 0, 0, 0, 0, 0, 0, 0];
        Uint64::new_unchecked(v.into())
    }
}
impl Uint64 {
    pub const TOTAL_SIZE: usize = 8;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 8;
    pub fn nth0(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(0..1))
    }
    pub fn nth1(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(1..2))
    }
    pub fn nth2(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(2..3))
    }
    pub fn nth3(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(3..4))
    }
    pub fn nth4(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(4..5))
    }
    pub fn nth5(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(5..6))
    }
    pub fn nth6(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(6..7))
    }
    pub fn nth7(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(7..8))
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.as_bytes()
    }
    pub fn as_reader<'r>(&'r self) -> Uint64Reader<'r> {
        Uint64Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Uint64 {
    type Builder = Uint64Builder;
    const NAME: &'static str = "Uint64";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Uint64(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Uint64Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Uint64Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([
            self.nth0(),
            self.nth1(),
            self.nth2(),
            self.nth3(),
            self.nth4(),
            self.nth5(),
            self.nth6(),
            self.nth7(),
        ])
    }
}
#[derive(Clone, Copy)]
pub struct Uint64Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for Uint64Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for Uint64Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for Uint64Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl<'r> Uint64Reader<'r> {
    pub const TOTAL_SIZE: usize = 8;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 8;
    pub fn nth0(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[0..1])
    }
    pub fn nth1(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[1..2])
    }
    pub fn nth2(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[2..3])
    }
    pub fn nth3(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[3..4])
    }
    pub fn nth4(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[4..5])
    }
    pub fn nth5(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[5..6])
    }
    pub fn nth6(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[6..7])
    }
    pub fn nth7(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[7..8])
    }
    pub fn raw_data(&self) -> &'r [u8] {
        self.as_slice()
    }
}
impl<'r> molecule::prelude::Reader<'r> for Uint64Reader<'r> {
    type Entity = Uint64;
    const NAME: &'static str = "Uint64Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        Uint64Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
pub struct Uint64Builder(pub(crate) [Byte; 8]);
impl ::core::fmt::Debug for Uint64Builder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::core::default::Default for Uint64Builder {
    fn default() -> Self {
        Uint64Builder([
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
        ])
    }
}
impl Uint64Builder {
    pub const TOTAL_SIZE: usize = 8;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 8;
    pub fn set(mut self, v: [Byte; 8]) -> Self {
        self.0 = v;
        self
    }
    pub fn nth0(mut self, v: Byte) -> Self {
        self.0[0] = v;
        self
    }
    pub fn nth1(mut self, v: Byte) -> Self {
        self.0[1] = v;
        self
    }
    pub fn nth2(mut self, v: Byte) -> Self {
        self.0[2] = v;
        self
    }
    pub fn nth3(mut self, v: Byte) -> Self {
        self.0[3] = v;
        self
    }
    pub fn nth4(mut self, v: Byte) -> Self {
        self.0[4] = v;
        self
    }
    pub fn nth5(mut self, v: Byte) -> Self {
        self.0[5] = v;
        self
    }
    pub fn nth6(mut self, v: Byte) -> Self {
        self.0[6] = v;
        self
    }
    pub fn nth7(mut self, v: Byte) -> Self {
        self.0[7] = v;
        self
    }
}
impl molecule::prelude::Builder for Uint64Builder {
    type Entity = Uint64;
    const NAME: &'static str = "Uint64Builder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.0[0].as_slice())?;
        writer.write_all(self.0[1].as_slice())?;
        writer.write_all(self.0[2].as_slice())?;
        writer.write_all(self.0[3].as_slice())?;
        writer.write_all(self.0[4].as_slice())?;
        writer.write_all(self.0[5].as_slice())?;
        writer.write_all(self.0[6].as_slice())?;
        writer.write_all(self.0[7].as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Uint64::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct Hash(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Hash {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Hash {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Hash {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl ::core::default::Default for Hash {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0,
        ];
        Hash::new_unchecked(v.into())
    }
}
impl Hash {
    pub const TOTAL_SIZE: usize = 32;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 32;
    pub fn nth0(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(0..1))
    }
    pub fn nth1(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(1..2))
    }
    pub fn nth2(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(2..3))
    }
    pub fn nth3(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(3..4))
    }
    pub fn nth4(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(4..5))
    }
    pub fn nth5(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(5..6))
    }
    pub fn nth6(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(6..7))
    }
    pub fn nth7(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(7..8))
    }
    pub fn nth8(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(8..9))
    }
    pub fn nth9(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(9..10))
    }
    pub fn nth10(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(10..11))
    }
    pub fn nth11(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(11..12))
    }
    pub fn nth12(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(12..13))
    }
    pub fn nth13(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(13..14))
    }
    pub fn nth14(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(14..15))
    }
    pub fn nth15(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(15..16))
    }
    pub fn nth16(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(16..17))
    }
    pub fn nth17(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(17..18))
    }
    pub fn nth18(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(18..19))
    }
    pub fn nth19(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(19..20))
    }
    pub fn nth20(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(20..21))
    }
    pub fn nth21(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(21..22))
    }
    pub fn nth22(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(22..23))
    }
    pub fn nth23(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(23..24))
    }
    pub fn nth24(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(24..25))
    }
    pub fn nth25(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(25..26))
    }
    pub fn nth26(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(26..27))
    }
    pub fn nth27(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(27..28))
    }
    pub fn nth28(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(28..29))
    }
    pub fn nth29(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(29..30))
    }
    pub fn nth30(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(30..31))
    }
    pub fn nth31(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(31..32))
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.as_bytes()
    }
    pub fn as_reader<'r>(&'r self) -> HashReader<'r> {
        HashReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Hash {
    type Builder = HashBuilder;
    const NAME: &'static str = "Hash";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Hash(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        HashReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        HashReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([
            self.nth0(),
            self.nth1(),
            self.nth2(),
            self.nth3(),
            self.nth4(),
            self.nth5(),
            self.nth6(),
            self.nth7(),
            self.nth8(),
            self.nth9(),
            self.nth10(),
            self.nth11(),
            self.nth12(),
            self.nth13(),
            self.nth14(),
            self.nth15(),
            self.nth16(),
            self.nth17(),
            self.nth18(),
            self.nth19(),
            self.nth20(),
            self.nth21(),
            self.nth22(),
            self.nth23(),
            self.nth24(),
            self.nth25(),
            self.nth26(),
            self.nth27(),
            self.nth28(),
            self.nth29(),
            self.nth30(),
            self.nth31(),
        ])
    }
}
#[derive(Clone, Copy)]
pub struct HashReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for HashReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for HashReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for HashReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl<'r> HashReader<'r> {
    pub const TOTAL_SIZE: usize = 32;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 32;
    pub fn nth0(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[0..1])
    }
    pub fn nth1(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[1..2])
    }
    pub fn nth2(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[2..3])
    }
    pub fn nth3(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[3..4])
    }
    pub fn nth4(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[4..5])
    }
    pub fn nth5(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[5..6])
    }
    pub fn nth6(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[6..7])
    }
    pub fn nth7(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[7..8])
    }
    pub fn nth8(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[8..9])
    }
    pub fn nth9(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[9..10])
    }
    pub fn nth10(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[10..11])
    }
    pub fn nth11(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[11..12])
    }
    pub fn nth12(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[12..13])
    }
    pub fn nth13(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[13..14])
    }
    pub fn nth14(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[14..15])
    }
    pub fn nth15(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[15..16])
    }
    pub fn nth16(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[16..17])
    }
    pub fn nth17(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[17..18])
    }
    pub fn nth18(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[18..19])
    }
    pub fn nth19(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[19..20])
    }
    pub fn nth20(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[20..21])
    }
    pub fn nth21(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[21..22])
    }
    pub fn nth22(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[22..23])
    }
    pub fn nth23(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[23..24])
    }
    pub fn nth24(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[24..25])
    }
    pub fn nth25(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[25..26])
    }
    pub fn nth26(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[26..27])
    }
    pub fn nth27(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[27..28])
    }
    pub fn nth28(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[28..29])
    }
    pub fn nth29(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[29..30])
    }
    pub fn nth30(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[30..31])
    }
    pub fn nth31(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[31..32])
    }
    pub fn raw_data(&self) -> &'r [u8] {
        self.as_slice()
    }
}
impl<'r> molecule::prelude::Reader<'r> for HashReader<'r> {
    type Entity = Hash;
    const NAME: &'static str = "HashReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        HashReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
pub struct HashBuilder(pub(crate) [Byte; 32]);
impl ::core::fmt::Debug for HashBuilder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::core::default::Default for HashBuilder {
    fn default() -> Self {
        HashBuilder([
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
        ])
    }
}
impl HashBuilder {
    pub const TOTAL_SIZE: usize = 32;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 32;
    pub fn set(mut self, v: [Byte; 32]) -> Self {
        self.0 = v;
        self
    }
    pub fn nth0(mut self, v: Byte) -> Self {
        self.0[0] = v;
        self
    }
    pub fn nth1(mut self, v: Byte) -> Self {
        self.0[1] = v;
        self
    }
    pub fn nth2(mut self, v: Byte) -> Self {
        self.0[2] = v;
        self
    }
    pub fn nth3(mut self, v: Byte) -> Self {
        self.0[3] = v;
        self
    }
    pub fn nth4(mut self, v: Byte) -> Self {
        self.0[4] = v;
        self
    }
    pub fn nth5(mut self, v: Byte) -> Self {
        self.0[5] = v;
        self
    }
    pub fn nth6(mut self, v: Byte) -> Self {
        self.0[6] = v;
        self
    }
    pub fn nth7(mut self, v: Byte) -> Self {
        self.0[7] = v;
        self
    }
    pub fn nth8(mut self, v: Byte) -> Self {
        self.0[8] = v;
        self
    }
    pub fn nth9(mut self, v: Byte) -> Self {
        self.0[9] = v;
        self
    }
    pub fn nth10(mut self, v: Byte) -> Self {
        self.0[10] = v;
        self
    }
    pub fn nth11(mut self, v: Byte) -> Self {
        self.0[11] = v;
        self
    }
    pub fn nth12(mut self, v: Byte) -> Self {
        self.0[12] = v;
        self
    }
    pub fn nth13(mut self, v: Byte) -> Self {
        self.0[13] = v;
        self
    }
    pub fn nth14(mut self, v: Byte) -> Self {
        self.0[14] = v;
        self
    }
    pub fn nth15(mut self, v: Byte) -> Self {
        self.0[15] = v;
        self
    }
    pub fn nth16(mut self, v: Byte) -> Self {
        self.0[16] = v;
        self
    }
    pub fn nth17(mut self, v: Byte) -> Self {
        self.0[17] = v;
        self
    }
    pub fn nth18(mut self, v: Byte) -> Self {
        self.0[18] = v;
        self
    }
    pub fn nth19(mut self, v: Byte) -> Self {
        self.0[19] = v;
        self
    }
    pub fn nth20(mut self, v: Byte) -> Self {
        self.0[20] = v;
        self
    }
    pub fn nth21(mut self, v: Byte) -> Self {
        self.0[21] = v;
        self
    }
    pub fn nth22(mut self, v: Byte) -> Self {
        self.0[22] = v;
        self
    }
    pub fn nth23(mut self, v: Byte) -> Self {
        self.0[23] = v;
        self
    }
    pub fn nth24(mut self, v: Byte) -> Self {
        self.0[24] = v;
        self
    }
    pub fn nth25(mut self, v: Byte) -> Self {
        self.0[25] = v;
        self
    }
    pub fn nth26(mut self, v: Byte) -> Self {
        self.0[26] = v;
        self
    }
    pub fn nth27(mut self, v: Byte) -> Self {
        self.0[27] = v;
        self
    }
    pub fn nth28(mut self, v: Byte) -> Self {
        self.0[28] = v;
        self
    }
    pub fn nth29(mut self, v: Byte) -> Self {
        self.0[29] = v;
        self
    }
    pub fn nth30(mut self, v: Byte) -> Self {
        self.0[30] = v;
        self
    }
    pub fn nth31(mut self, v: Byte) -> Self {
        self.0[31] = v;
        self
    }
}
impl molecule::prelude::Builder for HashBuilder {
    type Entity = Hash;
    const NAME: &'static str = "HashBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.0[0].as_slice())?;
        writer.write_all(self.0[1].as_slice())?;
        writer.write_all(self.0[2].as_slice())?;
        writer.write_all(self.0[3].as_slice())?;
        writer.write_all(self.0[4].as_slice())?;
        writer.write_all(self.0[5].as_slice())?;
        writer.write_all(self.0[6].as_slice())?;
        writer.write_all(self.0[7].as_slice())?;
        writer.write_all(self.0[8].as_slice())?;
        writer.write_all(self.0[9].as_slice())?;
        writer.write_all(self.0[10].as_slice())?;
        writer.write_all(self.0[11].as_slice())?;
        writer.write_all(self.0[12].as_slice())?;
        writer.write_all(self.0[13].as_slice())?;
        writer.write_all(self.0[14].as_slice())?;
        writer.write_all(self.0[15].as_slice())?;
        writer.write_all(self.0[16].as_slice())?;
        writer.write_all(self.0[17].as_slice())?;
        writer.write_all(self.0[18].as_slice())?;
        writer.write_all(self.0[19].as_slice())?;
        writer.write_all(self.0[20].as_slice())?;
        writer.write_all(self.0[21].as_slice())?;
        writer.write_all(self.0[22].as_slice())?;
        writer.write_all(self.0[23].as_slice())?;
        writer.write_all(self.0[24].as_slice())?;
        writer.write_all(self.0[25].as_slice())?;
        writer.write_all(self.0[26].as_slice())?;
        writer.write_all(self.0[27].as_slice())?;
        writer.write_all(self.0[28].as_slice())?;
        writer.write_all(self.0[29].as_slice())?;
        writer.write_all(self.0[30].as_slice())?;
        writer.write_all(self.0[31].as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Hash::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct Bytes(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Bytes {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Bytes {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Bytes {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl ::core::default::Default for Bytes {
    fn default() -> Self {
        let v: Vec<u8> = vec![0, 0, 0, 0];
        Bytes::new_unchecked(v.into())
    }
}
impl Bytes {
    pub const ITEM_SIZE: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()
    }
    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<Byte> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> Byte {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        Byte::new_unchecked(self.0.slice(start..end))
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.0.slice(molecule::NUMBER_SIZE..)
    }
    pub fn as_reader<'r>(&'r self) -> BytesReader<'r> {
        BytesReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Bytes {
    type Builder = BytesBuilder;
    const NAME: &'static str = "Bytes";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Bytes(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BytesReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BytesReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct BytesReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for BytesReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for BytesReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for BytesReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl<'r> BytesReader<'r> {
    pub const ITEM_SIZE: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()
    }
    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<ByteReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> ByteReader<'r> {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        ByteReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn raw_data(&self) -> &'r [u8] {
        &self.as_slice()[molecule::NUMBER_SIZE..]
    }
}
impl<'r> molecule::prelude::Reader<'r> for BytesReader<'r> {
    type Entity = Bytes;
    const NAME: &'static str = "BytesReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        BytesReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_count = molecule::unpack_number(slice) as usize;
        if item_count == 0 {
            if slice_len != molecule::NUMBER_SIZE {
                return ve!(Self, TotalSizeNotMatch, molecule::NUMBER_SIZE, slice_len);
            }
            return Ok(());
        }
        let total_size = molecule::NUMBER_SIZE + Self::ITEM_SIZE * item_count;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct BytesBuilder(pub(crate) Vec<Byte>);
impl BytesBuilder {
    pub const ITEM_SIZE: usize = 1;
    pub fn set(mut self, v: Vec<Byte>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: Byte) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = Byte>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
    pub fn replace(&mut self, index: usize, v: Byte) -> Option<Byte> {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v))
    }
}
impl molecule::prelude::Builder for BytesBuilder {
    type Entity = Bytes;
    const NAME: &'static str = "BytesBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.0.len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.len() as molecule::Number))?;
        for inner in &self.0[..] {
            writer.write_all(inner.as_slice())?;
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Bytes::new_unchecked(inner.into())
    }
}
pub struct BytesIterator(Bytes, usize, usize);
impl ::core::iter::Iterator for BytesIterator {
    type Item = Byte;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for BytesIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for Bytes {
    type Item = Byte;
    type IntoIter = BytesIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        BytesIterator(self, 0, len)
    }
}
#[derive(Clone)]
pub struct Bytes64(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Bytes64 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Bytes64 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Bytes64 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl ::core::default::Default for Bytes64 {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0,
        ];
        Bytes64::new_unchecked(v.into())
    }
}
impl Bytes64 {
    pub const TOTAL_SIZE: usize = 64;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 64;
    pub fn nth0(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(0..1))
    }
    pub fn nth1(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(1..2))
    }
    pub fn nth2(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(2..3))
    }
    pub fn nth3(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(3..4))
    }
    pub fn nth4(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(4..5))
    }
    pub fn nth5(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(5..6))
    }
    pub fn nth6(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(6..7))
    }
    pub fn nth7(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(7..8))
    }
    pub fn nth8(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(8..9))
    }
    pub fn nth9(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(9..10))
    }
    pub fn nth10(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(10..11))
    }
    pub fn nth11(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(11..12))
    }
    pub fn nth12(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(12..13))
    }
    pub fn nth13(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(13..14))
    }
    pub fn nth14(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(14..15))
    }
    pub fn nth15(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(15..16))
    }
    pub fn nth16(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(16..17))
    }
    pub fn nth17(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(17..18))
    }
    pub fn nth18(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(18..19))
    }
    pub fn nth19(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(19..20))
    }
    pub fn nth20(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(20..21))
    }
    pub fn nth21(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(21..22))
    }
    pub fn nth22(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(22..23))
    }
    pub fn nth23(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(23..24))
    }
    pub fn nth24(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(24..25))
    }
    pub fn nth25(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(25..26))
    }
    pub fn nth26(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(26..27))
    }
    pub fn nth27(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(27..28))
    }
    pub fn nth28(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(28..29))
    }
    pub fn nth29(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(29..30))
    }
    pub fn nth30(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(30..31))
    }
    pub fn nth31(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(31..32))
    }
    pub fn nth32(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(32..33))
    }
    pub fn nth33(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(33..34))
    }
    pub fn nth34(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(34..35))
    }
    pub fn nth35(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(35..36))
    }
    pub fn nth36(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(36..37))
    }
    pub fn nth37(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(37..38))
    }
    pub fn nth38(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(38..39))
    }
    pub fn nth39(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(39..40))
    }
    pub fn nth40(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(40..41))
    }
    pub fn nth41(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(41..42))
    }
    pub fn nth42(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(42..43))
    }
    pub fn nth43(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(43..44))
    }
    pub fn nth44(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(44..45))
    }
    pub fn nth45(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(45..46))
    }
    pub fn nth46(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(46..47))
    }
    pub fn nth47(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(47..48))
    }
    pub fn nth48(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(48..49))
    }
    pub fn nth49(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(49..50))
    }
    pub fn nth50(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(50..51))
    }
    pub fn nth51(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(51..52))
    }
    pub fn nth52(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(52..53))
    }
    pub fn nth53(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(53..54))
    }
    pub fn nth54(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(54..55))
    }
    pub fn nth55(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(55..56))
    }
    pub fn nth56(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(56..57))
    }
    pub fn nth57(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(57..58))
    }
    pub fn nth58(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(58..59))
    }
    pub fn nth59(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(59..60))
    }
    pub fn nth60(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(60..61))
    }
    pub fn nth61(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(61..62))
    }
    pub fn nth62(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(62..63))
    }
    pub fn nth63(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(63..64))
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.as_bytes()
    }
    pub fn as_reader<'r>(&'r self) -> Bytes64Reader<'r> {
        Bytes64Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Bytes64 {
    type Builder = Bytes64Builder;
    const NAME: &'static str = "Bytes64";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Bytes64(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Bytes64Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Bytes64Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([
            self.nth0(),
            self.nth1(),
            self.nth2(),
            self.nth3(),
            self.nth4(),
            self.nth5(),
            self.nth6(),
            self.nth7(),
            self.nth8(),
            self.nth9(),
            self.nth10(),
            self.nth11(),
            self.nth12(),
            self.nth13(),
            self.nth14(),
            self.nth15(),
            self.nth16(),
            self.nth17(),
            self.nth18(),
            self.nth19(),
            self.nth20(),
            self.nth21(),
            self.nth22(),
            self.nth23(),
            self.nth24(),
            self.nth25(),
            self.nth26(),
            self.nth27(),
            self.nth28(),
            self.nth29(),
            self.nth30(),
            self.nth31(),
            self.nth32(),
            self.nth33(),
            self.nth34(),
            self.nth35(),
            self.nth36(),
            self.nth37(),
            self.nth38(),
            self.nth39(),
            self.nth40(),
            self.nth41(),
            self.nth42(),
            self.nth43(),
            self.nth44(),
            self.nth45(),
            self.nth46(),
            self.nth47(),
            self.nth48(),
            self.nth49(),
            self.nth50(),
            self.nth51(),
            self.nth52(),
            self.nth53(),
            self.nth54(),
            self.nth55(),
            self.nth56(),
            self.nth57(),
            self.nth58(),
            self.nth59(),
            self.nth60(),
            self.nth61(),
            self.nth62(),
            self.nth63(),
        ])
    }
}
#[derive(Clone, Copy)]
pub struct Bytes64Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for Bytes64Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for Bytes64Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for Bytes64Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl<'r> Bytes64Reader<'r> {
    pub const TOTAL_SIZE: usize = 64;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 64;
    pub fn nth0(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[0..1])
    }
    pub fn nth1(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[1..2])
    }
    pub fn nth2(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[2..3])
    }
    pub fn nth3(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[3..4])
    }
    pub fn nth4(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[4..5])
    }
    pub fn nth5(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[5..6])
    }
    pub fn nth6(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[6..7])
    }
    pub fn nth7(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[7..8])
    }
    pub fn nth8(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[8..9])
    }
    pub fn nth9(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[9..10])
    }
    pub fn nth10(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[10..11])
    }
    pub fn nth11(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[11..12])
    }
    pub fn nth12(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[12..13])
    }
    pub fn nth13(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[13..14])
    }
    pub fn nth14(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[14..15])
    }
    pub fn nth15(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[15..16])
    }
    pub fn nth16(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[16..17])
    }
    pub fn nth17(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[17..18])
    }
    pub fn nth18(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[18..19])
    }
    pub fn nth19(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[19..20])
    }
    pub fn nth20(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[20..21])
    }
    pub fn nth21(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[21..22])
    }
    pub fn nth22(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[22..23])
    }
    pub fn nth23(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[23..24])
    }
    pub fn nth24(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[24..25])
    }
    pub fn nth25(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[25..26])
    }
    pub fn nth26(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[26..27])
    }
    pub fn nth27(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[27..28])
    }
    pub fn nth28(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[28..29])
    }
    pub fn nth29(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[29..30])
    }
    pub fn nth30(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[30..31])
    }
    pub fn nth31(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[31..32])
    }
    pub fn nth32(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[32..33])
    }
    pub fn nth33(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[33..34])
    }
    pub fn nth34(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[34..35])
    }
    pub fn nth35(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[35..36])
    }
    pub fn nth36(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[36..37])
    }
    pub fn nth37(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[37..38])
    }
    pub fn nth38(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[38..39])
    }
    pub fn nth39(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[39..40])
    }
    pub fn nth40(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[40..41])
    }
    pub fn nth41(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[41..42])
    }
    pub fn nth42(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[42..43])
    }
    pub fn nth43(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[43..44])
    }
    pub fn nth44(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[44..45])
    }
    pub fn nth45(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[45..46])
    }
    pub fn nth46(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[46..47])
    }
    pub fn nth47(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[47..48])
    }
    pub fn nth48(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[48..49])
    }
    pub fn nth49(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[49..50])
    }
    pub fn nth50(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[50..51])
    }
    pub fn nth51(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[51..52])
    }
    pub fn nth52(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[52..53])
    }
    pub fn nth53(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[53..54])
    }
    pub fn nth54(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[54..55])
    }
    pub fn nth55(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[55..56])
    }
    pub fn nth56(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[56..57])
    }
    pub fn nth57(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[57..58])
    }
    pub fn nth58(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[58..59])
    }
    pub fn nth59(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[59..60])
    }
    pub fn nth60(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[60..61])
    }
    pub fn nth61(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[61..62])
    }
    pub fn nth62(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[62..63])
    }
    pub fn nth63(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[63..64])
    }
    pub fn raw_data(&self) -> &'r [u8] {
        self.as_slice()
    }
}
impl<'r> molecule::prelude::Reader<'r> for Bytes64Reader<'r> {
    type Entity = Bytes64;
    const NAME: &'static str = "Bytes64Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        Bytes64Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
pub struct Bytes64Builder(pub(crate) [Byte; 64]);
impl ::core::fmt::Debug for Bytes64Builder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::core::default::Default for Bytes64Builder {
    fn default() -> Self {
        Bytes64Builder([
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
        ])
    }
}
impl Bytes64Builder {
    pub const TOTAL_SIZE: usize = 64;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 64;
    pub fn set(mut self, v: [Byte; 64]) -> Self {
        self.0 = v;
        self
    }
    pub fn nth0(mut self, v: Byte) -> Self {
        self.0[0] = v;
        self
    }
    pub fn nth1(mut self, v: Byte) -> Self {
        self.0[1] = v;
        self
    }
    pub fn nth2(mut self, v: Byte) -> Self {
        self.0[2] = v;
        self
    }
    pub fn nth3(mut self, v: Byte) -> Self {
        self.0[3] = v;
        self
    }
    pub fn nth4(mut self, v: Byte) -> Self {
        self.0[4] = v;
        self
    }
    pub fn nth5(mut self, v: Byte) -> Self {
        self.0[5] = v;
        self
    }
    pub fn nth6(mut self, v: Byte) -> Self {
        self.0[6] = v;
        self
    }
    pub fn nth7(mut self, v: Byte) -> Self {
        self.0[7] = v;
        self
    }
    pub fn nth8(mut self, v: Byte) -> Self {
        self.0[8] = v;
        self
    }
    pub fn nth9(mut self, v: Byte) -> Self {
        self.0[9] = v;
        self
    }
    pub fn nth10(mut self, v: Byte) -> Self {
        self.0[10] = v;
        self
    }
    pub fn nth11(mut self, v: Byte) -> Self {
        self.0[11] = v;
        self
    }
    pub fn nth12(mut self, v: Byte) -> Self {
        self.0[12] = v;
        self
    }
    pub fn nth13(mut self, v: Byte) -> Self {
        self.0[13] = v;
        self
    }
    pub fn nth14(mut self, v: Byte) -> Self {
        self.0[14] = v;
        self
    }
    pub fn nth15(mut self, v: Byte) -> Self {
        self.0[15] = v;
        self
    }
    pub fn nth16(mut self, v: Byte) -> Self {
        self.0[16] = v;
        self
    }
    pub fn nth17(mut self, v: Byte) -> Self {
        self.0[17] = v;
        self
    }
    pub fn nth18(mut self, v: Byte) -> Self {
        self.0[18] = v;
        self
    }
    pub fn nth19(mut self, v: Byte) -> Self {
        self.0[19] = v;
        self
    }
    pub fn nth20(mut self, v: Byte) -> Self {
        self.0[20] = v;
        self
    }
    pub fn nth21(mut self, v: Byte) -> Self {
        self.0[21] = v;
        self
    }
    pub fn nth22(mut self, v: Byte) -> Self {
        self.0[22] = v;
        self
    }
    pub fn nth23(mut self, v: Byte) -> Self {
        self.0[23] = v;
        self
    }
    pub fn nth24(mut self, v: Byte) -> Self {
        self.0[24] = v;
        self
    }
    pub fn nth25(mut self, v: Byte) -> Self {
        self.0[25] = v;
        self
    }
    pub fn nth26(mut self, v: Byte) -> Self {
        self.0[26] = v;
        self
    }
    pub fn nth27(mut self, v: Byte) -> Self {
        self.0[27] = v;
        self
    }
    pub fn nth28(mut self, v: Byte) -> Self {
        self.0[28] = v;
        self
    }
    pub fn nth29(mut self, v: Byte) -> Self {
        self.0[29] = v;
        self
    }
    pub fn nth30(mut self, v: Byte) -> Self {
        self.0[30] = v;
        self
    }
    pub fn nth31(mut self, v: Byte) -> Self {
        self.0[31] = v;
        self
    }
    pub fn nth32(mut self, v: Byte) -> Self {
        self.0[32] = v;
        self
    }
    pub fn nth33(mut self, v: Byte) -> Self {
        self.0[33] = v;
        self
    }
    pub fn nth34(mut self, v: Byte) -> Self {
        self.0[34] = v;
        self
    }
    pub fn nth35(mut self, v: Byte) -> Self {
        self.0[35] = v;
        self
    }
    pub fn nth36(mut self, v: Byte) -> Self {
        self.0[36] = v;
        self
    }
    pub fn nth37(mut self, v: Byte) -> Self {
        self.0[37] = v;
        self
    }
    pub fn nth38(mut self, v: Byte) -> Self {
        self.0[38] = v;
        self
    }
    pub fn nth39(mut self, v: Byte) -> Self {
        self.0[39] = v;
        self
    }
    pub fn nth40(mut self, v: Byte) -> Self {
        self.0[40] = v;
        self
    }
    pub fn nth41(mut self, v: Byte) -> Self {
        self.0[41] = v;
        self
    }
    pub fn nth42(mut self, v: Byte) -> Self {
        self.0[42] = v;
        self
    }
    pub fn nth43(mut self, v: Byte) -> Self {
        self.0[43] = v;
        self
    }
    pub fn nth44(mut self, v: Byte) -> Self {
        self.0[44] = v;
        self
    }
    pub fn nth45(mut self, v: Byte) -> Self {
        self.0[45] = v;
        self
    }
    pub fn nth46(mut self, v: Byte) -> Self {
        self.0[46] = v;
        self
    }
    pub fn nth47(mut self, v: Byte) -> Self {
        self.0[47] = v;
        self
    }
    pub fn nth48(mut self, v: Byte) -> Self {
        self.0[48] = v;
        self
    }
    pub fn nth49(mut self, v: Byte) -> Self {
        self.0[49] = v;
        self
    }
    pub fn nth50(mut self, v: Byte) -> Self {
        self.0[50] = v;
        self
    }
    pub fn nth51(mut self, v: Byte) -> Self {
        self.0[51] = v;
        self
    }
    pub fn nth52(mut self, v: Byte) -> Self {
        self.0[52] = v;
        self
    }
    pub fn nth53(mut self, v: Byte) -> Self {
        self.0[53] = v;
        self
    }
    pub fn nth54(mut self, v: Byte) -> Self {
        self.0[54] = v;
        self
    }
    pub fn nth55(mut self, v: Byte) -> Self {
        self.0[55] = v;
        self
    }
    pub fn nth56(mut self, v: Byte) -> Self {
        self.0[56] = v;
        self
    }
    pub fn nth57(mut self, v: Byte) -> Self {
        self.0[57] = v;
        self
    }
    pub fn nth58(mut self, v: Byte) -> Self {
        self.0[58] = v;
        self
    }
    pub fn nth59(mut self, v: Byte) -> Self {
        self.0[59] = v;
        self
    }
    pub fn nth60(mut self, v: Byte) -> Self {
        self.0[60] = v;
        self
    }
    pub fn nth61(mut self, v: Byte) -> Self {
        self.0[61] = v;
        self
    }
    pub fn nth62(mut self, v: Byte) -> Self {
        self.0[62] = v;
        self
    }
    pub fn nth63(mut self, v: Byte) -> Self {
        self.0[63] = v;
        self
    }
}
impl molecule::prelude::Builder for Bytes64Builder {
    type Entity = Bytes64;
    const NAME: &'static str = "Bytes64Builder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.0[0].as_slice())?;
        writer.write_all(self.0[1].as_slice())?;
        writer.write_all(self.0[2].as_slice())?;
        writer.write_all(self.0[3].as_slice())?;
        writer.write_all(self.0[4].as_slice())?;
        writer.write_all(self.0[5].as_slice())?;
        writer.write_all(self.0[6].as_slice())?;
        writer.write_all(self.0[7].as_slice())?;
        writer.write_all(self.0[8].as_slice())?;
        writer.write_all(self.0[9].as_slice())?;
        writer.write_all(self.0[10].as_slice())?;
        writer.write_all(self.0[11].as_slice())?;
        writer.write_all(self.0[12].as_slice())?;
        writer.write_all(self.0[13].as_slice())?;
        writer.write_all(self.0[14].as_slice())?;
        writer.write_all(self.0[15].as_slice())?;
        writer.write_all(self.0[16].as_slice())?;
        writer.write_all(self.0[17].as_slice())?;
        writer.write_all(self.0[18].as_slice())?;
        writer.write_all(self.0[19].as_slice())?;
        writer.write_all(self.0[20].as_slice())?;
        writer.write_all(self.0[21].as_slice())?;
        writer.write_all(self.0[22].as_slice())?;
        writer.write_all(self.0[23].as_slice())?;
        writer.write_all(self.0[24].as_slice())?;
        writer.write_all(self.0[25].as_slice())?;
        writer.write_all(self.0[26].as_slice())?;
        writer.write_all(self.0[27].as_slice())?;
        writer.write_all(self.0[28].as_slice())?;
        writer.write_all(self.0[29].as_slice())?;
        writer.write_all(self.0[30].as_slice())?;
        writer.write_all(self.0[31].as_slice())?;
        writer.write_all(self.0[32].as_slice())?;
        writer.write_all(self.0[33].as_slice())?;
        writer.write_all(self.0[34].as_slice())?;
        writer.write_all(self.0[35].as_slice())?;
        writer.write_all(self.0[36].as_slice())?;
        writer.write_all(self.0[37].as_slice())?;
        writer.write_all(self.0[38].as_slice())?;
        writer.write_all(self.0[39].as_slice())?;
        writer.write_all(self.0[40].as_slice())?;
        writer.write_all(self.0[41].as_slice())?;
        writer.write_all(self.0[42].as_slice())?;
        writer.write_all(self.0[43].as_slice())?;
        writer.write_all(self.0[44].as_slice())?;
        writer.write_all(self.0[45].as_slice())?;
        writer.write_all(self.0[46].as_slice())?;
        writer.write_all(self.0[47].as_slice())?;
        writer.write_all(self.0[48].as_slice())?;
        writer.write_all(self.0[49].as_slice())?;
        writer.write_all(self.0[50].as_slice())?;
        writer.write_all(self.0[51].as_slice())?;
        writer.write_all(self.0[52].as_slice())?;
        writer.write_all(self.0[53].as_slice())?;
        writer.write_all(self.0[54].as_slice())?;
        writer.write_all(self.0[55].as_slice())?;
        writer.write_all(self.0[56].as_slice())?;
        writer.write_all(self.0[57].as_slice())?;
        writer.write_all(self.0[58].as_slice())?;
        writer.write_all(self.0[59].as_slice())?;
        writer.write_all(self.0[60].as_slice())?;
        writer.write_all(self.0[61].as_slice())?;
        writer.write_all(self.0[62].as_slice())?;
        writer.write_all(self.0[63].as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Bytes64::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct BlsPubkey(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for BlsPubkey {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for BlsPubkey {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for BlsPubkey {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl ::core::default::Default for BlsPubkey {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0,
        ];
        BlsPubkey::new_unchecked(v.into())
    }
}
impl BlsPubkey {
    pub const TOTAL_SIZE: usize = 32;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 32;
    pub fn nth0(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(0..1))
    }
    pub fn nth1(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(1..2))
    }
    pub fn nth2(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(2..3))
    }
    pub fn nth3(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(3..4))
    }
    pub fn nth4(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(4..5))
    }
    pub fn nth5(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(5..6))
    }
    pub fn nth6(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(6..7))
    }
    pub fn nth7(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(7..8))
    }
    pub fn nth8(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(8..9))
    }
    pub fn nth9(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(9..10))
    }
    pub fn nth10(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(10..11))
    }
    pub fn nth11(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(11..12))
    }
    pub fn nth12(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(12..13))
    }
    pub fn nth13(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(13..14))
    }
    pub fn nth14(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(14..15))
    }
    pub fn nth15(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(15..16))
    }
    pub fn nth16(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(16..17))
    }
    pub fn nth17(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(17..18))
    }
    pub fn nth18(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(18..19))
    }
    pub fn nth19(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(19..20))
    }
    pub fn nth20(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(20..21))
    }
    pub fn nth21(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(21..22))
    }
    pub fn nth22(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(22..23))
    }
    pub fn nth23(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(23..24))
    }
    pub fn nth24(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(24..25))
    }
    pub fn nth25(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(25..26))
    }
    pub fn nth26(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(26..27))
    }
    pub fn nth27(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(27..28))
    }
    pub fn nth28(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(28..29))
    }
    pub fn nth29(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(29..30))
    }
    pub fn nth30(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(30..31))
    }
    pub fn nth31(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(31..32))
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.as_bytes()
    }
    pub fn as_reader<'r>(&'r self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for BlsPubkey {
    type Builder = BlsPubkeyBuilder;
    const NAME: &'static str = "BlsPubkey";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        BlsPubkey(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BlsPubkeyReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BlsPubkeyReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([
            self.nth0(),
            self.nth1(),
            self.nth2(),
            self.nth3(),
            self.nth4(),
            self.nth5(),
            self.nth6(),
            self.nth7(),
            self.nth8(),
            self.nth9(),
            self.nth10(),
            self.nth11(),
            self.nth12(),
            self.nth13(),
            self.nth14(),
            self.nth15(),
            self.nth16(),
            self.nth17(),
            self.nth18(),
            self.nth19(),
            self.nth20(),
            self.nth21(),
            self.nth22(),
            self.nth23(),
            self.nth24(),
            self.nth25(),
            self.nth26(),
            self.nth27(),
            self.nth28(),
            self.nth29(),
            self.nth30(),
            self.nth31(),
        ])
    }
}
#[derive(Clone, Copy)]
pub struct BlsPubkeyReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for BlsPubkeyReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for BlsPubkeyReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for BlsPubkeyReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl<'r> BlsPubkeyReader<'r> {
    pub const TOTAL_SIZE: usize = 32;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 32;
    pub fn nth0(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[0..1])
    }
    pub fn nth1(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[1..2])
    }
    pub fn nth2(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[2..3])
    }
    pub fn nth3(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[3..4])
    }
    pub fn nth4(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[4..5])
    }
    pub fn nth5(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[5..6])
    }
    pub fn nth6(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[6..7])
    }
    pub fn nth7(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[7..8])
    }
    pub fn nth8(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[8..9])
    }
    pub fn nth9(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[9..10])
    }
    pub fn nth10(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[10..11])
    }
    pub fn nth11(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[11..12])
    }
    pub fn nth12(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[12..13])
    }
    pub fn nth13(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[13..14])
    }
    pub fn nth14(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[14..15])
    }
    pub fn nth15(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[15..16])
    }
    pub fn nth16(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[16..17])
    }
    pub fn nth17(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[17..18])
    }
    pub fn nth18(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[18..19])
    }
    pub fn nth19(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[19..20])
    }
    pub fn nth20(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[20..21])
    }
    pub fn nth21(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[21..22])
    }
    pub fn nth22(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[22..23])
    }
    pub fn nth23(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[23..24])
    }
    pub fn nth24(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[24..25])
    }
    pub fn nth25(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[25..26])
    }
    pub fn nth26(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[26..27])
    }
    pub fn nth27(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[27..28])
    }
    pub fn nth28(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[28..29])
    }
    pub fn nth29(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[29..30])
    }
    pub fn nth30(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[30..31])
    }
    pub fn nth31(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[31..32])
    }
    pub fn raw_data(&self) -> &'r [u8] {
        self.as_slice()
    }
}
impl<'r> molecule::prelude::Reader<'r> for BlsPubkeyReader<'r> {
    type Entity = BlsPubkey;
    const NAME: &'static str = "BlsPubkeyReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        BlsPubkeyReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
pub struct BlsPubkeyBuilder(pub(crate) [Byte; 32]);
impl ::core::fmt::Debug for BlsPubkeyBuilder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::core::default::Default for BlsPubkeyBuilder {
    fn default() -> Self {
        BlsPubkeyBuilder([
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
        ])
    }
}
impl BlsPubkeyBuilder {
    pub const TOTAL_SIZE: usize = 32;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 32;
    pub fn set(mut self, v: [Byte; 32]) -> Self {
        self.0 = v;
        self
    }
    pub fn nth0(mut self, v: Byte) -> Self {
        self.0[0] = v;
        self
    }
    pub fn nth1(mut self, v: Byte) -> Self {
        self.0[1] = v;
        self
    }
    pub fn nth2(mut self, v: Byte) -> Self {
        self.0[2] = v;
        self
    }
    pub fn nth3(mut self, v: Byte) -> Self {
        self.0[3] = v;
        self
    }
    pub fn nth4(mut self, v: Byte) -> Self {
        self.0[4] = v;
        self
    }
    pub fn nth5(mut self, v: Byte) -> Self {
        self.0[5] = v;
        self
    }
    pub fn nth6(mut self, v: Byte) -> Self {
        self.0[6] = v;
        self
    }
    pub fn nth7(mut self, v: Byte) -> Self {
        self.0[7] = v;
        self
    }
    pub fn nth8(mut self, v: Byte) -> Self {
        self.0[8] = v;
        self
    }
    pub fn nth9(mut self, v: Byte) -> Self {
        self.0[9] = v;
        self
    }
    pub fn nth10(mut self, v: Byte) -> Self {
        self.0[10] = v;
        self
    }
    pub fn nth11(mut self, v: Byte) -> Self {
        self.0[11] = v;
        self
    }
    pub fn nth12(mut self, v: Byte) -> Self {
        self.0[12] = v;
        self
    }
    pub fn nth13(mut self, v: Byte) -> Self {
        self.0[13] = v;
        self
    }
    pub fn nth14(mut self, v: Byte) -> Self {
        self.0[14] = v;
        self
    }
    pub fn nth15(mut self, v: Byte) -> Self {
        self.0[15] = v;
        self
    }
    pub fn nth16(mut self, v: Byte) -> Self {
        self.0[16] = v;
        self
    }
    pub fn nth17(mut self, v: Byte) -> Self {
        self.0[17] = v;
        self
    }
    pub fn nth18(mut self, v: Byte) -> Self {
        self.0[18] = v;
        self
    }
    pub fn nth19(mut self, v: Byte) -> Self {
        self.0[19] = v;
        self
    }
    pub fn nth20(mut self, v: Byte) -> Self {
        self.0[20] = v;
        self
    }
    pub fn nth21(mut self, v: Byte) -> Self {
        self.0[21] = v;
        self
    }
    pub fn nth22(mut self, v: Byte) -> Self {
        self.0[22] = v;
        self
    }
    pub fn nth23(mut self, v: Byte) -> Self {
        self.0[23] = v;
        self
    }
    pub fn nth24(mut self, v: Byte) -> Self {
        self.0[24] = v;
        self
    }
    pub fn nth25(mut self, v: Byte) -> Self {
        self.0[25] = v;
        self
    }
    pub fn nth26(mut self, v: Byte) -> Self {
        self.0[26] = v;
        self
    }
    pub fn nth27(mut self, v: Byte) -> Self {
        self.0[27] = v;
        self
    }
    pub fn nth28(mut self, v: Byte) -> Self {
        self.0[28] = v;
        self
    }
    pub fn nth29(mut self, v: Byte) -> Self {
        self.0[29] = v;
        self
    }
    pub fn nth30(mut self, v: Byte) -> Self {
        self.0[30] = v;
        self
    }
    pub fn nth31(mut self, v: Byte) -> Self {
        self.0[31] = v;
        self
    }
}
impl molecule::prelude::Builder for BlsPubkeyBuilder {
    type Entity = BlsPubkey;
    const NAME: &'static str = "BlsPubkeyBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.0[0].as_slice())?;
        writer.write_all(self.0[1].as_slice())?;
        writer.write_all(self.0[2].as_slice())?;
        writer.write_all(self.0[3].as_slice())?;
        writer.write_all(self.0[4].as_slice())?;
        writer.write_all(self.0[5].as_slice())?;
        writer.write_all(self.0[6].as_slice())?;
        writer.write_all(self.0[7].as_slice())?;
        writer.write_all(self.0[8].as_slice())?;
        writer.write_all(self.0[9].as_slice())?;
        writer.write_all(self.0[10].as_slice())?;
        writer.write_all(self.0[11].as_slice())?;
        writer.write_all(self.0[12].as_slice())?;
        writer.write_all(self.0[13].as_slice())?;
        writer.write_all(self.0[14].as_slice())?;
        writer.write_all(self.0[15].as_slice())?;
        writer.write_all(self.0[16].as_slice())?;
        writer.write_all(self.0[17].as_slice())?;
        writer.write_all(self.0[18].as_slice())?;
        writer.write_all(self.0[19].as_slice())?;
        writer.write_all(self.0[20].as_slice())?;
        writer.write_all(self.0[21].as_slice())?;
        writer.write_all(self.0[22].as_slice())?;
        writer.write_all(self.0[23].as_slice())?;
        writer.write_all(self.0[24].as_slice())?;
        writer.write_all(self.0[25].as_slice())?;
        writer.write_all(self.0[26].as_slice())?;
        writer.write_all(self.0[27].as_slice())?;
        writer.write_all(self.0[28].as_slice())?;
        writer.write_all(self.0[29].as_slice())?;
        writer.write_all(self.0[30].as_slice())?;
        writer.write_all(self.0[31].as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        BlsPubkey::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct BlsSignature(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for BlsSignature {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for BlsSignature {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for BlsSignature {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl ::core::default::Default for BlsSignature {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        BlsSignature::new_unchecked(v.into())
    }
}
impl BlsSignature {
    pub const TOTAL_SIZE: usize = 96;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 96;
    pub fn nth0(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(0..1))
    }
    pub fn nth1(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(1..2))
    }
    pub fn nth2(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(2..3))
    }
    pub fn nth3(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(3..4))
    }
    pub fn nth4(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(4..5))
    }
    pub fn nth5(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(5..6))
    }
    pub fn nth6(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(6..7))
    }
    pub fn nth7(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(7..8))
    }
    pub fn nth8(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(8..9))
    }
    pub fn nth9(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(9..10))
    }
    pub fn nth10(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(10..11))
    }
    pub fn nth11(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(11..12))
    }
    pub fn nth12(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(12..13))
    }
    pub fn nth13(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(13..14))
    }
    pub fn nth14(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(14..15))
    }
    pub fn nth15(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(15..16))
    }
    pub fn nth16(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(16..17))
    }
    pub fn nth17(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(17..18))
    }
    pub fn nth18(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(18..19))
    }
    pub fn nth19(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(19..20))
    }
    pub fn nth20(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(20..21))
    }
    pub fn nth21(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(21..22))
    }
    pub fn nth22(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(22..23))
    }
    pub fn nth23(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(23..24))
    }
    pub fn nth24(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(24..25))
    }
    pub fn nth25(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(25..26))
    }
    pub fn nth26(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(26..27))
    }
    pub fn nth27(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(27..28))
    }
    pub fn nth28(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(28..29))
    }
    pub fn nth29(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(29..30))
    }
    pub fn nth30(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(30..31))
    }
    pub fn nth31(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(31..32))
    }
    pub fn nth32(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(32..33))
    }
    pub fn nth33(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(33..34))
    }
    pub fn nth34(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(34..35))
    }
    pub fn nth35(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(35..36))
    }
    pub fn nth36(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(36..37))
    }
    pub fn nth37(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(37..38))
    }
    pub fn nth38(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(38..39))
    }
    pub fn nth39(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(39..40))
    }
    pub fn nth40(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(40..41))
    }
    pub fn nth41(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(41..42))
    }
    pub fn nth42(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(42..43))
    }
    pub fn nth43(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(43..44))
    }
    pub fn nth44(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(44..45))
    }
    pub fn nth45(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(45..46))
    }
    pub fn nth46(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(46..47))
    }
    pub fn nth47(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(47..48))
    }
    pub fn nth48(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(48..49))
    }
    pub fn nth49(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(49..50))
    }
    pub fn nth50(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(50..51))
    }
    pub fn nth51(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(51..52))
    }
    pub fn nth52(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(52..53))
    }
    pub fn nth53(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(53..54))
    }
    pub fn nth54(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(54..55))
    }
    pub fn nth55(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(55..56))
    }
    pub fn nth56(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(56..57))
    }
    pub fn nth57(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(57..58))
    }
    pub fn nth58(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(58..59))
    }
    pub fn nth59(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(59..60))
    }
    pub fn nth60(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(60..61))
    }
    pub fn nth61(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(61..62))
    }
    pub fn nth62(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(62..63))
    }
    pub fn nth63(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(63..64))
    }
    pub fn nth64(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(64..65))
    }
    pub fn nth65(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(65..66))
    }
    pub fn nth66(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(66..67))
    }
    pub fn nth67(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(67..68))
    }
    pub fn nth68(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(68..69))
    }
    pub fn nth69(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(69..70))
    }
    pub fn nth70(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(70..71))
    }
    pub fn nth71(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(71..72))
    }
    pub fn nth72(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(72..73))
    }
    pub fn nth73(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(73..74))
    }
    pub fn nth74(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(74..75))
    }
    pub fn nth75(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(75..76))
    }
    pub fn nth76(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(76..77))
    }
    pub fn nth77(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(77..78))
    }
    pub fn nth78(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(78..79))
    }
    pub fn nth79(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(79..80))
    }
    pub fn nth80(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(80..81))
    }
    pub fn nth81(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(81..82))
    }
    pub fn nth82(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(82..83))
    }
    pub fn nth83(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(83..84))
    }
    pub fn nth84(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(84..85))
    }
    pub fn nth85(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(85..86))
    }
    pub fn nth86(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(86..87))
    }
    pub fn nth87(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(87..88))
    }
    pub fn nth88(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(88..89))
    }
    pub fn nth89(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(89..90))
    }
    pub fn nth90(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(90..91))
    }
    pub fn nth91(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(91..92))
    }
    pub fn nth92(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(92..93))
    }
    pub fn nth93(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(93..94))
    }
    pub fn nth94(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(94..95))
    }
    pub fn nth95(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(95..96))
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.as_bytes()
    }
    pub fn as_reader<'r>(&'r self) -> BlsSignatureReader<'r> {
        BlsSignatureReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for BlsSignature {
    type Builder = BlsSignatureBuilder;
    const NAME: &'static str = "BlsSignature";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        BlsSignature(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BlsSignatureReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BlsSignatureReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([
            self.nth0(),
            self.nth1(),
            self.nth2(),
            self.nth3(),
            self.nth4(),
            self.nth5(),
            self.nth6(),
            self.nth7(),
            self.nth8(),
            self.nth9(),
            self.nth10(),
            self.nth11(),
            self.nth12(),
            self.nth13(),
            self.nth14(),
            self.nth15(),
            self.nth16(),
            self.nth17(),
            self.nth18(),
            self.nth19(),
            self.nth20(),
            self.nth21(),
            self.nth22(),
            self.nth23(),
            self.nth24(),
            self.nth25(),
            self.nth26(),
            self.nth27(),
            self.nth28(),
            self.nth29(),
            self.nth30(),
            self.nth31(),
            self.nth32(),
            self.nth33(),
            self.nth34(),
            self.nth35(),
            self.nth36(),
            self.nth37(),
            self.nth38(),
            self.nth39(),
            self.nth40(),
            self.nth41(),
            self.nth42(),
            self.nth43(),
            self.nth44(),
            self.nth45(),
            self.nth46(),
            self.nth47(),
            self.nth48(),
            self.nth49(),
            self.nth50(),
            self.nth51(),
            self.nth52(),
            self.nth53(),
            self.nth54(),
            self.nth55(),
            self.nth56(),
            self.nth57(),
            self.nth58(),
            self.nth59(),
            self.nth60(),
            self.nth61(),
            self.nth62(),
            self.nth63(),
            self.nth64(),
            self.nth65(),
            self.nth66(),
            self.nth67(),
            self.nth68(),
            self.nth69(),
            self.nth70(),
            self.nth71(),
            self.nth72(),
            self.nth73(),
            self.nth74(),
            self.nth75(),
            self.nth76(),
            self.nth77(),
            self.nth78(),
            self.nth79(),
            self.nth80(),
            self.nth81(),
            self.nth82(),
            self.nth83(),
            self.nth84(),
            self.nth85(),
            self.nth86(),
            self.nth87(),
            self.nth88(),
            self.nth89(),
            self.nth90(),
            self.nth91(),
            self.nth92(),
            self.nth93(),
            self.nth94(),
            self.nth95(),
        ])
    }
}
#[derive(Clone, Copy)]
pub struct BlsSignatureReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for BlsSignatureReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for BlsSignatureReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for BlsSignatureReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl<'r> BlsSignatureReader<'r> {
    pub const TOTAL_SIZE: usize = 96;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 96;
    pub fn nth0(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[0..1])
    }
    pub fn nth1(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[1..2])
    }
    pub fn nth2(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[2..3])
    }
    pub fn nth3(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[3..4])
    }
    pub fn nth4(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[4..5])
    }
    pub fn nth5(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[5..6])
    }
    pub fn nth6(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[6..7])
    }
    pub fn nth7(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[7..8])
    }
    pub fn nth8(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[8..9])
    }
    pub fn nth9(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[9..10])
    }
    pub fn nth10(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[10..11])
    }
    pub fn nth11(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[11..12])
    }
    pub fn nth12(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[12..13])
    }
    pub fn nth13(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[13..14])
    }
    pub fn nth14(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[14..15])
    }
    pub fn nth15(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[15..16])
    }
    pub fn nth16(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[16..17])
    }
    pub fn nth17(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[17..18])
    }
    pub fn nth18(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[18..19])
    }
    pub fn nth19(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[19..20])
    }
    pub fn nth20(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[20..21])
    }
    pub fn nth21(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[21..22])
    }
    pub fn nth22(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[22..23])
    }
    pub fn nth23(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[23..24])
    }
    pub fn nth24(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[24..25])
    }
    pub fn nth25(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[25..26])
    }
    pub fn nth26(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[26..27])
    }
    pub fn nth27(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[27..28])
    }
    pub fn nth28(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[28..29])
    }
    pub fn nth29(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[29..30])
    }
    pub fn nth30(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[30..31])
    }
    pub fn nth31(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[31..32])
    }
    pub fn nth32(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[32..33])
    }
    pub fn nth33(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[33..34])
    }
    pub fn nth34(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[34..35])
    }
    pub fn nth35(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[35..36])
    }
    pub fn nth36(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[36..37])
    }
    pub fn nth37(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[37..38])
    }
    pub fn nth38(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[38..39])
    }
    pub fn nth39(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[39..40])
    }
    pub fn nth40(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[40..41])
    }
    pub fn nth41(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[41..42])
    }
    pub fn nth42(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[42..43])
    }
    pub fn nth43(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[43..44])
    }
    pub fn nth44(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[44..45])
    }
    pub fn nth45(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[45..46])
    }
    pub fn nth46(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[46..47])
    }
    pub fn nth47(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[47..48])
    }
    pub fn nth48(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[48..49])
    }
    pub fn nth49(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[49..50])
    }
    pub fn nth50(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[50..51])
    }
    pub fn nth51(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[51..52])
    }
    pub fn nth52(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[52..53])
    }
    pub fn nth53(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[53..54])
    }
    pub fn nth54(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[54..55])
    }
    pub fn nth55(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[55..56])
    }
    pub fn nth56(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[56..57])
    }
    pub fn nth57(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[57..58])
    }
    pub fn nth58(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[58..59])
    }
    pub fn nth59(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[59..60])
    }
    pub fn nth60(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[60..61])
    }
    pub fn nth61(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[61..62])
    }
    pub fn nth62(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[62..63])
    }
    pub fn nth63(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[63..64])
    }
    pub fn nth64(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[64..65])
    }
    pub fn nth65(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[65..66])
    }
    pub fn nth66(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[66..67])
    }
    pub fn nth67(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[67..68])
    }
    pub fn nth68(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[68..69])
    }
    pub fn nth69(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[69..70])
    }
    pub fn nth70(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[70..71])
    }
    pub fn nth71(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[71..72])
    }
    pub fn nth72(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[72..73])
    }
    pub fn nth73(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[73..74])
    }
    pub fn nth74(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[74..75])
    }
    pub fn nth75(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[75..76])
    }
    pub fn nth76(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[76..77])
    }
    pub fn nth77(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[77..78])
    }
    pub fn nth78(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[78..79])
    }
    pub fn nth79(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[79..80])
    }
    pub fn nth80(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[80..81])
    }
    pub fn nth81(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[81..82])
    }
    pub fn nth82(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[82..83])
    }
    pub fn nth83(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[83..84])
    }
    pub fn nth84(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[84..85])
    }
    pub fn nth85(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[85..86])
    }
    pub fn nth86(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[86..87])
    }
    pub fn nth87(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[87..88])
    }
    pub fn nth88(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[88..89])
    }
    pub fn nth89(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[89..90])
    }
    pub fn nth90(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[90..91])
    }
    pub fn nth91(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[91..92])
    }
    pub fn nth92(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[92..93])
    }
    pub fn nth93(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[93..94])
    }
    pub fn nth94(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[94..95])
    }
    pub fn nth95(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[95..96])
    }
    pub fn raw_data(&self) -> &'r [u8] {
        self.as_slice()
    }
}
impl<'r> molecule::prelude::Reader<'r> for BlsSignatureReader<'r> {
    type Entity = BlsSignature;
    const NAME: &'static str = "BlsSignatureReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        BlsSignatureReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
pub struct BlsSignatureBuilder(pub(crate) [Byte; 96]);
impl ::core::fmt::Debug for BlsSignatureBuilder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::core::default::Default for BlsSignatureBuilder {
    fn default() -> Self {
        BlsSignatureBuilder([
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
        ])
    }
}
impl BlsSignatureBuilder {
    pub const TOTAL_SIZE: usize = 96;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 96;
    pub fn set(mut self, v: [Byte; 96]) -> Self {
        self.0 = v;
        self
    }
    pub fn nth0(mut self, v: Byte) -> Self {
        self.0[0] = v;
        self
    }
    pub fn nth1(mut self, v: Byte) -> Self {
        self.0[1] = v;
        self
    }
    pub fn nth2(mut self, v: Byte) -> Self {
        self.0[2] = v;
        self
    }
    pub fn nth3(mut self, v: Byte) -> Self {
        self.0[3] = v;
        self
    }
    pub fn nth4(mut self, v: Byte) -> Self {
        self.0[4] = v;
        self
    }
    pub fn nth5(mut self, v: Byte) -> Self {
        self.0[5] = v;
        self
    }
    pub fn nth6(mut self, v: Byte) -> Self {
        self.0[6] = v;
        self
    }
    pub fn nth7(mut self, v: Byte) -> Self {
        self.0[7] = v;
        self
    }
    pub fn nth8(mut self, v: Byte) -> Self {
        self.0[8] = v;
        self
    }
    pub fn nth9(mut self, v: Byte) -> Self {
        self.0[9] = v;
        self
    }
    pub fn nth10(mut self, v: Byte) -> Self {
        self.0[10] = v;
        self
    }
    pub fn nth11(mut self, v: Byte) -> Self {
        self.0[11] = v;
        self
    }
    pub fn nth12(mut self, v: Byte) -> Self {
        self.0[12] = v;
        self
    }
    pub fn nth13(mut self, v: Byte) -> Self {
        self.0[13] = v;
        self
    }
    pub fn nth14(mut self, v: Byte) -> Self {
        self.0[14] = v;
        self
    }
    pub fn nth15(mut self, v: Byte) -> Self {
        self.0[15] = v;
        self
    }
    pub fn nth16(mut self, v: Byte) -> Self {
        self.0[16] = v;
        self
    }
    pub fn nth17(mut self, v: Byte) -> Self {
        self.0[17] = v;
        self
    }
    pub fn nth18(mut self, v: Byte) -> Self {
        self.0[18] = v;
        self
    }
    pub fn nth19(mut self, v: Byte) -> Self {
        self.0[19] = v;
        self
    }
    pub fn nth20(mut self, v: Byte) -> Self {
        self.0[20] = v;
        self
    }
    pub fn nth21(mut self, v: Byte) -> Self {
        self.0[21] = v;
        self
    }
    pub fn nth22(mut self, v: Byte) -> Self {
        self.0[22] = v;
        self
    }
    pub fn nth23(mut self, v: Byte) -> Self {
        self.0[23] = v;
        self
    }
    pub fn nth24(mut self, v: Byte) -> Self {
        self.0[24] = v;
        self
    }
    pub fn nth25(mut self, v: Byte) -> Self {
        self.0[25] = v;
        self
    }
    pub fn nth26(mut self, v: Byte) -> Self {
        self.0[26] = v;
        self
    }
    pub fn nth27(mut self, v: Byte) -> Self {
        self.0[27] = v;
        self
    }
    pub fn nth28(mut self, v: Byte) -> Self {
        self.0[28] = v;
        self
    }
    pub fn nth29(mut self, v: Byte) -> Self {
        self.0[29] = v;
        self
    }
    pub fn nth30(mut self, v: Byte) -> Self {
        self.0[30] = v;
        self
    }
    pub fn nth31(mut self, v: Byte) -> Self {
        self.0[31] = v;
        self
    }
    pub fn nth32(mut self, v: Byte) -> Self {
        self.0[32] = v;
        self
    }
    pub fn nth33(mut self, v: Byte) -> Self {
        self.0[33] = v;
        self
    }
    pub fn nth34(mut self, v: Byte) -> Self {
        self.0[34] = v;
        self
    }
    pub fn nth35(mut self, v: Byte) -> Self {
        self.0[35] = v;
        self
    }
    pub fn nth36(mut self, v: Byte) -> Self {
        self.0[36] = v;
        self
    }
    pub fn nth37(mut self, v: Byte) -> Self {
        self.0[37] = v;
        self
    }
    pub fn nth38(mut self, v: Byte) -> Self {
        self.0[38] = v;
        self
    }
    pub fn nth39(mut self, v: Byte) -> Self {
        self.0[39] = v;
        self
    }
    pub fn nth40(mut self, v: Byte) -> Self {
        self.0[40] = v;
        self
    }
    pub fn nth41(mut self, v: Byte) -> Self {
        self.0[41] = v;
        self
    }
    pub fn nth42(mut self, v: Byte) -> Self {
        self.0[42] = v;
        self
    }
    pub fn nth43(mut self, v: Byte) -> Self {
        self.0[43] = v;
        self
    }
    pub fn nth44(mut self, v: Byte) -> Self {
        self.0[44] = v;
        self
    }
    pub fn nth45(mut self, v: Byte) -> Self {
        self.0[45] = v;
        self
    }
    pub fn nth46(mut self, v: Byte) -> Self {
        self.0[46] = v;
        self
    }
    pub fn nth47(mut self, v: Byte) -> Self {
        self.0[47] = v;
        self
    }
    pub fn nth48(mut self, v: Byte) -> Self {
        self.0[48] = v;
        self
    }
    pub fn nth49(mut self, v: Byte) -> Self {
        self.0[49] = v;
        self
    }
    pub fn nth50(mut self, v: Byte) -> Self {
        self.0[50] = v;
        self
    }
    pub fn nth51(mut self, v: Byte) -> Self {
        self.0[51] = v;
        self
    }
    pub fn nth52(mut self, v: Byte) -> Self {
        self.0[52] = v;
        self
    }
    pub fn nth53(mut self, v: Byte) -> Self {
        self.0[53] = v;
        self
    }
    pub fn nth54(mut self, v: Byte) -> Self {
        self.0[54] = v;
        self
    }
    pub fn nth55(mut self, v: Byte) -> Self {
        self.0[55] = v;
        self
    }
    pub fn nth56(mut self, v: Byte) -> Self {
        self.0[56] = v;
        self
    }
    pub fn nth57(mut self, v: Byte) -> Self {
        self.0[57] = v;
        self
    }
    pub fn nth58(mut self, v: Byte) -> Self {
        self.0[58] = v;
        self
    }
    pub fn nth59(mut self, v: Byte) -> Self {
        self.0[59] = v;
        self
    }
    pub fn nth60(mut self, v: Byte) -> Self {
        self.0[60] = v;
        self
    }
    pub fn nth61(mut self, v: Byte) -> Self {
        self.0[61] = v;
        self
    }
    pub fn nth62(mut self, v: Byte) -> Self {
        self.0[62] = v;
        self
    }
    pub fn nth63(mut self, v: Byte) -> Self {
        self.0[63] = v;
        self
    }
    pub fn nth64(mut self, v: Byte) -> Self {
        self.0[64] = v;
        self
    }
    pub fn nth65(mut self, v: Byte) -> Self {
        self.0[65] = v;
        self
    }
    pub fn nth66(mut self, v: Byte) -> Self {
        self.0[66] = v;
        self
    }
    pub fn nth67(mut self, v: Byte) -> Self {
        self.0[67] = v;
        self
    }
    pub fn nth68(mut self, v: Byte) -> Self {
        self.0[68] = v;
        self
    }
    pub fn nth69(mut self, v: Byte) -> Self {
        self.0[69] = v;
        self
    }
    pub fn nth70(mut self, v: Byte) -> Self {
        self.0[70] = v;
        self
    }
    pub fn nth71(mut self, v: Byte) -> Self {
        self.0[71] = v;
        self
    }
    pub fn nth72(mut self, v: Byte) -> Self {
        self.0[72] = v;
        self
    }
    pub fn nth73(mut self, v: Byte) -> Self {
        self.0[73] = v;
        self
    }
    pub fn nth74(mut self, v: Byte) -> Self {
        self.0[74] = v;
        self
    }
    pub fn nth75(mut self, v: Byte) -> Self {
        self.0[75] = v;
        self
    }
    pub fn nth76(mut self, v: Byte) -> Self {
        self.0[76] = v;
        self
    }
    pub fn nth77(mut self, v: Byte) -> Self {
        self.0[77] = v;
        self
    }
    pub fn nth78(mut self, v: Byte) -> Self {
        self.0[78] = v;
        self
    }
    pub fn nth79(mut self, v: Byte) -> Self {
        self.0[79] = v;
        self
    }
    pub fn nth80(mut self, v: Byte) -> Self {
        self.0[80] = v;
        self
    }
    pub fn nth81(mut self, v: Byte) -> Self {
        self.0[81] = v;
        self
    }
    pub fn nth82(mut self, v: Byte) -> Self {
        self.0[82] = v;
        self
    }
    pub fn nth83(mut self, v: Byte) -> Self {
        self.0[83] = v;
        self
    }
    pub fn nth84(mut self, v: Byte) -> Self {
        self.0[84] = v;
        self
    }
    pub fn nth85(mut self, v: Byte) -> Self {
        self.0[85] = v;
        self
    }
    pub fn nth86(mut self, v: Byte) -> Self {
        self.0[86] = v;
        self
    }
    pub fn nth87(mut self, v: Byte) -> Self {
        self.0[87] = v;
        self
    }
    pub fn nth88(mut self, v: Byte) -> Self {
        self.0[88] = v;
        self
    }
    pub fn nth89(mut self, v: Byte) -> Self {
        self.0[89] = v;
        self
    }
    pub fn nth90(mut self, v: Byte) -> Self {
        self.0[90] = v;
        self
    }
    pub fn nth91(mut self, v: Byte) -> Self {
        self.0[91] = v;
        self
    }
    pub fn nth92(mut self, v: Byte) -> Self {
        self.0[92] = v;
        self
    }
    pub fn nth93(mut self, v: Byte) -> Self {
        self.0[93] = v;
        self
    }
    pub fn nth94(mut self, v: Byte) -> Self {
        self.0[94] = v;
        self
    }
    pub fn nth95(mut self, v: Byte) -> Self {
        self.0[95] = v;
        self
    }
}
impl molecule::prelude::Builder for BlsSignatureBuilder {
    type Entity = BlsSignature;
    const NAME: &'static str = "BlsSignatureBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.0[0].as_slice())?;
        writer.write_all(self.0[1].as_slice())?;
        writer.write_all(self.0[2].as_slice())?;
        writer.write_all(self.0[3].as_slice())?;
        writer.write_all(self.0[4].as_slice())?;
        writer.write_all(self.0[5].as_slice())?;
        writer.write_all(self.0[6].as_slice())?;
        writer.write_all(self.0[7].as_slice())?;
        writer.write_all(self.0[8].as_slice())?;
        writer.write_all(self.0[9].as_slice())?;
        writer.write_all(self.0[10].as_slice())?;
        writer.write_all(self.0[11].as_slice())?;
        writer.write_all(self.0[12].as_slice())?;
        writer.write_all(self.0[13].as_slice())?;
        writer.write_all(self.0[14].as_slice())?;
        writer.write_all(self.0[15].as_slice())?;
        writer.write_all(self.0[16].as_slice())?;
        writer.write_all(self.0[17].as_slice())?;
        writer.write_all(self.0[18].as_slice())?;
        writer.write_all(self.0[19].as_slice())?;
        writer.write_all(self.0[20].as_slice())?;
        writer.write_all(self.0[21].as_slice())?;
        writer.write_all(self.0[22].as_slice())?;
        writer.write_all(self.0[23].as_slice())?;
        writer.write_all(self.0[24].as_slice())?;
        writer.write_all(self.0[25].as_slice())?;
        writer.write_all(self.0[26].as_slice())?;
        writer.write_all(self.0[27].as_slice())?;
        writer.write_all(self.0[28].as_slice())?;
        writer.write_all(self.0[29].as_slice())?;
        writer.write_all(self.0[30].as_slice())?;
        writer.write_all(self.0[31].as_slice())?;
        writer.write_all(self.0[32].as_slice())?;
        writer.write_all(self.0[33].as_slice())?;
        writer.write_all(self.0[34].as_slice())?;
        writer.write_all(self.0[35].as_slice())?;
        writer.write_all(self.0[36].as_slice())?;
        writer.write_all(self.0[37].as_slice())?;
        writer.write_all(self.0[38].as_slice())?;
        writer.write_all(self.0[39].as_slice())?;
        writer.write_all(self.0[40].as_slice())?;
        writer.write_all(self.0[41].as_slice())?;
        writer.write_all(self.0[42].as_slice())?;
        writer.write_all(self.0[43].as_slice())?;
        writer.write_all(self.0[44].as_slice())?;
        writer.write_all(self.0[45].as_slice())?;
        writer.write_all(self.0[46].as_slice())?;
        writer.write_all(self.0[47].as_slice())?;
        writer.write_all(self.0[48].as_slice())?;
        writer.write_all(self.0[49].as_slice())?;
        writer.write_all(self.0[50].as_slice())?;
        writer.write_all(self.0[51].as_slice())?;
        writer.write_all(self.0[52].as_slice())?;
        writer.write_all(self.0[53].as_slice())?;
        writer.write_all(self.0[54].as_slice())?;
        writer.write_all(self.0[55].as_slice())?;
        writer.write_all(self.0[56].as_slice())?;
        writer.write_all(self.0[57].as_slice())?;
        writer.write_all(self.0[58].as_slice())?;
        writer.write_all(self.0[59].as_slice())?;
        writer.write_all(self.0[60].as_slice())?;
        writer.write_all(self.0[61].as_slice())?;
        writer.write_all(self.0[62].as_slice())?;
        writer.write_all(self.0[63].as_slice())?;
        writer.write_all(self.0[64].as_slice())?;
        writer.write_all(self.0[65].as_slice())?;
        writer.write_all(self.0[66].as_slice())?;
        writer.write_all(self.0[67].as_slice())?;
        writer.write_all(self.0[68].as_slice())?;
        writer.write_all(self.0[69].as_slice())?;
        writer.write_all(self.0[70].as_slice())?;
        writer.write_all(self.0[71].as_slice())?;
        writer.write_all(self.0[72].as_slice())?;
        writer.write_all(self.0[73].as_slice())?;
        writer.write_all(self.0[74].as_slice())?;
        writer.write_all(self.0[75].as_slice())?;
        writer.write_all(self.0[76].as_slice())?;
        writer.write_all(self.0[77].as_slice())?;
        writer.write_all(self.0[78].as_slice())?;
        writer.write_all(self.0[79].as_slice())?;
        writer.write_all(self.0[80].as_slice())?;
        writer.write_all(self.0[81].as_slice())?;
        writer.write_all(self.0[82].as_slice())?;
        writer.write_all(self.0[83].as_slice())?;
        writer.write_all(self.0[84].as_slice())?;
        writer.write_all(self.0[85].as_slice())?;
        writer.write_all(self.0[86].as_slice())?;
        writer.write_all(self.0[87].as_slice())?;
        writer.write_all(self.0[88].as_slice())?;
        writer.write_all(self.0[89].as_slice())?;
        writer.write_all(self.0[90].as_slice())?;
        writer.write_all(self.0[91].as_slice())?;
        writer.write_all(self.0[92].as_slice())?;
        writer.write_all(self.0[93].as_slice())?;
        writer.write_all(self.0[94].as_slice())?;
        writer.write_all(self.0[95].as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        BlsSignature::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct BlsPubkeyArray(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for BlsPubkeyArray {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for BlsPubkeyArray {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for BlsPubkeyArray {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        write!(f, "{}", self.nth0())?;
        write!(f, ", {}", self.nth1())?;
        write!(f, ", {}", self.nth2())?;
        write!(f, ", {}", self.nth3())?;
        write!(f, ", {}", self.nth4())?;
        write!(f, ", {}", self.nth5())?;
        write!(f, ", {}", self.nth6())?;
        write!(f, ", {}", self.nth7())?;
        write!(f, ", {}", self.nth8())?;
        write!(f, ", {}", self.nth9())?;
        write!(f, ", {}", self.nth10())?;
        write!(f, ", {}", self.nth11())?;
        write!(f, ", {}", self.nth12())?;
        write!(f, ", {}", self.nth13())?;
        write!(f, ", {}", self.nth14())?;
        write!(f, ", {}", self.nth15())?;
        write!(f, ", {}", self.nth16())?;
        write!(f, ", {}", self.nth17())?;
        write!(f, ", {}", self.nth18())?;
        write!(f, ", {}", self.nth19())?;
        write!(f, ", {}", self.nth20())?;
        write!(f, ", {}", self.nth21())?;
        write!(f, ", {}", self.nth22())?;
        write!(f, ", {}", self.nth23())?;
        write!(f, ", {}", self.nth24())?;
        write!(f, ", {}", self.nth25())?;
        write!(f, ", {}", self.nth26())?;
        write!(f, ", {}", self.nth27())?;
        write!(f, ", {}", self.nth28())?;
        write!(f, ", {}", self.nth29())?;
        write!(f, ", {}", self.nth30())?;
        write!(f, ", {}", self.nth31())?;
        write!(f, ", {}", self.nth32())?;
        write!(f, ", {}", self.nth33())?;
        write!(f, ", {}", self.nth34())?;
        write!(f, ", {}", self.nth35())?;
        write!(f, ", {}", self.nth36())?;
        write!(f, ", {}", self.nth37())?;
        write!(f, ", {}", self.nth38())?;
        write!(f, ", {}", self.nth39())?;
        write!(f, ", {}", self.nth40())?;
        write!(f, ", {}", self.nth41())?;
        write!(f, ", {}", self.nth42())?;
        write!(f, ", {}", self.nth43())?;
        write!(f, ", {}", self.nth44())?;
        write!(f, ", {}", self.nth45())?;
        write!(f, ", {}", self.nth46())?;
        write!(f, ", {}", self.nth47())?;
        write!(f, ", {}", self.nth48())?;
        write!(f, ", {}", self.nth49())?;
        write!(f, ", {}", self.nth50())?;
        write!(f, ", {}", self.nth51())?;
        write!(f, ", {}", self.nth52())?;
        write!(f, ", {}", self.nth53())?;
        write!(f, ", {}", self.nth54())?;
        write!(f, ", {}", self.nth55())?;
        write!(f, ", {}", self.nth56())?;
        write!(f, ", {}", self.nth57())?;
        write!(f, ", {}", self.nth58())?;
        write!(f, ", {}", self.nth59())?;
        write!(f, ", {}", self.nth60())?;
        write!(f, ", {}", self.nth61())?;
        write!(f, ", {}", self.nth62())?;
        write!(f, ", {}", self.nth63())?;
        write!(f, ", {}", self.nth64())?;
        write!(f, ", {}", self.nth65())?;
        write!(f, ", {}", self.nth66())?;
        write!(f, ", {}", self.nth67())?;
        write!(f, ", {}", self.nth68())?;
        write!(f, ", {}", self.nth69())?;
        write!(f, ", {}", self.nth70())?;
        write!(f, ", {}", self.nth71())?;
        write!(f, ", {}", self.nth72())?;
        write!(f, ", {}", self.nth73())?;
        write!(f, ", {}", self.nth74())?;
        write!(f, ", {}", self.nth75())?;
        write!(f, ", {}", self.nth76())?;
        write!(f, ", {}", self.nth77())?;
        write!(f, ", {}", self.nth78())?;
        write!(f, ", {}", self.nth79())?;
        write!(f, ", {}", self.nth80())?;
        write!(f, ", {}", self.nth81())?;
        write!(f, ", {}", self.nth82())?;
        write!(f, ", {}", self.nth83())?;
        write!(f, ", {}", self.nth84())?;
        write!(f, ", {}", self.nth85())?;
        write!(f, ", {}", self.nth86())?;
        write!(f, ", {}", self.nth87())?;
        write!(f, ", {}", self.nth88())?;
        write!(f, ", {}", self.nth89())?;
        write!(f, ", {}", self.nth90())?;
        write!(f, ", {}", self.nth91())?;
        write!(f, ", {}", self.nth92())?;
        write!(f, ", {}", self.nth93())?;
        write!(f, ", {}", self.nth94())?;
        write!(f, ", {}", self.nth95())?;
        write!(f, ", {}", self.nth96())?;
        write!(f, ", {}", self.nth97())?;
        write!(f, ", {}", self.nth98())?;
        write!(f, ", {}", self.nth99())?;
        write!(f, ", {}", self.nth100())?;
        write!(f, ", {}", self.nth101())?;
        write!(f, ", {}", self.nth102())?;
        write!(f, ", {}", self.nth103())?;
        write!(f, ", {}", self.nth104())?;
        write!(f, ", {}", self.nth105())?;
        write!(f, ", {}", self.nth106())?;
        write!(f, ", {}", self.nth107())?;
        write!(f, ", {}", self.nth108())?;
        write!(f, ", {}", self.nth109())?;
        write!(f, ", {}", self.nth110())?;
        write!(f, ", {}", self.nth111())?;
        write!(f, ", {}", self.nth112())?;
        write!(f, ", {}", self.nth113())?;
        write!(f, ", {}", self.nth114())?;
        write!(f, ", {}", self.nth115())?;
        write!(f, ", {}", self.nth116())?;
        write!(f, ", {}", self.nth117())?;
        write!(f, ", {}", self.nth118())?;
        write!(f, ", {}", self.nth119())?;
        write!(f, ", {}", self.nth120())?;
        write!(f, ", {}", self.nth121())?;
        write!(f, ", {}", self.nth122())?;
        write!(f, ", {}", self.nth123())?;
        write!(f, ", {}", self.nth124())?;
        write!(f, ", {}", self.nth125())?;
        write!(f, ", {}", self.nth126())?;
        write!(f, ", {}", self.nth127())?;
        write!(f, ", {}", self.nth128())?;
        write!(f, ", {}", self.nth129())?;
        write!(f, ", {}", self.nth130())?;
        write!(f, ", {}", self.nth131())?;
        write!(f, ", {}", self.nth132())?;
        write!(f, ", {}", self.nth133())?;
        write!(f, ", {}", self.nth134())?;
        write!(f, ", {}", self.nth135())?;
        write!(f, ", {}", self.nth136())?;
        write!(f, ", {}", self.nth137())?;
        write!(f, ", {}", self.nth138())?;
        write!(f, ", {}", self.nth139())?;
        write!(f, ", {}", self.nth140())?;
        write!(f, ", {}", self.nth141())?;
        write!(f, ", {}", self.nth142())?;
        write!(f, ", {}", self.nth143())?;
        write!(f, ", {}", self.nth144())?;
        write!(f, ", {}", self.nth145())?;
        write!(f, ", {}", self.nth146())?;
        write!(f, ", {}", self.nth147())?;
        write!(f, ", {}", self.nth148())?;
        write!(f, ", {}", self.nth149())?;
        write!(f, ", {}", self.nth150())?;
        write!(f, ", {}", self.nth151())?;
        write!(f, ", {}", self.nth152())?;
        write!(f, ", {}", self.nth153())?;
        write!(f, ", {}", self.nth154())?;
        write!(f, ", {}", self.nth155())?;
        write!(f, ", {}", self.nth156())?;
        write!(f, ", {}", self.nth157())?;
        write!(f, ", {}", self.nth158())?;
        write!(f, ", {}", self.nth159())?;
        write!(f, ", {}", self.nth160())?;
        write!(f, ", {}", self.nth161())?;
        write!(f, ", {}", self.nth162())?;
        write!(f, ", {}", self.nth163())?;
        write!(f, ", {}", self.nth164())?;
        write!(f, ", {}", self.nth165())?;
        write!(f, ", {}", self.nth166())?;
        write!(f, ", {}", self.nth167())?;
        write!(f, ", {}", self.nth168())?;
        write!(f, ", {}", self.nth169())?;
        write!(f, ", {}", self.nth170())?;
        write!(f, ", {}", self.nth171())?;
        write!(f, ", {}", self.nth172())?;
        write!(f, ", {}", self.nth173())?;
        write!(f, ", {}", self.nth174())?;
        write!(f, ", {}", self.nth175())?;
        write!(f, ", {}", self.nth176())?;
        write!(f, ", {}", self.nth177())?;
        write!(f, ", {}", self.nth178())?;
        write!(f, ", {}", self.nth179())?;
        write!(f, ", {}", self.nth180())?;
        write!(f, ", {}", self.nth181())?;
        write!(f, ", {}", self.nth182())?;
        write!(f, ", {}", self.nth183())?;
        write!(f, ", {}", self.nth184())?;
        write!(f, ", {}", self.nth185())?;
        write!(f, ", {}", self.nth186())?;
        write!(f, ", {}", self.nth187())?;
        write!(f, ", {}", self.nth188())?;
        write!(f, ", {}", self.nth189())?;
        write!(f, ", {}", self.nth190())?;
        write!(f, ", {}", self.nth191())?;
        write!(f, ", {}", self.nth192())?;
        write!(f, ", {}", self.nth193())?;
        write!(f, ", {}", self.nth194())?;
        write!(f, ", {}", self.nth195())?;
        write!(f, ", {}", self.nth196())?;
        write!(f, ", {}", self.nth197())?;
        write!(f, ", {}", self.nth198())?;
        write!(f, ", {}", self.nth199())?;
        write!(f, ", {}", self.nth200())?;
        write!(f, ", {}", self.nth201())?;
        write!(f, ", {}", self.nth202())?;
        write!(f, ", {}", self.nth203())?;
        write!(f, ", {}", self.nth204())?;
        write!(f, ", {}", self.nth205())?;
        write!(f, ", {}", self.nth206())?;
        write!(f, ", {}", self.nth207())?;
        write!(f, ", {}", self.nth208())?;
        write!(f, ", {}", self.nth209())?;
        write!(f, ", {}", self.nth210())?;
        write!(f, ", {}", self.nth211())?;
        write!(f, ", {}", self.nth212())?;
        write!(f, ", {}", self.nth213())?;
        write!(f, ", {}", self.nth214())?;
        write!(f, ", {}", self.nth215())?;
        write!(f, ", {}", self.nth216())?;
        write!(f, ", {}", self.nth217())?;
        write!(f, ", {}", self.nth218())?;
        write!(f, ", {}", self.nth219())?;
        write!(f, ", {}", self.nth220())?;
        write!(f, ", {}", self.nth221())?;
        write!(f, ", {}", self.nth222())?;
        write!(f, ", {}", self.nth223())?;
        write!(f, ", {}", self.nth224())?;
        write!(f, ", {}", self.nth225())?;
        write!(f, ", {}", self.nth226())?;
        write!(f, ", {}", self.nth227())?;
        write!(f, ", {}", self.nth228())?;
        write!(f, ", {}", self.nth229())?;
        write!(f, ", {}", self.nth230())?;
        write!(f, ", {}", self.nth231())?;
        write!(f, ", {}", self.nth232())?;
        write!(f, ", {}", self.nth233())?;
        write!(f, ", {}", self.nth234())?;
        write!(f, ", {}", self.nth235())?;
        write!(f, ", {}", self.nth236())?;
        write!(f, ", {}", self.nth237())?;
        write!(f, ", {}", self.nth238())?;
        write!(f, ", {}", self.nth239())?;
        write!(f, ", {}", self.nth240())?;
        write!(f, ", {}", self.nth241())?;
        write!(f, ", {}", self.nth242())?;
        write!(f, ", {}", self.nth243())?;
        write!(f, ", {}", self.nth244())?;
        write!(f, ", {}", self.nth245())?;
        write!(f, ", {}", self.nth246())?;
        write!(f, ", {}", self.nth247())?;
        write!(f, ", {}", self.nth248())?;
        write!(f, ", {}", self.nth249())?;
        write!(f, ", {}", self.nth250())?;
        write!(f, ", {}", self.nth251())?;
        write!(f, ", {}", self.nth252())?;
        write!(f, ", {}", self.nth253())?;
        write!(f, ", {}", self.nth254())?;
        write!(f, ", {}", self.nth255())?;
        write!(f, ", {}", self.nth256())?;
        write!(f, ", {}", self.nth257())?;
        write!(f, ", {}", self.nth258())?;
        write!(f, ", {}", self.nth259())?;
        write!(f, ", {}", self.nth260())?;
        write!(f, ", {}", self.nth261())?;
        write!(f, ", {}", self.nth262())?;
        write!(f, ", {}", self.nth263())?;
        write!(f, ", {}", self.nth264())?;
        write!(f, ", {}", self.nth265())?;
        write!(f, ", {}", self.nth266())?;
        write!(f, ", {}", self.nth267())?;
        write!(f, ", {}", self.nth268())?;
        write!(f, ", {}", self.nth269())?;
        write!(f, ", {}", self.nth270())?;
        write!(f, ", {}", self.nth271())?;
        write!(f, ", {}", self.nth272())?;
        write!(f, ", {}", self.nth273())?;
        write!(f, ", {}", self.nth274())?;
        write!(f, ", {}", self.nth275())?;
        write!(f, ", {}", self.nth276())?;
        write!(f, ", {}", self.nth277())?;
        write!(f, ", {}", self.nth278())?;
        write!(f, ", {}", self.nth279())?;
        write!(f, ", {}", self.nth280())?;
        write!(f, ", {}", self.nth281())?;
        write!(f, ", {}", self.nth282())?;
        write!(f, ", {}", self.nth283())?;
        write!(f, ", {}", self.nth284())?;
        write!(f, ", {}", self.nth285())?;
        write!(f, ", {}", self.nth286())?;
        write!(f, ", {}", self.nth287())?;
        write!(f, ", {}", self.nth288())?;
        write!(f, ", {}", self.nth289())?;
        write!(f, ", {}", self.nth290())?;
        write!(f, ", {}", self.nth291())?;
        write!(f, ", {}", self.nth292())?;
        write!(f, ", {}", self.nth293())?;
        write!(f, ", {}", self.nth294())?;
        write!(f, ", {}", self.nth295())?;
        write!(f, ", {}", self.nth296())?;
        write!(f, ", {}", self.nth297())?;
        write!(f, ", {}", self.nth298())?;
        write!(f, ", {}", self.nth299())?;
        write!(f, ", {}", self.nth300())?;
        write!(f, ", {}", self.nth301())?;
        write!(f, ", {}", self.nth302())?;
        write!(f, ", {}", self.nth303())?;
        write!(f, ", {}", self.nth304())?;
        write!(f, ", {}", self.nth305())?;
        write!(f, ", {}", self.nth306())?;
        write!(f, ", {}", self.nth307())?;
        write!(f, ", {}", self.nth308())?;
        write!(f, ", {}", self.nth309())?;
        write!(f, ", {}", self.nth310())?;
        write!(f, ", {}", self.nth311())?;
        write!(f, ", {}", self.nth312())?;
        write!(f, ", {}", self.nth313())?;
        write!(f, ", {}", self.nth314())?;
        write!(f, ", {}", self.nth315())?;
        write!(f, ", {}", self.nth316())?;
        write!(f, ", {}", self.nth317())?;
        write!(f, ", {}", self.nth318())?;
        write!(f, ", {}", self.nth319())?;
        write!(f, ", {}", self.nth320())?;
        write!(f, ", {}", self.nth321())?;
        write!(f, ", {}", self.nth322())?;
        write!(f, ", {}", self.nth323())?;
        write!(f, ", {}", self.nth324())?;
        write!(f, ", {}", self.nth325())?;
        write!(f, ", {}", self.nth326())?;
        write!(f, ", {}", self.nth327())?;
        write!(f, ", {}", self.nth328())?;
        write!(f, ", {}", self.nth329())?;
        write!(f, ", {}", self.nth330())?;
        write!(f, ", {}", self.nth331())?;
        write!(f, ", {}", self.nth332())?;
        write!(f, ", {}", self.nth333())?;
        write!(f, ", {}", self.nth334())?;
        write!(f, ", {}", self.nth335())?;
        write!(f, ", {}", self.nth336())?;
        write!(f, ", {}", self.nth337())?;
        write!(f, ", {}", self.nth338())?;
        write!(f, ", {}", self.nth339())?;
        write!(f, ", {}", self.nth340())?;
        write!(f, ", {}", self.nth341())?;
        write!(f, ", {}", self.nth342())?;
        write!(f, ", {}", self.nth343())?;
        write!(f, ", {}", self.nth344())?;
        write!(f, ", {}", self.nth345())?;
        write!(f, ", {}", self.nth346())?;
        write!(f, ", {}", self.nth347())?;
        write!(f, ", {}", self.nth348())?;
        write!(f, ", {}", self.nth349())?;
        write!(f, ", {}", self.nth350())?;
        write!(f, ", {}", self.nth351())?;
        write!(f, ", {}", self.nth352())?;
        write!(f, ", {}", self.nth353())?;
        write!(f, ", {}", self.nth354())?;
        write!(f, ", {}", self.nth355())?;
        write!(f, ", {}", self.nth356())?;
        write!(f, ", {}", self.nth357())?;
        write!(f, ", {}", self.nth358())?;
        write!(f, ", {}", self.nth359())?;
        write!(f, ", {}", self.nth360())?;
        write!(f, ", {}", self.nth361())?;
        write!(f, ", {}", self.nth362())?;
        write!(f, ", {}", self.nth363())?;
        write!(f, ", {}", self.nth364())?;
        write!(f, ", {}", self.nth365())?;
        write!(f, ", {}", self.nth366())?;
        write!(f, ", {}", self.nth367())?;
        write!(f, ", {}", self.nth368())?;
        write!(f, ", {}", self.nth369())?;
        write!(f, ", {}", self.nth370())?;
        write!(f, ", {}", self.nth371())?;
        write!(f, ", {}", self.nth372())?;
        write!(f, ", {}", self.nth373())?;
        write!(f, ", {}", self.nth374())?;
        write!(f, ", {}", self.nth375())?;
        write!(f, ", {}", self.nth376())?;
        write!(f, ", {}", self.nth377())?;
        write!(f, ", {}", self.nth378())?;
        write!(f, ", {}", self.nth379())?;
        write!(f, ", {}", self.nth380())?;
        write!(f, ", {}", self.nth381())?;
        write!(f, ", {}", self.nth382())?;
        write!(f, ", {}", self.nth383())?;
        write!(f, ", {}", self.nth384())?;
        write!(f, ", {}", self.nth385())?;
        write!(f, ", {}", self.nth386())?;
        write!(f, ", {}", self.nth387())?;
        write!(f, ", {}", self.nth388())?;
        write!(f, ", {}", self.nth389())?;
        write!(f, ", {}", self.nth390())?;
        write!(f, ", {}", self.nth391())?;
        write!(f, ", {}", self.nth392())?;
        write!(f, ", {}", self.nth393())?;
        write!(f, ", {}", self.nth394())?;
        write!(f, ", {}", self.nth395())?;
        write!(f, ", {}", self.nth396())?;
        write!(f, ", {}", self.nth397())?;
        write!(f, ", {}", self.nth398())?;
        write!(f, ", {}", self.nth399())?;
        write!(f, ", {}", self.nth400())?;
        write!(f, ", {}", self.nth401())?;
        write!(f, ", {}", self.nth402())?;
        write!(f, ", {}", self.nth403())?;
        write!(f, ", {}", self.nth404())?;
        write!(f, ", {}", self.nth405())?;
        write!(f, ", {}", self.nth406())?;
        write!(f, ", {}", self.nth407())?;
        write!(f, ", {}", self.nth408())?;
        write!(f, ", {}", self.nth409())?;
        write!(f, ", {}", self.nth410())?;
        write!(f, ", {}", self.nth411())?;
        write!(f, ", {}", self.nth412())?;
        write!(f, ", {}", self.nth413())?;
        write!(f, ", {}", self.nth414())?;
        write!(f, ", {}", self.nth415())?;
        write!(f, ", {}", self.nth416())?;
        write!(f, ", {}", self.nth417())?;
        write!(f, ", {}", self.nth418())?;
        write!(f, ", {}", self.nth419())?;
        write!(f, ", {}", self.nth420())?;
        write!(f, ", {}", self.nth421())?;
        write!(f, ", {}", self.nth422())?;
        write!(f, ", {}", self.nth423())?;
        write!(f, ", {}", self.nth424())?;
        write!(f, ", {}", self.nth425())?;
        write!(f, ", {}", self.nth426())?;
        write!(f, ", {}", self.nth427())?;
        write!(f, ", {}", self.nth428())?;
        write!(f, ", {}", self.nth429())?;
        write!(f, ", {}", self.nth430())?;
        write!(f, ", {}", self.nth431())?;
        write!(f, ", {}", self.nth432())?;
        write!(f, ", {}", self.nth433())?;
        write!(f, ", {}", self.nth434())?;
        write!(f, ", {}", self.nth435())?;
        write!(f, ", {}", self.nth436())?;
        write!(f, ", {}", self.nth437())?;
        write!(f, ", {}", self.nth438())?;
        write!(f, ", {}", self.nth439())?;
        write!(f, ", {}", self.nth440())?;
        write!(f, ", {}", self.nth441())?;
        write!(f, ", {}", self.nth442())?;
        write!(f, ", {}", self.nth443())?;
        write!(f, ", {}", self.nth444())?;
        write!(f, ", {}", self.nth445())?;
        write!(f, ", {}", self.nth446())?;
        write!(f, ", {}", self.nth447())?;
        write!(f, ", {}", self.nth448())?;
        write!(f, ", {}", self.nth449())?;
        write!(f, ", {}", self.nth450())?;
        write!(f, ", {}", self.nth451())?;
        write!(f, ", {}", self.nth452())?;
        write!(f, ", {}", self.nth453())?;
        write!(f, ", {}", self.nth454())?;
        write!(f, ", {}", self.nth455())?;
        write!(f, ", {}", self.nth456())?;
        write!(f, ", {}", self.nth457())?;
        write!(f, ", {}", self.nth458())?;
        write!(f, ", {}", self.nth459())?;
        write!(f, ", {}", self.nth460())?;
        write!(f, ", {}", self.nth461())?;
        write!(f, ", {}", self.nth462())?;
        write!(f, ", {}", self.nth463())?;
        write!(f, ", {}", self.nth464())?;
        write!(f, ", {}", self.nth465())?;
        write!(f, ", {}", self.nth466())?;
        write!(f, ", {}", self.nth467())?;
        write!(f, ", {}", self.nth468())?;
        write!(f, ", {}", self.nth469())?;
        write!(f, ", {}", self.nth470())?;
        write!(f, ", {}", self.nth471())?;
        write!(f, ", {}", self.nth472())?;
        write!(f, ", {}", self.nth473())?;
        write!(f, ", {}", self.nth474())?;
        write!(f, ", {}", self.nth475())?;
        write!(f, ", {}", self.nth476())?;
        write!(f, ", {}", self.nth477())?;
        write!(f, ", {}", self.nth478())?;
        write!(f, ", {}", self.nth479())?;
        write!(f, ", {}", self.nth480())?;
        write!(f, ", {}", self.nth481())?;
        write!(f, ", {}", self.nth482())?;
        write!(f, ", {}", self.nth483())?;
        write!(f, ", {}", self.nth484())?;
        write!(f, ", {}", self.nth485())?;
        write!(f, ", {}", self.nth486())?;
        write!(f, ", {}", self.nth487())?;
        write!(f, ", {}", self.nth488())?;
        write!(f, ", {}", self.nth489())?;
        write!(f, ", {}", self.nth490())?;
        write!(f, ", {}", self.nth491())?;
        write!(f, ", {}", self.nth492())?;
        write!(f, ", {}", self.nth493())?;
        write!(f, ", {}", self.nth494())?;
        write!(f, ", {}", self.nth495())?;
        write!(f, ", {}", self.nth496())?;
        write!(f, ", {}", self.nth497())?;
        write!(f, ", {}", self.nth498())?;
        write!(f, ", {}", self.nth499())?;
        write!(f, ", {}", self.nth500())?;
        write!(f, ", {}", self.nth501())?;
        write!(f, ", {}", self.nth502())?;
        write!(f, ", {}", self.nth503())?;
        write!(f, ", {}", self.nth504())?;
        write!(f, ", {}", self.nth505())?;
        write!(f, ", {}", self.nth506())?;
        write!(f, ", {}", self.nth507())?;
        write!(f, ", {}", self.nth508())?;
        write!(f, ", {}", self.nth509())?;
        write!(f, ", {}", self.nth510())?;
        write!(f, ", {}", self.nth511())?;
        write!(f, "]")
    }
}
impl ::core::default::Default for BlsPubkeyArray {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        BlsPubkeyArray::new_unchecked(v.into())
    }
}
impl BlsPubkeyArray {
    pub const TOTAL_SIZE: usize = 16384;
    pub const ITEM_SIZE: usize = 32;
    pub const ITEM_COUNT: usize = 512;
    pub fn nth0(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(0..32))
    }
    pub fn nth1(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(32..64))
    }
    pub fn nth2(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(64..96))
    }
    pub fn nth3(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(96..128))
    }
    pub fn nth4(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(128..160))
    }
    pub fn nth5(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(160..192))
    }
    pub fn nth6(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(192..224))
    }
    pub fn nth7(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(224..256))
    }
    pub fn nth8(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(256..288))
    }
    pub fn nth9(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(288..320))
    }
    pub fn nth10(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(320..352))
    }
    pub fn nth11(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(352..384))
    }
    pub fn nth12(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(384..416))
    }
    pub fn nth13(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(416..448))
    }
    pub fn nth14(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(448..480))
    }
    pub fn nth15(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(480..512))
    }
    pub fn nth16(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(512..544))
    }
    pub fn nth17(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(544..576))
    }
    pub fn nth18(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(576..608))
    }
    pub fn nth19(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(608..640))
    }
    pub fn nth20(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(640..672))
    }
    pub fn nth21(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(672..704))
    }
    pub fn nth22(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(704..736))
    }
    pub fn nth23(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(736..768))
    }
    pub fn nth24(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(768..800))
    }
    pub fn nth25(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(800..832))
    }
    pub fn nth26(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(832..864))
    }
    pub fn nth27(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(864..896))
    }
    pub fn nth28(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(896..928))
    }
    pub fn nth29(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(928..960))
    }
    pub fn nth30(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(960..992))
    }
    pub fn nth31(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(992..1024))
    }
    pub fn nth32(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(1024..1056))
    }
    pub fn nth33(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(1056..1088))
    }
    pub fn nth34(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(1088..1120))
    }
    pub fn nth35(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(1120..1152))
    }
    pub fn nth36(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(1152..1184))
    }
    pub fn nth37(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(1184..1216))
    }
    pub fn nth38(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(1216..1248))
    }
    pub fn nth39(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(1248..1280))
    }
    pub fn nth40(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(1280..1312))
    }
    pub fn nth41(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(1312..1344))
    }
    pub fn nth42(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(1344..1376))
    }
    pub fn nth43(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(1376..1408))
    }
    pub fn nth44(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(1408..1440))
    }
    pub fn nth45(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(1440..1472))
    }
    pub fn nth46(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(1472..1504))
    }
    pub fn nth47(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(1504..1536))
    }
    pub fn nth48(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(1536..1568))
    }
    pub fn nth49(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(1568..1600))
    }
    pub fn nth50(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(1600..1632))
    }
    pub fn nth51(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(1632..1664))
    }
    pub fn nth52(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(1664..1696))
    }
    pub fn nth53(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(1696..1728))
    }
    pub fn nth54(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(1728..1760))
    }
    pub fn nth55(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(1760..1792))
    }
    pub fn nth56(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(1792..1824))
    }
    pub fn nth57(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(1824..1856))
    }
    pub fn nth58(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(1856..1888))
    }
    pub fn nth59(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(1888..1920))
    }
    pub fn nth60(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(1920..1952))
    }
    pub fn nth61(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(1952..1984))
    }
    pub fn nth62(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(1984..2016))
    }
    pub fn nth63(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(2016..2048))
    }
    pub fn nth64(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(2048..2080))
    }
    pub fn nth65(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(2080..2112))
    }
    pub fn nth66(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(2112..2144))
    }
    pub fn nth67(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(2144..2176))
    }
    pub fn nth68(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(2176..2208))
    }
    pub fn nth69(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(2208..2240))
    }
    pub fn nth70(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(2240..2272))
    }
    pub fn nth71(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(2272..2304))
    }
    pub fn nth72(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(2304..2336))
    }
    pub fn nth73(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(2336..2368))
    }
    pub fn nth74(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(2368..2400))
    }
    pub fn nth75(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(2400..2432))
    }
    pub fn nth76(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(2432..2464))
    }
    pub fn nth77(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(2464..2496))
    }
    pub fn nth78(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(2496..2528))
    }
    pub fn nth79(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(2528..2560))
    }
    pub fn nth80(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(2560..2592))
    }
    pub fn nth81(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(2592..2624))
    }
    pub fn nth82(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(2624..2656))
    }
    pub fn nth83(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(2656..2688))
    }
    pub fn nth84(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(2688..2720))
    }
    pub fn nth85(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(2720..2752))
    }
    pub fn nth86(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(2752..2784))
    }
    pub fn nth87(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(2784..2816))
    }
    pub fn nth88(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(2816..2848))
    }
    pub fn nth89(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(2848..2880))
    }
    pub fn nth90(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(2880..2912))
    }
    pub fn nth91(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(2912..2944))
    }
    pub fn nth92(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(2944..2976))
    }
    pub fn nth93(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(2976..3008))
    }
    pub fn nth94(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(3008..3040))
    }
    pub fn nth95(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(3040..3072))
    }
    pub fn nth96(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(3072..3104))
    }
    pub fn nth97(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(3104..3136))
    }
    pub fn nth98(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(3136..3168))
    }
    pub fn nth99(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(3168..3200))
    }
    pub fn nth100(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(3200..3232))
    }
    pub fn nth101(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(3232..3264))
    }
    pub fn nth102(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(3264..3296))
    }
    pub fn nth103(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(3296..3328))
    }
    pub fn nth104(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(3328..3360))
    }
    pub fn nth105(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(3360..3392))
    }
    pub fn nth106(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(3392..3424))
    }
    pub fn nth107(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(3424..3456))
    }
    pub fn nth108(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(3456..3488))
    }
    pub fn nth109(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(3488..3520))
    }
    pub fn nth110(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(3520..3552))
    }
    pub fn nth111(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(3552..3584))
    }
    pub fn nth112(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(3584..3616))
    }
    pub fn nth113(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(3616..3648))
    }
    pub fn nth114(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(3648..3680))
    }
    pub fn nth115(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(3680..3712))
    }
    pub fn nth116(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(3712..3744))
    }
    pub fn nth117(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(3744..3776))
    }
    pub fn nth118(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(3776..3808))
    }
    pub fn nth119(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(3808..3840))
    }
    pub fn nth120(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(3840..3872))
    }
    pub fn nth121(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(3872..3904))
    }
    pub fn nth122(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(3904..3936))
    }
    pub fn nth123(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(3936..3968))
    }
    pub fn nth124(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(3968..4000))
    }
    pub fn nth125(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(4000..4032))
    }
    pub fn nth126(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(4032..4064))
    }
    pub fn nth127(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(4064..4096))
    }
    pub fn nth128(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(4096..4128))
    }
    pub fn nth129(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(4128..4160))
    }
    pub fn nth130(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(4160..4192))
    }
    pub fn nth131(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(4192..4224))
    }
    pub fn nth132(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(4224..4256))
    }
    pub fn nth133(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(4256..4288))
    }
    pub fn nth134(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(4288..4320))
    }
    pub fn nth135(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(4320..4352))
    }
    pub fn nth136(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(4352..4384))
    }
    pub fn nth137(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(4384..4416))
    }
    pub fn nth138(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(4416..4448))
    }
    pub fn nth139(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(4448..4480))
    }
    pub fn nth140(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(4480..4512))
    }
    pub fn nth141(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(4512..4544))
    }
    pub fn nth142(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(4544..4576))
    }
    pub fn nth143(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(4576..4608))
    }
    pub fn nth144(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(4608..4640))
    }
    pub fn nth145(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(4640..4672))
    }
    pub fn nth146(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(4672..4704))
    }
    pub fn nth147(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(4704..4736))
    }
    pub fn nth148(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(4736..4768))
    }
    pub fn nth149(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(4768..4800))
    }
    pub fn nth150(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(4800..4832))
    }
    pub fn nth151(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(4832..4864))
    }
    pub fn nth152(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(4864..4896))
    }
    pub fn nth153(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(4896..4928))
    }
    pub fn nth154(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(4928..4960))
    }
    pub fn nth155(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(4960..4992))
    }
    pub fn nth156(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(4992..5024))
    }
    pub fn nth157(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(5024..5056))
    }
    pub fn nth158(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(5056..5088))
    }
    pub fn nth159(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(5088..5120))
    }
    pub fn nth160(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(5120..5152))
    }
    pub fn nth161(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(5152..5184))
    }
    pub fn nth162(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(5184..5216))
    }
    pub fn nth163(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(5216..5248))
    }
    pub fn nth164(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(5248..5280))
    }
    pub fn nth165(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(5280..5312))
    }
    pub fn nth166(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(5312..5344))
    }
    pub fn nth167(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(5344..5376))
    }
    pub fn nth168(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(5376..5408))
    }
    pub fn nth169(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(5408..5440))
    }
    pub fn nth170(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(5440..5472))
    }
    pub fn nth171(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(5472..5504))
    }
    pub fn nth172(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(5504..5536))
    }
    pub fn nth173(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(5536..5568))
    }
    pub fn nth174(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(5568..5600))
    }
    pub fn nth175(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(5600..5632))
    }
    pub fn nth176(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(5632..5664))
    }
    pub fn nth177(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(5664..5696))
    }
    pub fn nth178(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(5696..5728))
    }
    pub fn nth179(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(5728..5760))
    }
    pub fn nth180(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(5760..5792))
    }
    pub fn nth181(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(5792..5824))
    }
    pub fn nth182(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(5824..5856))
    }
    pub fn nth183(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(5856..5888))
    }
    pub fn nth184(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(5888..5920))
    }
    pub fn nth185(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(5920..5952))
    }
    pub fn nth186(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(5952..5984))
    }
    pub fn nth187(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(5984..6016))
    }
    pub fn nth188(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(6016..6048))
    }
    pub fn nth189(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(6048..6080))
    }
    pub fn nth190(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(6080..6112))
    }
    pub fn nth191(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(6112..6144))
    }
    pub fn nth192(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(6144..6176))
    }
    pub fn nth193(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(6176..6208))
    }
    pub fn nth194(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(6208..6240))
    }
    pub fn nth195(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(6240..6272))
    }
    pub fn nth196(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(6272..6304))
    }
    pub fn nth197(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(6304..6336))
    }
    pub fn nth198(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(6336..6368))
    }
    pub fn nth199(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(6368..6400))
    }
    pub fn nth200(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(6400..6432))
    }
    pub fn nth201(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(6432..6464))
    }
    pub fn nth202(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(6464..6496))
    }
    pub fn nth203(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(6496..6528))
    }
    pub fn nth204(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(6528..6560))
    }
    pub fn nth205(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(6560..6592))
    }
    pub fn nth206(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(6592..6624))
    }
    pub fn nth207(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(6624..6656))
    }
    pub fn nth208(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(6656..6688))
    }
    pub fn nth209(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(6688..6720))
    }
    pub fn nth210(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(6720..6752))
    }
    pub fn nth211(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(6752..6784))
    }
    pub fn nth212(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(6784..6816))
    }
    pub fn nth213(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(6816..6848))
    }
    pub fn nth214(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(6848..6880))
    }
    pub fn nth215(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(6880..6912))
    }
    pub fn nth216(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(6912..6944))
    }
    pub fn nth217(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(6944..6976))
    }
    pub fn nth218(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(6976..7008))
    }
    pub fn nth219(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(7008..7040))
    }
    pub fn nth220(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(7040..7072))
    }
    pub fn nth221(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(7072..7104))
    }
    pub fn nth222(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(7104..7136))
    }
    pub fn nth223(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(7136..7168))
    }
    pub fn nth224(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(7168..7200))
    }
    pub fn nth225(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(7200..7232))
    }
    pub fn nth226(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(7232..7264))
    }
    pub fn nth227(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(7264..7296))
    }
    pub fn nth228(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(7296..7328))
    }
    pub fn nth229(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(7328..7360))
    }
    pub fn nth230(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(7360..7392))
    }
    pub fn nth231(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(7392..7424))
    }
    pub fn nth232(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(7424..7456))
    }
    pub fn nth233(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(7456..7488))
    }
    pub fn nth234(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(7488..7520))
    }
    pub fn nth235(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(7520..7552))
    }
    pub fn nth236(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(7552..7584))
    }
    pub fn nth237(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(7584..7616))
    }
    pub fn nth238(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(7616..7648))
    }
    pub fn nth239(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(7648..7680))
    }
    pub fn nth240(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(7680..7712))
    }
    pub fn nth241(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(7712..7744))
    }
    pub fn nth242(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(7744..7776))
    }
    pub fn nth243(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(7776..7808))
    }
    pub fn nth244(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(7808..7840))
    }
    pub fn nth245(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(7840..7872))
    }
    pub fn nth246(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(7872..7904))
    }
    pub fn nth247(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(7904..7936))
    }
    pub fn nth248(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(7936..7968))
    }
    pub fn nth249(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(7968..8000))
    }
    pub fn nth250(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(8000..8032))
    }
    pub fn nth251(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(8032..8064))
    }
    pub fn nth252(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(8064..8096))
    }
    pub fn nth253(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(8096..8128))
    }
    pub fn nth254(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(8128..8160))
    }
    pub fn nth255(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(8160..8192))
    }
    pub fn nth256(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(8192..8224))
    }
    pub fn nth257(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(8224..8256))
    }
    pub fn nth258(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(8256..8288))
    }
    pub fn nth259(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(8288..8320))
    }
    pub fn nth260(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(8320..8352))
    }
    pub fn nth261(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(8352..8384))
    }
    pub fn nth262(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(8384..8416))
    }
    pub fn nth263(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(8416..8448))
    }
    pub fn nth264(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(8448..8480))
    }
    pub fn nth265(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(8480..8512))
    }
    pub fn nth266(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(8512..8544))
    }
    pub fn nth267(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(8544..8576))
    }
    pub fn nth268(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(8576..8608))
    }
    pub fn nth269(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(8608..8640))
    }
    pub fn nth270(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(8640..8672))
    }
    pub fn nth271(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(8672..8704))
    }
    pub fn nth272(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(8704..8736))
    }
    pub fn nth273(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(8736..8768))
    }
    pub fn nth274(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(8768..8800))
    }
    pub fn nth275(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(8800..8832))
    }
    pub fn nth276(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(8832..8864))
    }
    pub fn nth277(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(8864..8896))
    }
    pub fn nth278(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(8896..8928))
    }
    pub fn nth279(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(8928..8960))
    }
    pub fn nth280(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(8960..8992))
    }
    pub fn nth281(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(8992..9024))
    }
    pub fn nth282(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(9024..9056))
    }
    pub fn nth283(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(9056..9088))
    }
    pub fn nth284(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(9088..9120))
    }
    pub fn nth285(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(9120..9152))
    }
    pub fn nth286(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(9152..9184))
    }
    pub fn nth287(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(9184..9216))
    }
    pub fn nth288(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(9216..9248))
    }
    pub fn nth289(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(9248..9280))
    }
    pub fn nth290(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(9280..9312))
    }
    pub fn nth291(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(9312..9344))
    }
    pub fn nth292(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(9344..9376))
    }
    pub fn nth293(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(9376..9408))
    }
    pub fn nth294(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(9408..9440))
    }
    pub fn nth295(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(9440..9472))
    }
    pub fn nth296(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(9472..9504))
    }
    pub fn nth297(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(9504..9536))
    }
    pub fn nth298(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(9536..9568))
    }
    pub fn nth299(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(9568..9600))
    }
    pub fn nth300(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(9600..9632))
    }
    pub fn nth301(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(9632..9664))
    }
    pub fn nth302(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(9664..9696))
    }
    pub fn nth303(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(9696..9728))
    }
    pub fn nth304(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(9728..9760))
    }
    pub fn nth305(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(9760..9792))
    }
    pub fn nth306(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(9792..9824))
    }
    pub fn nth307(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(9824..9856))
    }
    pub fn nth308(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(9856..9888))
    }
    pub fn nth309(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(9888..9920))
    }
    pub fn nth310(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(9920..9952))
    }
    pub fn nth311(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(9952..9984))
    }
    pub fn nth312(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(9984..10016))
    }
    pub fn nth313(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(10016..10048))
    }
    pub fn nth314(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(10048..10080))
    }
    pub fn nth315(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(10080..10112))
    }
    pub fn nth316(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(10112..10144))
    }
    pub fn nth317(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(10144..10176))
    }
    pub fn nth318(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(10176..10208))
    }
    pub fn nth319(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(10208..10240))
    }
    pub fn nth320(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(10240..10272))
    }
    pub fn nth321(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(10272..10304))
    }
    pub fn nth322(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(10304..10336))
    }
    pub fn nth323(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(10336..10368))
    }
    pub fn nth324(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(10368..10400))
    }
    pub fn nth325(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(10400..10432))
    }
    pub fn nth326(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(10432..10464))
    }
    pub fn nth327(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(10464..10496))
    }
    pub fn nth328(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(10496..10528))
    }
    pub fn nth329(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(10528..10560))
    }
    pub fn nth330(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(10560..10592))
    }
    pub fn nth331(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(10592..10624))
    }
    pub fn nth332(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(10624..10656))
    }
    pub fn nth333(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(10656..10688))
    }
    pub fn nth334(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(10688..10720))
    }
    pub fn nth335(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(10720..10752))
    }
    pub fn nth336(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(10752..10784))
    }
    pub fn nth337(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(10784..10816))
    }
    pub fn nth338(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(10816..10848))
    }
    pub fn nth339(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(10848..10880))
    }
    pub fn nth340(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(10880..10912))
    }
    pub fn nth341(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(10912..10944))
    }
    pub fn nth342(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(10944..10976))
    }
    pub fn nth343(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(10976..11008))
    }
    pub fn nth344(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(11008..11040))
    }
    pub fn nth345(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(11040..11072))
    }
    pub fn nth346(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(11072..11104))
    }
    pub fn nth347(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(11104..11136))
    }
    pub fn nth348(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(11136..11168))
    }
    pub fn nth349(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(11168..11200))
    }
    pub fn nth350(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(11200..11232))
    }
    pub fn nth351(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(11232..11264))
    }
    pub fn nth352(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(11264..11296))
    }
    pub fn nth353(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(11296..11328))
    }
    pub fn nth354(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(11328..11360))
    }
    pub fn nth355(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(11360..11392))
    }
    pub fn nth356(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(11392..11424))
    }
    pub fn nth357(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(11424..11456))
    }
    pub fn nth358(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(11456..11488))
    }
    pub fn nth359(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(11488..11520))
    }
    pub fn nth360(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(11520..11552))
    }
    pub fn nth361(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(11552..11584))
    }
    pub fn nth362(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(11584..11616))
    }
    pub fn nth363(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(11616..11648))
    }
    pub fn nth364(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(11648..11680))
    }
    pub fn nth365(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(11680..11712))
    }
    pub fn nth366(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(11712..11744))
    }
    pub fn nth367(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(11744..11776))
    }
    pub fn nth368(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(11776..11808))
    }
    pub fn nth369(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(11808..11840))
    }
    pub fn nth370(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(11840..11872))
    }
    pub fn nth371(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(11872..11904))
    }
    pub fn nth372(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(11904..11936))
    }
    pub fn nth373(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(11936..11968))
    }
    pub fn nth374(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(11968..12000))
    }
    pub fn nth375(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(12000..12032))
    }
    pub fn nth376(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(12032..12064))
    }
    pub fn nth377(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(12064..12096))
    }
    pub fn nth378(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(12096..12128))
    }
    pub fn nth379(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(12128..12160))
    }
    pub fn nth380(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(12160..12192))
    }
    pub fn nth381(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(12192..12224))
    }
    pub fn nth382(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(12224..12256))
    }
    pub fn nth383(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(12256..12288))
    }
    pub fn nth384(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(12288..12320))
    }
    pub fn nth385(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(12320..12352))
    }
    pub fn nth386(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(12352..12384))
    }
    pub fn nth387(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(12384..12416))
    }
    pub fn nth388(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(12416..12448))
    }
    pub fn nth389(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(12448..12480))
    }
    pub fn nth390(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(12480..12512))
    }
    pub fn nth391(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(12512..12544))
    }
    pub fn nth392(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(12544..12576))
    }
    pub fn nth393(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(12576..12608))
    }
    pub fn nth394(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(12608..12640))
    }
    pub fn nth395(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(12640..12672))
    }
    pub fn nth396(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(12672..12704))
    }
    pub fn nth397(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(12704..12736))
    }
    pub fn nth398(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(12736..12768))
    }
    pub fn nth399(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(12768..12800))
    }
    pub fn nth400(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(12800..12832))
    }
    pub fn nth401(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(12832..12864))
    }
    pub fn nth402(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(12864..12896))
    }
    pub fn nth403(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(12896..12928))
    }
    pub fn nth404(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(12928..12960))
    }
    pub fn nth405(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(12960..12992))
    }
    pub fn nth406(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(12992..13024))
    }
    pub fn nth407(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(13024..13056))
    }
    pub fn nth408(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(13056..13088))
    }
    pub fn nth409(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(13088..13120))
    }
    pub fn nth410(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(13120..13152))
    }
    pub fn nth411(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(13152..13184))
    }
    pub fn nth412(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(13184..13216))
    }
    pub fn nth413(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(13216..13248))
    }
    pub fn nth414(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(13248..13280))
    }
    pub fn nth415(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(13280..13312))
    }
    pub fn nth416(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(13312..13344))
    }
    pub fn nth417(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(13344..13376))
    }
    pub fn nth418(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(13376..13408))
    }
    pub fn nth419(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(13408..13440))
    }
    pub fn nth420(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(13440..13472))
    }
    pub fn nth421(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(13472..13504))
    }
    pub fn nth422(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(13504..13536))
    }
    pub fn nth423(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(13536..13568))
    }
    pub fn nth424(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(13568..13600))
    }
    pub fn nth425(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(13600..13632))
    }
    pub fn nth426(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(13632..13664))
    }
    pub fn nth427(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(13664..13696))
    }
    pub fn nth428(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(13696..13728))
    }
    pub fn nth429(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(13728..13760))
    }
    pub fn nth430(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(13760..13792))
    }
    pub fn nth431(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(13792..13824))
    }
    pub fn nth432(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(13824..13856))
    }
    pub fn nth433(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(13856..13888))
    }
    pub fn nth434(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(13888..13920))
    }
    pub fn nth435(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(13920..13952))
    }
    pub fn nth436(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(13952..13984))
    }
    pub fn nth437(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(13984..14016))
    }
    pub fn nth438(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(14016..14048))
    }
    pub fn nth439(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(14048..14080))
    }
    pub fn nth440(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(14080..14112))
    }
    pub fn nth441(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(14112..14144))
    }
    pub fn nth442(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(14144..14176))
    }
    pub fn nth443(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(14176..14208))
    }
    pub fn nth444(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(14208..14240))
    }
    pub fn nth445(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(14240..14272))
    }
    pub fn nth446(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(14272..14304))
    }
    pub fn nth447(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(14304..14336))
    }
    pub fn nth448(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(14336..14368))
    }
    pub fn nth449(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(14368..14400))
    }
    pub fn nth450(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(14400..14432))
    }
    pub fn nth451(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(14432..14464))
    }
    pub fn nth452(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(14464..14496))
    }
    pub fn nth453(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(14496..14528))
    }
    pub fn nth454(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(14528..14560))
    }
    pub fn nth455(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(14560..14592))
    }
    pub fn nth456(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(14592..14624))
    }
    pub fn nth457(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(14624..14656))
    }
    pub fn nth458(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(14656..14688))
    }
    pub fn nth459(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(14688..14720))
    }
    pub fn nth460(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(14720..14752))
    }
    pub fn nth461(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(14752..14784))
    }
    pub fn nth462(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(14784..14816))
    }
    pub fn nth463(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(14816..14848))
    }
    pub fn nth464(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(14848..14880))
    }
    pub fn nth465(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(14880..14912))
    }
    pub fn nth466(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(14912..14944))
    }
    pub fn nth467(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(14944..14976))
    }
    pub fn nth468(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(14976..15008))
    }
    pub fn nth469(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(15008..15040))
    }
    pub fn nth470(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(15040..15072))
    }
    pub fn nth471(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(15072..15104))
    }
    pub fn nth472(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(15104..15136))
    }
    pub fn nth473(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(15136..15168))
    }
    pub fn nth474(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(15168..15200))
    }
    pub fn nth475(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(15200..15232))
    }
    pub fn nth476(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(15232..15264))
    }
    pub fn nth477(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(15264..15296))
    }
    pub fn nth478(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(15296..15328))
    }
    pub fn nth479(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(15328..15360))
    }
    pub fn nth480(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(15360..15392))
    }
    pub fn nth481(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(15392..15424))
    }
    pub fn nth482(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(15424..15456))
    }
    pub fn nth483(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(15456..15488))
    }
    pub fn nth484(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(15488..15520))
    }
    pub fn nth485(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(15520..15552))
    }
    pub fn nth486(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(15552..15584))
    }
    pub fn nth487(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(15584..15616))
    }
    pub fn nth488(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(15616..15648))
    }
    pub fn nth489(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(15648..15680))
    }
    pub fn nth490(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(15680..15712))
    }
    pub fn nth491(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(15712..15744))
    }
    pub fn nth492(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(15744..15776))
    }
    pub fn nth493(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(15776..15808))
    }
    pub fn nth494(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(15808..15840))
    }
    pub fn nth495(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(15840..15872))
    }
    pub fn nth496(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(15872..15904))
    }
    pub fn nth497(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(15904..15936))
    }
    pub fn nth498(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(15936..15968))
    }
    pub fn nth499(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(15968..16000))
    }
    pub fn nth500(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(16000..16032))
    }
    pub fn nth501(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(16032..16064))
    }
    pub fn nth502(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(16064..16096))
    }
    pub fn nth503(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(16096..16128))
    }
    pub fn nth504(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(16128..16160))
    }
    pub fn nth505(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(16160..16192))
    }
    pub fn nth506(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(16192..16224))
    }
    pub fn nth507(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(16224..16256))
    }
    pub fn nth508(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(16256..16288))
    }
    pub fn nth509(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(16288..16320))
    }
    pub fn nth510(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(16320..16352))
    }
    pub fn nth511(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(16352..16384))
    }
    pub fn as_reader<'r>(&'r self) -> BlsPubkeyArrayReader<'r> {
        BlsPubkeyArrayReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for BlsPubkeyArray {
    type Builder = BlsPubkeyArrayBuilder;
    const NAME: &'static str = "BlsPubkeyArray";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        BlsPubkeyArray(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BlsPubkeyArrayReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BlsPubkeyArrayReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([
            self.nth0(),
            self.nth1(),
            self.nth2(),
            self.nth3(),
            self.nth4(),
            self.nth5(),
            self.nth6(),
            self.nth7(),
            self.nth8(),
            self.nth9(),
            self.nth10(),
            self.nth11(),
            self.nth12(),
            self.nth13(),
            self.nth14(),
            self.nth15(),
            self.nth16(),
            self.nth17(),
            self.nth18(),
            self.nth19(),
            self.nth20(),
            self.nth21(),
            self.nth22(),
            self.nth23(),
            self.nth24(),
            self.nth25(),
            self.nth26(),
            self.nth27(),
            self.nth28(),
            self.nth29(),
            self.nth30(),
            self.nth31(),
            self.nth32(),
            self.nth33(),
            self.nth34(),
            self.nth35(),
            self.nth36(),
            self.nth37(),
            self.nth38(),
            self.nth39(),
            self.nth40(),
            self.nth41(),
            self.nth42(),
            self.nth43(),
            self.nth44(),
            self.nth45(),
            self.nth46(),
            self.nth47(),
            self.nth48(),
            self.nth49(),
            self.nth50(),
            self.nth51(),
            self.nth52(),
            self.nth53(),
            self.nth54(),
            self.nth55(),
            self.nth56(),
            self.nth57(),
            self.nth58(),
            self.nth59(),
            self.nth60(),
            self.nth61(),
            self.nth62(),
            self.nth63(),
            self.nth64(),
            self.nth65(),
            self.nth66(),
            self.nth67(),
            self.nth68(),
            self.nth69(),
            self.nth70(),
            self.nth71(),
            self.nth72(),
            self.nth73(),
            self.nth74(),
            self.nth75(),
            self.nth76(),
            self.nth77(),
            self.nth78(),
            self.nth79(),
            self.nth80(),
            self.nth81(),
            self.nth82(),
            self.nth83(),
            self.nth84(),
            self.nth85(),
            self.nth86(),
            self.nth87(),
            self.nth88(),
            self.nth89(),
            self.nth90(),
            self.nth91(),
            self.nth92(),
            self.nth93(),
            self.nth94(),
            self.nth95(),
            self.nth96(),
            self.nth97(),
            self.nth98(),
            self.nth99(),
            self.nth100(),
            self.nth101(),
            self.nth102(),
            self.nth103(),
            self.nth104(),
            self.nth105(),
            self.nth106(),
            self.nth107(),
            self.nth108(),
            self.nth109(),
            self.nth110(),
            self.nth111(),
            self.nth112(),
            self.nth113(),
            self.nth114(),
            self.nth115(),
            self.nth116(),
            self.nth117(),
            self.nth118(),
            self.nth119(),
            self.nth120(),
            self.nth121(),
            self.nth122(),
            self.nth123(),
            self.nth124(),
            self.nth125(),
            self.nth126(),
            self.nth127(),
            self.nth128(),
            self.nth129(),
            self.nth130(),
            self.nth131(),
            self.nth132(),
            self.nth133(),
            self.nth134(),
            self.nth135(),
            self.nth136(),
            self.nth137(),
            self.nth138(),
            self.nth139(),
            self.nth140(),
            self.nth141(),
            self.nth142(),
            self.nth143(),
            self.nth144(),
            self.nth145(),
            self.nth146(),
            self.nth147(),
            self.nth148(),
            self.nth149(),
            self.nth150(),
            self.nth151(),
            self.nth152(),
            self.nth153(),
            self.nth154(),
            self.nth155(),
            self.nth156(),
            self.nth157(),
            self.nth158(),
            self.nth159(),
            self.nth160(),
            self.nth161(),
            self.nth162(),
            self.nth163(),
            self.nth164(),
            self.nth165(),
            self.nth166(),
            self.nth167(),
            self.nth168(),
            self.nth169(),
            self.nth170(),
            self.nth171(),
            self.nth172(),
            self.nth173(),
            self.nth174(),
            self.nth175(),
            self.nth176(),
            self.nth177(),
            self.nth178(),
            self.nth179(),
            self.nth180(),
            self.nth181(),
            self.nth182(),
            self.nth183(),
            self.nth184(),
            self.nth185(),
            self.nth186(),
            self.nth187(),
            self.nth188(),
            self.nth189(),
            self.nth190(),
            self.nth191(),
            self.nth192(),
            self.nth193(),
            self.nth194(),
            self.nth195(),
            self.nth196(),
            self.nth197(),
            self.nth198(),
            self.nth199(),
            self.nth200(),
            self.nth201(),
            self.nth202(),
            self.nth203(),
            self.nth204(),
            self.nth205(),
            self.nth206(),
            self.nth207(),
            self.nth208(),
            self.nth209(),
            self.nth210(),
            self.nth211(),
            self.nth212(),
            self.nth213(),
            self.nth214(),
            self.nth215(),
            self.nth216(),
            self.nth217(),
            self.nth218(),
            self.nth219(),
            self.nth220(),
            self.nth221(),
            self.nth222(),
            self.nth223(),
            self.nth224(),
            self.nth225(),
            self.nth226(),
            self.nth227(),
            self.nth228(),
            self.nth229(),
            self.nth230(),
            self.nth231(),
            self.nth232(),
            self.nth233(),
            self.nth234(),
            self.nth235(),
            self.nth236(),
            self.nth237(),
            self.nth238(),
            self.nth239(),
            self.nth240(),
            self.nth241(),
            self.nth242(),
            self.nth243(),
            self.nth244(),
            self.nth245(),
            self.nth246(),
            self.nth247(),
            self.nth248(),
            self.nth249(),
            self.nth250(),
            self.nth251(),
            self.nth252(),
            self.nth253(),
            self.nth254(),
            self.nth255(),
            self.nth256(),
            self.nth257(),
            self.nth258(),
            self.nth259(),
            self.nth260(),
            self.nth261(),
            self.nth262(),
            self.nth263(),
            self.nth264(),
            self.nth265(),
            self.nth266(),
            self.nth267(),
            self.nth268(),
            self.nth269(),
            self.nth270(),
            self.nth271(),
            self.nth272(),
            self.nth273(),
            self.nth274(),
            self.nth275(),
            self.nth276(),
            self.nth277(),
            self.nth278(),
            self.nth279(),
            self.nth280(),
            self.nth281(),
            self.nth282(),
            self.nth283(),
            self.nth284(),
            self.nth285(),
            self.nth286(),
            self.nth287(),
            self.nth288(),
            self.nth289(),
            self.nth290(),
            self.nth291(),
            self.nth292(),
            self.nth293(),
            self.nth294(),
            self.nth295(),
            self.nth296(),
            self.nth297(),
            self.nth298(),
            self.nth299(),
            self.nth300(),
            self.nth301(),
            self.nth302(),
            self.nth303(),
            self.nth304(),
            self.nth305(),
            self.nth306(),
            self.nth307(),
            self.nth308(),
            self.nth309(),
            self.nth310(),
            self.nth311(),
            self.nth312(),
            self.nth313(),
            self.nth314(),
            self.nth315(),
            self.nth316(),
            self.nth317(),
            self.nth318(),
            self.nth319(),
            self.nth320(),
            self.nth321(),
            self.nth322(),
            self.nth323(),
            self.nth324(),
            self.nth325(),
            self.nth326(),
            self.nth327(),
            self.nth328(),
            self.nth329(),
            self.nth330(),
            self.nth331(),
            self.nth332(),
            self.nth333(),
            self.nth334(),
            self.nth335(),
            self.nth336(),
            self.nth337(),
            self.nth338(),
            self.nth339(),
            self.nth340(),
            self.nth341(),
            self.nth342(),
            self.nth343(),
            self.nth344(),
            self.nth345(),
            self.nth346(),
            self.nth347(),
            self.nth348(),
            self.nth349(),
            self.nth350(),
            self.nth351(),
            self.nth352(),
            self.nth353(),
            self.nth354(),
            self.nth355(),
            self.nth356(),
            self.nth357(),
            self.nth358(),
            self.nth359(),
            self.nth360(),
            self.nth361(),
            self.nth362(),
            self.nth363(),
            self.nth364(),
            self.nth365(),
            self.nth366(),
            self.nth367(),
            self.nth368(),
            self.nth369(),
            self.nth370(),
            self.nth371(),
            self.nth372(),
            self.nth373(),
            self.nth374(),
            self.nth375(),
            self.nth376(),
            self.nth377(),
            self.nth378(),
            self.nth379(),
            self.nth380(),
            self.nth381(),
            self.nth382(),
            self.nth383(),
            self.nth384(),
            self.nth385(),
            self.nth386(),
            self.nth387(),
            self.nth388(),
            self.nth389(),
            self.nth390(),
            self.nth391(),
            self.nth392(),
            self.nth393(),
            self.nth394(),
            self.nth395(),
            self.nth396(),
            self.nth397(),
            self.nth398(),
            self.nth399(),
            self.nth400(),
            self.nth401(),
            self.nth402(),
            self.nth403(),
            self.nth404(),
            self.nth405(),
            self.nth406(),
            self.nth407(),
            self.nth408(),
            self.nth409(),
            self.nth410(),
            self.nth411(),
            self.nth412(),
            self.nth413(),
            self.nth414(),
            self.nth415(),
            self.nth416(),
            self.nth417(),
            self.nth418(),
            self.nth419(),
            self.nth420(),
            self.nth421(),
            self.nth422(),
            self.nth423(),
            self.nth424(),
            self.nth425(),
            self.nth426(),
            self.nth427(),
            self.nth428(),
            self.nth429(),
            self.nth430(),
            self.nth431(),
            self.nth432(),
            self.nth433(),
            self.nth434(),
            self.nth435(),
            self.nth436(),
            self.nth437(),
            self.nth438(),
            self.nth439(),
            self.nth440(),
            self.nth441(),
            self.nth442(),
            self.nth443(),
            self.nth444(),
            self.nth445(),
            self.nth446(),
            self.nth447(),
            self.nth448(),
            self.nth449(),
            self.nth450(),
            self.nth451(),
            self.nth452(),
            self.nth453(),
            self.nth454(),
            self.nth455(),
            self.nth456(),
            self.nth457(),
            self.nth458(),
            self.nth459(),
            self.nth460(),
            self.nth461(),
            self.nth462(),
            self.nth463(),
            self.nth464(),
            self.nth465(),
            self.nth466(),
            self.nth467(),
            self.nth468(),
            self.nth469(),
            self.nth470(),
            self.nth471(),
            self.nth472(),
            self.nth473(),
            self.nth474(),
            self.nth475(),
            self.nth476(),
            self.nth477(),
            self.nth478(),
            self.nth479(),
            self.nth480(),
            self.nth481(),
            self.nth482(),
            self.nth483(),
            self.nth484(),
            self.nth485(),
            self.nth486(),
            self.nth487(),
            self.nth488(),
            self.nth489(),
            self.nth490(),
            self.nth491(),
            self.nth492(),
            self.nth493(),
            self.nth494(),
            self.nth495(),
            self.nth496(),
            self.nth497(),
            self.nth498(),
            self.nth499(),
            self.nth500(),
            self.nth501(),
            self.nth502(),
            self.nth503(),
            self.nth504(),
            self.nth505(),
            self.nth506(),
            self.nth507(),
            self.nth508(),
            self.nth509(),
            self.nth510(),
            self.nth511(),
        ])
    }
}
#[derive(Clone, Copy)]
pub struct BlsPubkeyArrayReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for BlsPubkeyArrayReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for BlsPubkeyArrayReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for BlsPubkeyArrayReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        write!(f, "{}", self.nth0())?;
        write!(f, ", {}", self.nth1())?;
        write!(f, ", {}", self.nth2())?;
        write!(f, ", {}", self.nth3())?;
        write!(f, ", {}", self.nth4())?;
        write!(f, ", {}", self.nth5())?;
        write!(f, ", {}", self.nth6())?;
        write!(f, ", {}", self.nth7())?;
        write!(f, ", {}", self.nth8())?;
        write!(f, ", {}", self.nth9())?;
        write!(f, ", {}", self.nth10())?;
        write!(f, ", {}", self.nth11())?;
        write!(f, ", {}", self.nth12())?;
        write!(f, ", {}", self.nth13())?;
        write!(f, ", {}", self.nth14())?;
        write!(f, ", {}", self.nth15())?;
        write!(f, ", {}", self.nth16())?;
        write!(f, ", {}", self.nth17())?;
        write!(f, ", {}", self.nth18())?;
        write!(f, ", {}", self.nth19())?;
        write!(f, ", {}", self.nth20())?;
        write!(f, ", {}", self.nth21())?;
        write!(f, ", {}", self.nth22())?;
        write!(f, ", {}", self.nth23())?;
        write!(f, ", {}", self.nth24())?;
        write!(f, ", {}", self.nth25())?;
        write!(f, ", {}", self.nth26())?;
        write!(f, ", {}", self.nth27())?;
        write!(f, ", {}", self.nth28())?;
        write!(f, ", {}", self.nth29())?;
        write!(f, ", {}", self.nth30())?;
        write!(f, ", {}", self.nth31())?;
        write!(f, ", {}", self.nth32())?;
        write!(f, ", {}", self.nth33())?;
        write!(f, ", {}", self.nth34())?;
        write!(f, ", {}", self.nth35())?;
        write!(f, ", {}", self.nth36())?;
        write!(f, ", {}", self.nth37())?;
        write!(f, ", {}", self.nth38())?;
        write!(f, ", {}", self.nth39())?;
        write!(f, ", {}", self.nth40())?;
        write!(f, ", {}", self.nth41())?;
        write!(f, ", {}", self.nth42())?;
        write!(f, ", {}", self.nth43())?;
        write!(f, ", {}", self.nth44())?;
        write!(f, ", {}", self.nth45())?;
        write!(f, ", {}", self.nth46())?;
        write!(f, ", {}", self.nth47())?;
        write!(f, ", {}", self.nth48())?;
        write!(f, ", {}", self.nth49())?;
        write!(f, ", {}", self.nth50())?;
        write!(f, ", {}", self.nth51())?;
        write!(f, ", {}", self.nth52())?;
        write!(f, ", {}", self.nth53())?;
        write!(f, ", {}", self.nth54())?;
        write!(f, ", {}", self.nth55())?;
        write!(f, ", {}", self.nth56())?;
        write!(f, ", {}", self.nth57())?;
        write!(f, ", {}", self.nth58())?;
        write!(f, ", {}", self.nth59())?;
        write!(f, ", {}", self.nth60())?;
        write!(f, ", {}", self.nth61())?;
        write!(f, ", {}", self.nth62())?;
        write!(f, ", {}", self.nth63())?;
        write!(f, ", {}", self.nth64())?;
        write!(f, ", {}", self.nth65())?;
        write!(f, ", {}", self.nth66())?;
        write!(f, ", {}", self.nth67())?;
        write!(f, ", {}", self.nth68())?;
        write!(f, ", {}", self.nth69())?;
        write!(f, ", {}", self.nth70())?;
        write!(f, ", {}", self.nth71())?;
        write!(f, ", {}", self.nth72())?;
        write!(f, ", {}", self.nth73())?;
        write!(f, ", {}", self.nth74())?;
        write!(f, ", {}", self.nth75())?;
        write!(f, ", {}", self.nth76())?;
        write!(f, ", {}", self.nth77())?;
        write!(f, ", {}", self.nth78())?;
        write!(f, ", {}", self.nth79())?;
        write!(f, ", {}", self.nth80())?;
        write!(f, ", {}", self.nth81())?;
        write!(f, ", {}", self.nth82())?;
        write!(f, ", {}", self.nth83())?;
        write!(f, ", {}", self.nth84())?;
        write!(f, ", {}", self.nth85())?;
        write!(f, ", {}", self.nth86())?;
        write!(f, ", {}", self.nth87())?;
        write!(f, ", {}", self.nth88())?;
        write!(f, ", {}", self.nth89())?;
        write!(f, ", {}", self.nth90())?;
        write!(f, ", {}", self.nth91())?;
        write!(f, ", {}", self.nth92())?;
        write!(f, ", {}", self.nth93())?;
        write!(f, ", {}", self.nth94())?;
        write!(f, ", {}", self.nth95())?;
        write!(f, ", {}", self.nth96())?;
        write!(f, ", {}", self.nth97())?;
        write!(f, ", {}", self.nth98())?;
        write!(f, ", {}", self.nth99())?;
        write!(f, ", {}", self.nth100())?;
        write!(f, ", {}", self.nth101())?;
        write!(f, ", {}", self.nth102())?;
        write!(f, ", {}", self.nth103())?;
        write!(f, ", {}", self.nth104())?;
        write!(f, ", {}", self.nth105())?;
        write!(f, ", {}", self.nth106())?;
        write!(f, ", {}", self.nth107())?;
        write!(f, ", {}", self.nth108())?;
        write!(f, ", {}", self.nth109())?;
        write!(f, ", {}", self.nth110())?;
        write!(f, ", {}", self.nth111())?;
        write!(f, ", {}", self.nth112())?;
        write!(f, ", {}", self.nth113())?;
        write!(f, ", {}", self.nth114())?;
        write!(f, ", {}", self.nth115())?;
        write!(f, ", {}", self.nth116())?;
        write!(f, ", {}", self.nth117())?;
        write!(f, ", {}", self.nth118())?;
        write!(f, ", {}", self.nth119())?;
        write!(f, ", {}", self.nth120())?;
        write!(f, ", {}", self.nth121())?;
        write!(f, ", {}", self.nth122())?;
        write!(f, ", {}", self.nth123())?;
        write!(f, ", {}", self.nth124())?;
        write!(f, ", {}", self.nth125())?;
        write!(f, ", {}", self.nth126())?;
        write!(f, ", {}", self.nth127())?;
        write!(f, ", {}", self.nth128())?;
        write!(f, ", {}", self.nth129())?;
        write!(f, ", {}", self.nth130())?;
        write!(f, ", {}", self.nth131())?;
        write!(f, ", {}", self.nth132())?;
        write!(f, ", {}", self.nth133())?;
        write!(f, ", {}", self.nth134())?;
        write!(f, ", {}", self.nth135())?;
        write!(f, ", {}", self.nth136())?;
        write!(f, ", {}", self.nth137())?;
        write!(f, ", {}", self.nth138())?;
        write!(f, ", {}", self.nth139())?;
        write!(f, ", {}", self.nth140())?;
        write!(f, ", {}", self.nth141())?;
        write!(f, ", {}", self.nth142())?;
        write!(f, ", {}", self.nth143())?;
        write!(f, ", {}", self.nth144())?;
        write!(f, ", {}", self.nth145())?;
        write!(f, ", {}", self.nth146())?;
        write!(f, ", {}", self.nth147())?;
        write!(f, ", {}", self.nth148())?;
        write!(f, ", {}", self.nth149())?;
        write!(f, ", {}", self.nth150())?;
        write!(f, ", {}", self.nth151())?;
        write!(f, ", {}", self.nth152())?;
        write!(f, ", {}", self.nth153())?;
        write!(f, ", {}", self.nth154())?;
        write!(f, ", {}", self.nth155())?;
        write!(f, ", {}", self.nth156())?;
        write!(f, ", {}", self.nth157())?;
        write!(f, ", {}", self.nth158())?;
        write!(f, ", {}", self.nth159())?;
        write!(f, ", {}", self.nth160())?;
        write!(f, ", {}", self.nth161())?;
        write!(f, ", {}", self.nth162())?;
        write!(f, ", {}", self.nth163())?;
        write!(f, ", {}", self.nth164())?;
        write!(f, ", {}", self.nth165())?;
        write!(f, ", {}", self.nth166())?;
        write!(f, ", {}", self.nth167())?;
        write!(f, ", {}", self.nth168())?;
        write!(f, ", {}", self.nth169())?;
        write!(f, ", {}", self.nth170())?;
        write!(f, ", {}", self.nth171())?;
        write!(f, ", {}", self.nth172())?;
        write!(f, ", {}", self.nth173())?;
        write!(f, ", {}", self.nth174())?;
        write!(f, ", {}", self.nth175())?;
        write!(f, ", {}", self.nth176())?;
        write!(f, ", {}", self.nth177())?;
        write!(f, ", {}", self.nth178())?;
        write!(f, ", {}", self.nth179())?;
        write!(f, ", {}", self.nth180())?;
        write!(f, ", {}", self.nth181())?;
        write!(f, ", {}", self.nth182())?;
        write!(f, ", {}", self.nth183())?;
        write!(f, ", {}", self.nth184())?;
        write!(f, ", {}", self.nth185())?;
        write!(f, ", {}", self.nth186())?;
        write!(f, ", {}", self.nth187())?;
        write!(f, ", {}", self.nth188())?;
        write!(f, ", {}", self.nth189())?;
        write!(f, ", {}", self.nth190())?;
        write!(f, ", {}", self.nth191())?;
        write!(f, ", {}", self.nth192())?;
        write!(f, ", {}", self.nth193())?;
        write!(f, ", {}", self.nth194())?;
        write!(f, ", {}", self.nth195())?;
        write!(f, ", {}", self.nth196())?;
        write!(f, ", {}", self.nth197())?;
        write!(f, ", {}", self.nth198())?;
        write!(f, ", {}", self.nth199())?;
        write!(f, ", {}", self.nth200())?;
        write!(f, ", {}", self.nth201())?;
        write!(f, ", {}", self.nth202())?;
        write!(f, ", {}", self.nth203())?;
        write!(f, ", {}", self.nth204())?;
        write!(f, ", {}", self.nth205())?;
        write!(f, ", {}", self.nth206())?;
        write!(f, ", {}", self.nth207())?;
        write!(f, ", {}", self.nth208())?;
        write!(f, ", {}", self.nth209())?;
        write!(f, ", {}", self.nth210())?;
        write!(f, ", {}", self.nth211())?;
        write!(f, ", {}", self.nth212())?;
        write!(f, ", {}", self.nth213())?;
        write!(f, ", {}", self.nth214())?;
        write!(f, ", {}", self.nth215())?;
        write!(f, ", {}", self.nth216())?;
        write!(f, ", {}", self.nth217())?;
        write!(f, ", {}", self.nth218())?;
        write!(f, ", {}", self.nth219())?;
        write!(f, ", {}", self.nth220())?;
        write!(f, ", {}", self.nth221())?;
        write!(f, ", {}", self.nth222())?;
        write!(f, ", {}", self.nth223())?;
        write!(f, ", {}", self.nth224())?;
        write!(f, ", {}", self.nth225())?;
        write!(f, ", {}", self.nth226())?;
        write!(f, ", {}", self.nth227())?;
        write!(f, ", {}", self.nth228())?;
        write!(f, ", {}", self.nth229())?;
        write!(f, ", {}", self.nth230())?;
        write!(f, ", {}", self.nth231())?;
        write!(f, ", {}", self.nth232())?;
        write!(f, ", {}", self.nth233())?;
        write!(f, ", {}", self.nth234())?;
        write!(f, ", {}", self.nth235())?;
        write!(f, ", {}", self.nth236())?;
        write!(f, ", {}", self.nth237())?;
        write!(f, ", {}", self.nth238())?;
        write!(f, ", {}", self.nth239())?;
        write!(f, ", {}", self.nth240())?;
        write!(f, ", {}", self.nth241())?;
        write!(f, ", {}", self.nth242())?;
        write!(f, ", {}", self.nth243())?;
        write!(f, ", {}", self.nth244())?;
        write!(f, ", {}", self.nth245())?;
        write!(f, ", {}", self.nth246())?;
        write!(f, ", {}", self.nth247())?;
        write!(f, ", {}", self.nth248())?;
        write!(f, ", {}", self.nth249())?;
        write!(f, ", {}", self.nth250())?;
        write!(f, ", {}", self.nth251())?;
        write!(f, ", {}", self.nth252())?;
        write!(f, ", {}", self.nth253())?;
        write!(f, ", {}", self.nth254())?;
        write!(f, ", {}", self.nth255())?;
        write!(f, ", {}", self.nth256())?;
        write!(f, ", {}", self.nth257())?;
        write!(f, ", {}", self.nth258())?;
        write!(f, ", {}", self.nth259())?;
        write!(f, ", {}", self.nth260())?;
        write!(f, ", {}", self.nth261())?;
        write!(f, ", {}", self.nth262())?;
        write!(f, ", {}", self.nth263())?;
        write!(f, ", {}", self.nth264())?;
        write!(f, ", {}", self.nth265())?;
        write!(f, ", {}", self.nth266())?;
        write!(f, ", {}", self.nth267())?;
        write!(f, ", {}", self.nth268())?;
        write!(f, ", {}", self.nth269())?;
        write!(f, ", {}", self.nth270())?;
        write!(f, ", {}", self.nth271())?;
        write!(f, ", {}", self.nth272())?;
        write!(f, ", {}", self.nth273())?;
        write!(f, ", {}", self.nth274())?;
        write!(f, ", {}", self.nth275())?;
        write!(f, ", {}", self.nth276())?;
        write!(f, ", {}", self.nth277())?;
        write!(f, ", {}", self.nth278())?;
        write!(f, ", {}", self.nth279())?;
        write!(f, ", {}", self.nth280())?;
        write!(f, ", {}", self.nth281())?;
        write!(f, ", {}", self.nth282())?;
        write!(f, ", {}", self.nth283())?;
        write!(f, ", {}", self.nth284())?;
        write!(f, ", {}", self.nth285())?;
        write!(f, ", {}", self.nth286())?;
        write!(f, ", {}", self.nth287())?;
        write!(f, ", {}", self.nth288())?;
        write!(f, ", {}", self.nth289())?;
        write!(f, ", {}", self.nth290())?;
        write!(f, ", {}", self.nth291())?;
        write!(f, ", {}", self.nth292())?;
        write!(f, ", {}", self.nth293())?;
        write!(f, ", {}", self.nth294())?;
        write!(f, ", {}", self.nth295())?;
        write!(f, ", {}", self.nth296())?;
        write!(f, ", {}", self.nth297())?;
        write!(f, ", {}", self.nth298())?;
        write!(f, ", {}", self.nth299())?;
        write!(f, ", {}", self.nth300())?;
        write!(f, ", {}", self.nth301())?;
        write!(f, ", {}", self.nth302())?;
        write!(f, ", {}", self.nth303())?;
        write!(f, ", {}", self.nth304())?;
        write!(f, ", {}", self.nth305())?;
        write!(f, ", {}", self.nth306())?;
        write!(f, ", {}", self.nth307())?;
        write!(f, ", {}", self.nth308())?;
        write!(f, ", {}", self.nth309())?;
        write!(f, ", {}", self.nth310())?;
        write!(f, ", {}", self.nth311())?;
        write!(f, ", {}", self.nth312())?;
        write!(f, ", {}", self.nth313())?;
        write!(f, ", {}", self.nth314())?;
        write!(f, ", {}", self.nth315())?;
        write!(f, ", {}", self.nth316())?;
        write!(f, ", {}", self.nth317())?;
        write!(f, ", {}", self.nth318())?;
        write!(f, ", {}", self.nth319())?;
        write!(f, ", {}", self.nth320())?;
        write!(f, ", {}", self.nth321())?;
        write!(f, ", {}", self.nth322())?;
        write!(f, ", {}", self.nth323())?;
        write!(f, ", {}", self.nth324())?;
        write!(f, ", {}", self.nth325())?;
        write!(f, ", {}", self.nth326())?;
        write!(f, ", {}", self.nth327())?;
        write!(f, ", {}", self.nth328())?;
        write!(f, ", {}", self.nth329())?;
        write!(f, ", {}", self.nth330())?;
        write!(f, ", {}", self.nth331())?;
        write!(f, ", {}", self.nth332())?;
        write!(f, ", {}", self.nth333())?;
        write!(f, ", {}", self.nth334())?;
        write!(f, ", {}", self.nth335())?;
        write!(f, ", {}", self.nth336())?;
        write!(f, ", {}", self.nth337())?;
        write!(f, ", {}", self.nth338())?;
        write!(f, ", {}", self.nth339())?;
        write!(f, ", {}", self.nth340())?;
        write!(f, ", {}", self.nth341())?;
        write!(f, ", {}", self.nth342())?;
        write!(f, ", {}", self.nth343())?;
        write!(f, ", {}", self.nth344())?;
        write!(f, ", {}", self.nth345())?;
        write!(f, ", {}", self.nth346())?;
        write!(f, ", {}", self.nth347())?;
        write!(f, ", {}", self.nth348())?;
        write!(f, ", {}", self.nth349())?;
        write!(f, ", {}", self.nth350())?;
        write!(f, ", {}", self.nth351())?;
        write!(f, ", {}", self.nth352())?;
        write!(f, ", {}", self.nth353())?;
        write!(f, ", {}", self.nth354())?;
        write!(f, ", {}", self.nth355())?;
        write!(f, ", {}", self.nth356())?;
        write!(f, ", {}", self.nth357())?;
        write!(f, ", {}", self.nth358())?;
        write!(f, ", {}", self.nth359())?;
        write!(f, ", {}", self.nth360())?;
        write!(f, ", {}", self.nth361())?;
        write!(f, ", {}", self.nth362())?;
        write!(f, ", {}", self.nth363())?;
        write!(f, ", {}", self.nth364())?;
        write!(f, ", {}", self.nth365())?;
        write!(f, ", {}", self.nth366())?;
        write!(f, ", {}", self.nth367())?;
        write!(f, ", {}", self.nth368())?;
        write!(f, ", {}", self.nth369())?;
        write!(f, ", {}", self.nth370())?;
        write!(f, ", {}", self.nth371())?;
        write!(f, ", {}", self.nth372())?;
        write!(f, ", {}", self.nth373())?;
        write!(f, ", {}", self.nth374())?;
        write!(f, ", {}", self.nth375())?;
        write!(f, ", {}", self.nth376())?;
        write!(f, ", {}", self.nth377())?;
        write!(f, ", {}", self.nth378())?;
        write!(f, ", {}", self.nth379())?;
        write!(f, ", {}", self.nth380())?;
        write!(f, ", {}", self.nth381())?;
        write!(f, ", {}", self.nth382())?;
        write!(f, ", {}", self.nth383())?;
        write!(f, ", {}", self.nth384())?;
        write!(f, ", {}", self.nth385())?;
        write!(f, ", {}", self.nth386())?;
        write!(f, ", {}", self.nth387())?;
        write!(f, ", {}", self.nth388())?;
        write!(f, ", {}", self.nth389())?;
        write!(f, ", {}", self.nth390())?;
        write!(f, ", {}", self.nth391())?;
        write!(f, ", {}", self.nth392())?;
        write!(f, ", {}", self.nth393())?;
        write!(f, ", {}", self.nth394())?;
        write!(f, ", {}", self.nth395())?;
        write!(f, ", {}", self.nth396())?;
        write!(f, ", {}", self.nth397())?;
        write!(f, ", {}", self.nth398())?;
        write!(f, ", {}", self.nth399())?;
        write!(f, ", {}", self.nth400())?;
        write!(f, ", {}", self.nth401())?;
        write!(f, ", {}", self.nth402())?;
        write!(f, ", {}", self.nth403())?;
        write!(f, ", {}", self.nth404())?;
        write!(f, ", {}", self.nth405())?;
        write!(f, ", {}", self.nth406())?;
        write!(f, ", {}", self.nth407())?;
        write!(f, ", {}", self.nth408())?;
        write!(f, ", {}", self.nth409())?;
        write!(f, ", {}", self.nth410())?;
        write!(f, ", {}", self.nth411())?;
        write!(f, ", {}", self.nth412())?;
        write!(f, ", {}", self.nth413())?;
        write!(f, ", {}", self.nth414())?;
        write!(f, ", {}", self.nth415())?;
        write!(f, ", {}", self.nth416())?;
        write!(f, ", {}", self.nth417())?;
        write!(f, ", {}", self.nth418())?;
        write!(f, ", {}", self.nth419())?;
        write!(f, ", {}", self.nth420())?;
        write!(f, ", {}", self.nth421())?;
        write!(f, ", {}", self.nth422())?;
        write!(f, ", {}", self.nth423())?;
        write!(f, ", {}", self.nth424())?;
        write!(f, ", {}", self.nth425())?;
        write!(f, ", {}", self.nth426())?;
        write!(f, ", {}", self.nth427())?;
        write!(f, ", {}", self.nth428())?;
        write!(f, ", {}", self.nth429())?;
        write!(f, ", {}", self.nth430())?;
        write!(f, ", {}", self.nth431())?;
        write!(f, ", {}", self.nth432())?;
        write!(f, ", {}", self.nth433())?;
        write!(f, ", {}", self.nth434())?;
        write!(f, ", {}", self.nth435())?;
        write!(f, ", {}", self.nth436())?;
        write!(f, ", {}", self.nth437())?;
        write!(f, ", {}", self.nth438())?;
        write!(f, ", {}", self.nth439())?;
        write!(f, ", {}", self.nth440())?;
        write!(f, ", {}", self.nth441())?;
        write!(f, ", {}", self.nth442())?;
        write!(f, ", {}", self.nth443())?;
        write!(f, ", {}", self.nth444())?;
        write!(f, ", {}", self.nth445())?;
        write!(f, ", {}", self.nth446())?;
        write!(f, ", {}", self.nth447())?;
        write!(f, ", {}", self.nth448())?;
        write!(f, ", {}", self.nth449())?;
        write!(f, ", {}", self.nth450())?;
        write!(f, ", {}", self.nth451())?;
        write!(f, ", {}", self.nth452())?;
        write!(f, ", {}", self.nth453())?;
        write!(f, ", {}", self.nth454())?;
        write!(f, ", {}", self.nth455())?;
        write!(f, ", {}", self.nth456())?;
        write!(f, ", {}", self.nth457())?;
        write!(f, ", {}", self.nth458())?;
        write!(f, ", {}", self.nth459())?;
        write!(f, ", {}", self.nth460())?;
        write!(f, ", {}", self.nth461())?;
        write!(f, ", {}", self.nth462())?;
        write!(f, ", {}", self.nth463())?;
        write!(f, ", {}", self.nth464())?;
        write!(f, ", {}", self.nth465())?;
        write!(f, ", {}", self.nth466())?;
        write!(f, ", {}", self.nth467())?;
        write!(f, ", {}", self.nth468())?;
        write!(f, ", {}", self.nth469())?;
        write!(f, ", {}", self.nth470())?;
        write!(f, ", {}", self.nth471())?;
        write!(f, ", {}", self.nth472())?;
        write!(f, ", {}", self.nth473())?;
        write!(f, ", {}", self.nth474())?;
        write!(f, ", {}", self.nth475())?;
        write!(f, ", {}", self.nth476())?;
        write!(f, ", {}", self.nth477())?;
        write!(f, ", {}", self.nth478())?;
        write!(f, ", {}", self.nth479())?;
        write!(f, ", {}", self.nth480())?;
        write!(f, ", {}", self.nth481())?;
        write!(f, ", {}", self.nth482())?;
        write!(f, ", {}", self.nth483())?;
        write!(f, ", {}", self.nth484())?;
        write!(f, ", {}", self.nth485())?;
        write!(f, ", {}", self.nth486())?;
        write!(f, ", {}", self.nth487())?;
        write!(f, ", {}", self.nth488())?;
        write!(f, ", {}", self.nth489())?;
        write!(f, ", {}", self.nth490())?;
        write!(f, ", {}", self.nth491())?;
        write!(f, ", {}", self.nth492())?;
        write!(f, ", {}", self.nth493())?;
        write!(f, ", {}", self.nth494())?;
        write!(f, ", {}", self.nth495())?;
        write!(f, ", {}", self.nth496())?;
        write!(f, ", {}", self.nth497())?;
        write!(f, ", {}", self.nth498())?;
        write!(f, ", {}", self.nth499())?;
        write!(f, ", {}", self.nth500())?;
        write!(f, ", {}", self.nth501())?;
        write!(f, ", {}", self.nth502())?;
        write!(f, ", {}", self.nth503())?;
        write!(f, ", {}", self.nth504())?;
        write!(f, ", {}", self.nth505())?;
        write!(f, ", {}", self.nth506())?;
        write!(f, ", {}", self.nth507())?;
        write!(f, ", {}", self.nth508())?;
        write!(f, ", {}", self.nth509())?;
        write!(f, ", {}", self.nth510())?;
        write!(f, ", {}", self.nth511())?;
        write!(f, "]")
    }
}
impl<'r> BlsPubkeyArrayReader<'r> {
    pub const TOTAL_SIZE: usize = 16384;
    pub const ITEM_SIZE: usize = 32;
    pub const ITEM_COUNT: usize = 512;
    pub fn nth0(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[0..32])
    }
    pub fn nth1(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[32..64])
    }
    pub fn nth2(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[64..96])
    }
    pub fn nth3(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[96..128])
    }
    pub fn nth4(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[128..160])
    }
    pub fn nth5(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[160..192])
    }
    pub fn nth6(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[192..224])
    }
    pub fn nth7(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[224..256])
    }
    pub fn nth8(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[256..288])
    }
    pub fn nth9(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[288..320])
    }
    pub fn nth10(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[320..352])
    }
    pub fn nth11(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[352..384])
    }
    pub fn nth12(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[384..416])
    }
    pub fn nth13(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[416..448])
    }
    pub fn nth14(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[448..480])
    }
    pub fn nth15(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[480..512])
    }
    pub fn nth16(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[512..544])
    }
    pub fn nth17(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[544..576])
    }
    pub fn nth18(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[576..608])
    }
    pub fn nth19(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[608..640])
    }
    pub fn nth20(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[640..672])
    }
    pub fn nth21(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[672..704])
    }
    pub fn nth22(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[704..736])
    }
    pub fn nth23(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[736..768])
    }
    pub fn nth24(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[768..800])
    }
    pub fn nth25(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[800..832])
    }
    pub fn nth26(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[832..864])
    }
    pub fn nth27(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[864..896])
    }
    pub fn nth28(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[896..928])
    }
    pub fn nth29(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[928..960])
    }
    pub fn nth30(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[960..992])
    }
    pub fn nth31(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[992..1024])
    }
    pub fn nth32(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[1024..1056])
    }
    pub fn nth33(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[1056..1088])
    }
    pub fn nth34(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[1088..1120])
    }
    pub fn nth35(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[1120..1152])
    }
    pub fn nth36(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[1152..1184])
    }
    pub fn nth37(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[1184..1216])
    }
    pub fn nth38(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[1216..1248])
    }
    pub fn nth39(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[1248..1280])
    }
    pub fn nth40(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[1280..1312])
    }
    pub fn nth41(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[1312..1344])
    }
    pub fn nth42(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[1344..1376])
    }
    pub fn nth43(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[1376..1408])
    }
    pub fn nth44(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[1408..1440])
    }
    pub fn nth45(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[1440..1472])
    }
    pub fn nth46(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[1472..1504])
    }
    pub fn nth47(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[1504..1536])
    }
    pub fn nth48(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[1536..1568])
    }
    pub fn nth49(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[1568..1600])
    }
    pub fn nth50(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[1600..1632])
    }
    pub fn nth51(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[1632..1664])
    }
    pub fn nth52(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[1664..1696])
    }
    pub fn nth53(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[1696..1728])
    }
    pub fn nth54(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[1728..1760])
    }
    pub fn nth55(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[1760..1792])
    }
    pub fn nth56(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[1792..1824])
    }
    pub fn nth57(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[1824..1856])
    }
    pub fn nth58(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[1856..1888])
    }
    pub fn nth59(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[1888..1920])
    }
    pub fn nth60(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[1920..1952])
    }
    pub fn nth61(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[1952..1984])
    }
    pub fn nth62(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[1984..2016])
    }
    pub fn nth63(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[2016..2048])
    }
    pub fn nth64(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[2048..2080])
    }
    pub fn nth65(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[2080..2112])
    }
    pub fn nth66(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[2112..2144])
    }
    pub fn nth67(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[2144..2176])
    }
    pub fn nth68(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[2176..2208])
    }
    pub fn nth69(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[2208..2240])
    }
    pub fn nth70(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[2240..2272])
    }
    pub fn nth71(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[2272..2304])
    }
    pub fn nth72(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[2304..2336])
    }
    pub fn nth73(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[2336..2368])
    }
    pub fn nth74(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[2368..2400])
    }
    pub fn nth75(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[2400..2432])
    }
    pub fn nth76(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[2432..2464])
    }
    pub fn nth77(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[2464..2496])
    }
    pub fn nth78(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[2496..2528])
    }
    pub fn nth79(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[2528..2560])
    }
    pub fn nth80(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[2560..2592])
    }
    pub fn nth81(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[2592..2624])
    }
    pub fn nth82(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[2624..2656])
    }
    pub fn nth83(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[2656..2688])
    }
    pub fn nth84(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[2688..2720])
    }
    pub fn nth85(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[2720..2752])
    }
    pub fn nth86(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[2752..2784])
    }
    pub fn nth87(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[2784..2816])
    }
    pub fn nth88(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[2816..2848])
    }
    pub fn nth89(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[2848..2880])
    }
    pub fn nth90(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[2880..2912])
    }
    pub fn nth91(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[2912..2944])
    }
    pub fn nth92(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[2944..2976])
    }
    pub fn nth93(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[2976..3008])
    }
    pub fn nth94(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[3008..3040])
    }
    pub fn nth95(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[3040..3072])
    }
    pub fn nth96(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[3072..3104])
    }
    pub fn nth97(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[3104..3136])
    }
    pub fn nth98(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[3136..3168])
    }
    pub fn nth99(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[3168..3200])
    }
    pub fn nth100(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[3200..3232])
    }
    pub fn nth101(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[3232..3264])
    }
    pub fn nth102(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[3264..3296])
    }
    pub fn nth103(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[3296..3328])
    }
    pub fn nth104(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[3328..3360])
    }
    pub fn nth105(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[3360..3392])
    }
    pub fn nth106(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[3392..3424])
    }
    pub fn nth107(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[3424..3456])
    }
    pub fn nth108(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[3456..3488])
    }
    pub fn nth109(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[3488..3520])
    }
    pub fn nth110(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[3520..3552])
    }
    pub fn nth111(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[3552..3584])
    }
    pub fn nth112(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[3584..3616])
    }
    pub fn nth113(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[3616..3648])
    }
    pub fn nth114(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[3648..3680])
    }
    pub fn nth115(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[3680..3712])
    }
    pub fn nth116(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[3712..3744])
    }
    pub fn nth117(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[3744..3776])
    }
    pub fn nth118(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[3776..3808])
    }
    pub fn nth119(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[3808..3840])
    }
    pub fn nth120(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[3840..3872])
    }
    pub fn nth121(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[3872..3904])
    }
    pub fn nth122(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[3904..3936])
    }
    pub fn nth123(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[3936..3968])
    }
    pub fn nth124(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[3968..4000])
    }
    pub fn nth125(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[4000..4032])
    }
    pub fn nth126(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[4032..4064])
    }
    pub fn nth127(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[4064..4096])
    }
    pub fn nth128(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[4096..4128])
    }
    pub fn nth129(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[4128..4160])
    }
    pub fn nth130(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[4160..4192])
    }
    pub fn nth131(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[4192..4224])
    }
    pub fn nth132(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[4224..4256])
    }
    pub fn nth133(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[4256..4288])
    }
    pub fn nth134(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[4288..4320])
    }
    pub fn nth135(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[4320..4352])
    }
    pub fn nth136(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[4352..4384])
    }
    pub fn nth137(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[4384..4416])
    }
    pub fn nth138(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[4416..4448])
    }
    pub fn nth139(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[4448..4480])
    }
    pub fn nth140(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[4480..4512])
    }
    pub fn nth141(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[4512..4544])
    }
    pub fn nth142(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[4544..4576])
    }
    pub fn nth143(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[4576..4608])
    }
    pub fn nth144(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[4608..4640])
    }
    pub fn nth145(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[4640..4672])
    }
    pub fn nth146(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[4672..4704])
    }
    pub fn nth147(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[4704..4736])
    }
    pub fn nth148(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[4736..4768])
    }
    pub fn nth149(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[4768..4800])
    }
    pub fn nth150(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[4800..4832])
    }
    pub fn nth151(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[4832..4864])
    }
    pub fn nth152(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[4864..4896])
    }
    pub fn nth153(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[4896..4928])
    }
    pub fn nth154(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[4928..4960])
    }
    pub fn nth155(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[4960..4992])
    }
    pub fn nth156(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[4992..5024])
    }
    pub fn nth157(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[5024..5056])
    }
    pub fn nth158(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[5056..5088])
    }
    pub fn nth159(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[5088..5120])
    }
    pub fn nth160(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[5120..5152])
    }
    pub fn nth161(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[5152..5184])
    }
    pub fn nth162(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[5184..5216])
    }
    pub fn nth163(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[5216..5248])
    }
    pub fn nth164(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[5248..5280])
    }
    pub fn nth165(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[5280..5312])
    }
    pub fn nth166(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[5312..5344])
    }
    pub fn nth167(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[5344..5376])
    }
    pub fn nth168(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[5376..5408])
    }
    pub fn nth169(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[5408..5440])
    }
    pub fn nth170(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[5440..5472])
    }
    pub fn nth171(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[5472..5504])
    }
    pub fn nth172(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[5504..5536])
    }
    pub fn nth173(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[5536..5568])
    }
    pub fn nth174(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[5568..5600])
    }
    pub fn nth175(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[5600..5632])
    }
    pub fn nth176(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[5632..5664])
    }
    pub fn nth177(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[5664..5696])
    }
    pub fn nth178(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[5696..5728])
    }
    pub fn nth179(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[5728..5760])
    }
    pub fn nth180(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[5760..5792])
    }
    pub fn nth181(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[5792..5824])
    }
    pub fn nth182(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[5824..5856])
    }
    pub fn nth183(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[5856..5888])
    }
    pub fn nth184(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[5888..5920])
    }
    pub fn nth185(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[5920..5952])
    }
    pub fn nth186(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[5952..5984])
    }
    pub fn nth187(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[5984..6016])
    }
    pub fn nth188(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[6016..6048])
    }
    pub fn nth189(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[6048..6080])
    }
    pub fn nth190(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[6080..6112])
    }
    pub fn nth191(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[6112..6144])
    }
    pub fn nth192(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[6144..6176])
    }
    pub fn nth193(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[6176..6208])
    }
    pub fn nth194(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[6208..6240])
    }
    pub fn nth195(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[6240..6272])
    }
    pub fn nth196(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[6272..6304])
    }
    pub fn nth197(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[6304..6336])
    }
    pub fn nth198(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[6336..6368])
    }
    pub fn nth199(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[6368..6400])
    }
    pub fn nth200(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[6400..6432])
    }
    pub fn nth201(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[6432..6464])
    }
    pub fn nth202(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[6464..6496])
    }
    pub fn nth203(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[6496..6528])
    }
    pub fn nth204(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[6528..6560])
    }
    pub fn nth205(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[6560..6592])
    }
    pub fn nth206(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[6592..6624])
    }
    pub fn nth207(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[6624..6656])
    }
    pub fn nth208(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[6656..6688])
    }
    pub fn nth209(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[6688..6720])
    }
    pub fn nth210(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[6720..6752])
    }
    pub fn nth211(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[6752..6784])
    }
    pub fn nth212(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[6784..6816])
    }
    pub fn nth213(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[6816..6848])
    }
    pub fn nth214(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[6848..6880])
    }
    pub fn nth215(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[6880..6912])
    }
    pub fn nth216(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[6912..6944])
    }
    pub fn nth217(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[6944..6976])
    }
    pub fn nth218(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[6976..7008])
    }
    pub fn nth219(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[7008..7040])
    }
    pub fn nth220(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[7040..7072])
    }
    pub fn nth221(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[7072..7104])
    }
    pub fn nth222(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[7104..7136])
    }
    pub fn nth223(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[7136..7168])
    }
    pub fn nth224(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[7168..7200])
    }
    pub fn nth225(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[7200..7232])
    }
    pub fn nth226(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[7232..7264])
    }
    pub fn nth227(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[7264..7296])
    }
    pub fn nth228(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[7296..7328])
    }
    pub fn nth229(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[7328..7360])
    }
    pub fn nth230(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[7360..7392])
    }
    pub fn nth231(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[7392..7424])
    }
    pub fn nth232(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[7424..7456])
    }
    pub fn nth233(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[7456..7488])
    }
    pub fn nth234(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[7488..7520])
    }
    pub fn nth235(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[7520..7552])
    }
    pub fn nth236(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[7552..7584])
    }
    pub fn nth237(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[7584..7616])
    }
    pub fn nth238(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[7616..7648])
    }
    pub fn nth239(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[7648..7680])
    }
    pub fn nth240(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[7680..7712])
    }
    pub fn nth241(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[7712..7744])
    }
    pub fn nth242(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[7744..7776])
    }
    pub fn nth243(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[7776..7808])
    }
    pub fn nth244(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[7808..7840])
    }
    pub fn nth245(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[7840..7872])
    }
    pub fn nth246(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[7872..7904])
    }
    pub fn nth247(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[7904..7936])
    }
    pub fn nth248(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[7936..7968])
    }
    pub fn nth249(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[7968..8000])
    }
    pub fn nth250(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[8000..8032])
    }
    pub fn nth251(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[8032..8064])
    }
    pub fn nth252(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[8064..8096])
    }
    pub fn nth253(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[8096..8128])
    }
    pub fn nth254(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[8128..8160])
    }
    pub fn nth255(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[8160..8192])
    }
    pub fn nth256(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[8192..8224])
    }
    pub fn nth257(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[8224..8256])
    }
    pub fn nth258(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[8256..8288])
    }
    pub fn nth259(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[8288..8320])
    }
    pub fn nth260(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[8320..8352])
    }
    pub fn nth261(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[8352..8384])
    }
    pub fn nth262(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[8384..8416])
    }
    pub fn nth263(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[8416..8448])
    }
    pub fn nth264(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[8448..8480])
    }
    pub fn nth265(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[8480..8512])
    }
    pub fn nth266(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[8512..8544])
    }
    pub fn nth267(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[8544..8576])
    }
    pub fn nth268(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[8576..8608])
    }
    pub fn nth269(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[8608..8640])
    }
    pub fn nth270(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[8640..8672])
    }
    pub fn nth271(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[8672..8704])
    }
    pub fn nth272(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[8704..8736])
    }
    pub fn nth273(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[8736..8768])
    }
    pub fn nth274(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[8768..8800])
    }
    pub fn nth275(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[8800..8832])
    }
    pub fn nth276(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[8832..8864])
    }
    pub fn nth277(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[8864..8896])
    }
    pub fn nth278(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[8896..8928])
    }
    pub fn nth279(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[8928..8960])
    }
    pub fn nth280(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[8960..8992])
    }
    pub fn nth281(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[8992..9024])
    }
    pub fn nth282(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[9024..9056])
    }
    pub fn nth283(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[9056..9088])
    }
    pub fn nth284(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[9088..9120])
    }
    pub fn nth285(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[9120..9152])
    }
    pub fn nth286(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[9152..9184])
    }
    pub fn nth287(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[9184..9216])
    }
    pub fn nth288(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[9216..9248])
    }
    pub fn nth289(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[9248..9280])
    }
    pub fn nth290(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[9280..9312])
    }
    pub fn nth291(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[9312..9344])
    }
    pub fn nth292(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[9344..9376])
    }
    pub fn nth293(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[9376..9408])
    }
    pub fn nth294(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[9408..9440])
    }
    pub fn nth295(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[9440..9472])
    }
    pub fn nth296(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[9472..9504])
    }
    pub fn nth297(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[9504..9536])
    }
    pub fn nth298(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[9536..9568])
    }
    pub fn nth299(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[9568..9600])
    }
    pub fn nth300(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[9600..9632])
    }
    pub fn nth301(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[9632..9664])
    }
    pub fn nth302(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[9664..9696])
    }
    pub fn nth303(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[9696..9728])
    }
    pub fn nth304(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[9728..9760])
    }
    pub fn nth305(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[9760..9792])
    }
    pub fn nth306(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[9792..9824])
    }
    pub fn nth307(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[9824..9856])
    }
    pub fn nth308(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[9856..9888])
    }
    pub fn nth309(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[9888..9920])
    }
    pub fn nth310(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[9920..9952])
    }
    pub fn nth311(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[9952..9984])
    }
    pub fn nth312(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[9984..10016])
    }
    pub fn nth313(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[10016..10048])
    }
    pub fn nth314(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[10048..10080])
    }
    pub fn nth315(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[10080..10112])
    }
    pub fn nth316(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[10112..10144])
    }
    pub fn nth317(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[10144..10176])
    }
    pub fn nth318(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[10176..10208])
    }
    pub fn nth319(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[10208..10240])
    }
    pub fn nth320(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[10240..10272])
    }
    pub fn nth321(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[10272..10304])
    }
    pub fn nth322(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[10304..10336])
    }
    pub fn nth323(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[10336..10368])
    }
    pub fn nth324(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[10368..10400])
    }
    pub fn nth325(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[10400..10432])
    }
    pub fn nth326(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[10432..10464])
    }
    pub fn nth327(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[10464..10496])
    }
    pub fn nth328(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[10496..10528])
    }
    pub fn nth329(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[10528..10560])
    }
    pub fn nth330(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[10560..10592])
    }
    pub fn nth331(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[10592..10624])
    }
    pub fn nth332(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[10624..10656])
    }
    pub fn nth333(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[10656..10688])
    }
    pub fn nth334(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[10688..10720])
    }
    pub fn nth335(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[10720..10752])
    }
    pub fn nth336(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[10752..10784])
    }
    pub fn nth337(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[10784..10816])
    }
    pub fn nth338(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[10816..10848])
    }
    pub fn nth339(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[10848..10880])
    }
    pub fn nth340(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[10880..10912])
    }
    pub fn nth341(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[10912..10944])
    }
    pub fn nth342(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[10944..10976])
    }
    pub fn nth343(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[10976..11008])
    }
    pub fn nth344(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[11008..11040])
    }
    pub fn nth345(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[11040..11072])
    }
    pub fn nth346(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[11072..11104])
    }
    pub fn nth347(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[11104..11136])
    }
    pub fn nth348(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[11136..11168])
    }
    pub fn nth349(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[11168..11200])
    }
    pub fn nth350(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[11200..11232])
    }
    pub fn nth351(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[11232..11264])
    }
    pub fn nth352(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[11264..11296])
    }
    pub fn nth353(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[11296..11328])
    }
    pub fn nth354(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[11328..11360])
    }
    pub fn nth355(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[11360..11392])
    }
    pub fn nth356(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[11392..11424])
    }
    pub fn nth357(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[11424..11456])
    }
    pub fn nth358(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[11456..11488])
    }
    pub fn nth359(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[11488..11520])
    }
    pub fn nth360(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[11520..11552])
    }
    pub fn nth361(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[11552..11584])
    }
    pub fn nth362(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[11584..11616])
    }
    pub fn nth363(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[11616..11648])
    }
    pub fn nth364(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[11648..11680])
    }
    pub fn nth365(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[11680..11712])
    }
    pub fn nth366(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[11712..11744])
    }
    pub fn nth367(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[11744..11776])
    }
    pub fn nth368(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[11776..11808])
    }
    pub fn nth369(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[11808..11840])
    }
    pub fn nth370(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[11840..11872])
    }
    pub fn nth371(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[11872..11904])
    }
    pub fn nth372(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[11904..11936])
    }
    pub fn nth373(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[11936..11968])
    }
    pub fn nth374(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[11968..12000])
    }
    pub fn nth375(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[12000..12032])
    }
    pub fn nth376(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[12032..12064])
    }
    pub fn nth377(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[12064..12096])
    }
    pub fn nth378(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[12096..12128])
    }
    pub fn nth379(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[12128..12160])
    }
    pub fn nth380(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[12160..12192])
    }
    pub fn nth381(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[12192..12224])
    }
    pub fn nth382(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[12224..12256])
    }
    pub fn nth383(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[12256..12288])
    }
    pub fn nth384(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[12288..12320])
    }
    pub fn nth385(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[12320..12352])
    }
    pub fn nth386(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[12352..12384])
    }
    pub fn nth387(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[12384..12416])
    }
    pub fn nth388(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[12416..12448])
    }
    pub fn nth389(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[12448..12480])
    }
    pub fn nth390(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[12480..12512])
    }
    pub fn nth391(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[12512..12544])
    }
    pub fn nth392(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[12544..12576])
    }
    pub fn nth393(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[12576..12608])
    }
    pub fn nth394(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[12608..12640])
    }
    pub fn nth395(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[12640..12672])
    }
    pub fn nth396(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[12672..12704])
    }
    pub fn nth397(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[12704..12736])
    }
    pub fn nth398(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[12736..12768])
    }
    pub fn nth399(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[12768..12800])
    }
    pub fn nth400(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[12800..12832])
    }
    pub fn nth401(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[12832..12864])
    }
    pub fn nth402(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[12864..12896])
    }
    pub fn nth403(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[12896..12928])
    }
    pub fn nth404(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[12928..12960])
    }
    pub fn nth405(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[12960..12992])
    }
    pub fn nth406(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[12992..13024])
    }
    pub fn nth407(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[13024..13056])
    }
    pub fn nth408(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[13056..13088])
    }
    pub fn nth409(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[13088..13120])
    }
    pub fn nth410(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[13120..13152])
    }
    pub fn nth411(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[13152..13184])
    }
    pub fn nth412(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[13184..13216])
    }
    pub fn nth413(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[13216..13248])
    }
    pub fn nth414(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[13248..13280])
    }
    pub fn nth415(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[13280..13312])
    }
    pub fn nth416(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[13312..13344])
    }
    pub fn nth417(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[13344..13376])
    }
    pub fn nth418(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[13376..13408])
    }
    pub fn nth419(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[13408..13440])
    }
    pub fn nth420(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[13440..13472])
    }
    pub fn nth421(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[13472..13504])
    }
    pub fn nth422(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[13504..13536])
    }
    pub fn nth423(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[13536..13568])
    }
    pub fn nth424(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[13568..13600])
    }
    pub fn nth425(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[13600..13632])
    }
    pub fn nth426(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[13632..13664])
    }
    pub fn nth427(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[13664..13696])
    }
    pub fn nth428(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[13696..13728])
    }
    pub fn nth429(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[13728..13760])
    }
    pub fn nth430(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[13760..13792])
    }
    pub fn nth431(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[13792..13824])
    }
    pub fn nth432(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[13824..13856])
    }
    pub fn nth433(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[13856..13888])
    }
    pub fn nth434(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[13888..13920])
    }
    pub fn nth435(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[13920..13952])
    }
    pub fn nth436(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[13952..13984])
    }
    pub fn nth437(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[13984..14016])
    }
    pub fn nth438(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[14016..14048])
    }
    pub fn nth439(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[14048..14080])
    }
    pub fn nth440(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[14080..14112])
    }
    pub fn nth441(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[14112..14144])
    }
    pub fn nth442(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[14144..14176])
    }
    pub fn nth443(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[14176..14208])
    }
    pub fn nth444(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[14208..14240])
    }
    pub fn nth445(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[14240..14272])
    }
    pub fn nth446(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[14272..14304])
    }
    pub fn nth447(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[14304..14336])
    }
    pub fn nth448(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[14336..14368])
    }
    pub fn nth449(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[14368..14400])
    }
    pub fn nth450(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[14400..14432])
    }
    pub fn nth451(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[14432..14464])
    }
    pub fn nth452(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[14464..14496])
    }
    pub fn nth453(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[14496..14528])
    }
    pub fn nth454(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[14528..14560])
    }
    pub fn nth455(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[14560..14592])
    }
    pub fn nth456(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[14592..14624])
    }
    pub fn nth457(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[14624..14656])
    }
    pub fn nth458(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[14656..14688])
    }
    pub fn nth459(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[14688..14720])
    }
    pub fn nth460(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[14720..14752])
    }
    pub fn nth461(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[14752..14784])
    }
    pub fn nth462(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[14784..14816])
    }
    pub fn nth463(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[14816..14848])
    }
    pub fn nth464(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[14848..14880])
    }
    pub fn nth465(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[14880..14912])
    }
    pub fn nth466(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[14912..14944])
    }
    pub fn nth467(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[14944..14976])
    }
    pub fn nth468(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[14976..15008])
    }
    pub fn nth469(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[15008..15040])
    }
    pub fn nth470(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[15040..15072])
    }
    pub fn nth471(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[15072..15104])
    }
    pub fn nth472(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[15104..15136])
    }
    pub fn nth473(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[15136..15168])
    }
    pub fn nth474(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[15168..15200])
    }
    pub fn nth475(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[15200..15232])
    }
    pub fn nth476(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[15232..15264])
    }
    pub fn nth477(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[15264..15296])
    }
    pub fn nth478(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[15296..15328])
    }
    pub fn nth479(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[15328..15360])
    }
    pub fn nth480(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[15360..15392])
    }
    pub fn nth481(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[15392..15424])
    }
    pub fn nth482(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[15424..15456])
    }
    pub fn nth483(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[15456..15488])
    }
    pub fn nth484(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[15488..15520])
    }
    pub fn nth485(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[15520..15552])
    }
    pub fn nth486(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[15552..15584])
    }
    pub fn nth487(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[15584..15616])
    }
    pub fn nth488(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[15616..15648])
    }
    pub fn nth489(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[15648..15680])
    }
    pub fn nth490(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[15680..15712])
    }
    pub fn nth491(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[15712..15744])
    }
    pub fn nth492(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[15744..15776])
    }
    pub fn nth493(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[15776..15808])
    }
    pub fn nth494(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[15808..15840])
    }
    pub fn nth495(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[15840..15872])
    }
    pub fn nth496(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[15872..15904])
    }
    pub fn nth497(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[15904..15936])
    }
    pub fn nth498(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[15936..15968])
    }
    pub fn nth499(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[15968..16000])
    }
    pub fn nth500(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[16000..16032])
    }
    pub fn nth501(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[16032..16064])
    }
    pub fn nth502(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[16064..16096])
    }
    pub fn nth503(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[16096..16128])
    }
    pub fn nth504(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[16128..16160])
    }
    pub fn nth505(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[16160..16192])
    }
    pub fn nth506(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[16192..16224])
    }
    pub fn nth507(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[16224..16256])
    }
    pub fn nth508(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[16256..16288])
    }
    pub fn nth509(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[16288..16320])
    }
    pub fn nth510(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[16320..16352])
    }
    pub fn nth511(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[16352..16384])
    }
}
impl<'r> molecule::prelude::Reader<'r> for BlsPubkeyArrayReader<'r> {
    type Entity = BlsPubkeyArray;
    const NAME: &'static str = "BlsPubkeyArrayReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        BlsPubkeyArrayReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
pub struct BlsPubkeyArrayBuilder(pub(crate) [BlsPubkey; 512]);
impl ::core::fmt::Debug for BlsPubkeyArrayBuilder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::core::default::Default for BlsPubkeyArrayBuilder {
    fn default() -> Self {
        BlsPubkeyArrayBuilder([
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
            BlsPubkey::default(),
        ])
    }
}
impl BlsPubkeyArrayBuilder {
    pub const TOTAL_SIZE: usize = 16384;
    pub const ITEM_SIZE: usize = 32;
    pub const ITEM_COUNT: usize = 512;
    pub fn set(mut self, v: [BlsPubkey; 512]) -> Self {
        self.0 = v;
        self
    }
    pub fn nth0(mut self, v: BlsPubkey) -> Self {
        self.0[0] = v;
        self
    }
    pub fn nth1(mut self, v: BlsPubkey) -> Self {
        self.0[1] = v;
        self
    }
    pub fn nth2(mut self, v: BlsPubkey) -> Self {
        self.0[2] = v;
        self
    }
    pub fn nth3(mut self, v: BlsPubkey) -> Self {
        self.0[3] = v;
        self
    }
    pub fn nth4(mut self, v: BlsPubkey) -> Self {
        self.0[4] = v;
        self
    }
    pub fn nth5(mut self, v: BlsPubkey) -> Self {
        self.0[5] = v;
        self
    }
    pub fn nth6(mut self, v: BlsPubkey) -> Self {
        self.0[6] = v;
        self
    }
    pub fn nth7(mut self, v: BlsPubkey) -> Self {
        self.0[7] = v;
        self
    }
    pub fn nth8(mut self, v: BlsPubkey) -> Self {
        self.0[8] = v;
        self
    }
    pub fn nth9(mut self, v: BlsPubkey) -> Self {
        self.0[9] = v;
        self
    }
    pub fn nth10(mut self, v: BlsPubkey) -> Self {
        self.0[10] = v;
        self
    }
    pub fn nth11(mut self, v: BlsPubkey) -> Self {
        self.0[11] = v;
        self
    }
    pub fn nth12(mut self, v: BlsPubkey) -> Self {
        self.0[12] = v;
        self
    }
    pub fn nth13(mut self, v: BlsPubkey) -> Self {
        self.0[13] = v;
        self
    }
    pub fn nth14(mut self, v: BlsPubkey) -> Self {
        self.0[14] = v;
        self
    }
    pub fn nth15(mut self, v: BlsPubkey) -> Self {
        self.0[15] = v;
        self
    }
    pub fn nth16(mut self, v: BlsPubkey) -> Self {
        self.0[16] = v;
        self
    }
    pub fn nth17(mut self, v: BlsPubkey) -> Self {
        self.0[17] = v;
        self
    }
    pub fn nth18(mut self, v: BlsPubkey) -> Self {
        self.0[18] = v;
        self
    }
    pub fn nth19(mut self, v: BlsPubkey) -> Self {
        self.0[19] = v;
        self
    }
    pub fn nth20(mut self, v: BlsPubkey) -> Self {
        self.0[20] = v;
        self
    }
    pub fn nth21(mut self, v: BlsPubkey) -> Self {
        self.0[21] = v;
        self
    }
    pub fn nth22(mut self, v: BlsPubkey) -> Self {
        self.0[22] = v;
        self
    }
    pub fn nth23(mut self, v: BlsPubkey) -> Self {
        self.0[23] = v;
        self
    }
    pub fn nth24(mut self, v: BlsPubkey) -> Self {
        self.0[24] = v;
        self
    }
    pub fn nth25(mut self, v: BlsPubkey) -> Self {
        self.0[25] = v;
        self
    }
    pub fn nth26(mut self, v: BlsPubkey) -> Self {
        self.0[26] = v;
        self
    }
    pub fn nth27(mut self, v: BlsPubkey) -> Self {
        self.0[27] = v;
        self
    }
    pub fn nth28(mut self, v: BlsPubkey) -> Self {
        self.0[28] = v;
        self
    }
    pub fn nth29(mut self, v: BlsPubkey) -> Self {
        self.0[29] = v;
        self
    }
    pub fn nth30(mut self, v: BlsPubkey) -> Self {
        self.0[30] = v;
        self
    }
    pub fn nth31(mut self, v: BlsPubkey) -> Self {
        self.0[31] = v;
        self
    }
    pub fn nth32(mut self, v: BlsPubkey) -> Self {
        self.0[32] = v;
        self
    }
    pub fn nth33(mut self, v: BlsPubkey) -> Self {
        self.0[33] = v;
        self
    }
    pub fn nth34(mut self, v: BlsPubkey) -> Self {
        self.0[34] = v;
        self
    }
    pub fn nth35(mut self, v: BlsPubkey) -> Self {
        self.0[35] = v;
        self
    }
    pub fn nth36(mut self, v: BlsPubkey) -> Self {
        self.0[36] = v;
        self
    }
    pub fn nth37(mut self, v: BlsPubkey) -> Self {
        self.0[37] = v;
        self
    }
    pub fn nth38(mut self, v: BlsPubkey) -> Self {
        self.0[38] = v;
        self
    }
    pub fn nth39(mut self, v: BlsPubkey) -> Self {
        self.0[39] = v;
        self
    }
    pub fn nth40(mut self, v: BlsPubkey) -> Self {
        self.0[40] = v;
        self
    }
    pub fn nth41(mut self, v: BlsPubkey) -> Self {
        self.0[41] = v;
        self
    }
    pub fn nth42(mut self, v: BlsPubkey) -> Self {
        self.0[42] = v;
        self
    }
    pub fn nth43(mut self, v: BlsPubkey) -> Self {
        self.0[43] = v;
        self
    }
    pub fn nth44(mut self, v: BlsPubkey) -> Self {
        self.0[44] = v;
        self
    }
    pub fn nth45(mut self, v: BlsPubkey) -> Self {
        self.0[45] = v;
        self
    }
    pub fn nth46(mut self, v: BlsPubkey) -> Self {
        self.0[46] = v;
        self
    }
    pub fn nth47(mut self, v: BlsPubkey) -> Self {
        self.0[47] = v;
        self
    }
    pub fn nth48(mut self, v: BlsPubkey) -> Self {
        self.0[48] = v;
        self
    }
    pub fn nth49(mut self, v: BlsPubkey) -> Self {
        self.0[49] = v;
        self
    }
    pub fn nth50(mut self, v: BlsPubkey) -> Self {
        self.0[50] = v;
        self
    }
    pub fn nth51(mut self, v: BlsPubkey) -> Self {
        self.0[51] = v;
        self
    }
    pub fn nth52(mut self, v: BlsPubkey) -> Self {
        self.0[52] = v;
        self
    }
    pub fn nth53(mut self, v: BlsPubkey) -> Self {
        self.0[53] = v;
        self
    }
    pub fn nth54(mut self, v: BlsPubkey) -> Self {
        self.0[54] = v;
        self
    }
    pub fn nth55(mut self, v: BlsPubkey) -> Self {
        self.0[55] = v;
        self
    }
    pub fn nth56(mut self, v: BlsPubkey) -> Self {
        self.0[56] = v;
        self
    }
    pub fn nth57(mut self, v: BlsPubkey) -> Self {
        self.0[57] = v;
        self
    }
    pub fn nth58(mut self, v: BlsPubkey) -> Self {
        self.0[58] = v;
        self
    }
    pub fn nth59(mut self, v: BlsPubkey) -> Self {
        self.0[59] = v;
        self
    }
    pub fn nth60(mut self, v: BlsPubkey) -> Self {
        self.0[60] = v;
        self
    }
    pub fn nth61(mut self, v: BlsPubkey) -> Self {
        self.0[61] = v;
        self
    }
    pub fn nth62(mut self, v: BlsPubkey) -> Self {
        self.0[62] = v;
        self
    }
    pub fn nth63(mut self, v: BlsPubkey) -> Self {
        self.0[63] = v;
        self
    }
    pub fn nth64(mut self, v: BlsPubkey) -> Self {
        self.0[64] = v;
        self
    }
    pub fn nth65(mut self, v: BlsPubkey) -> Self {
        self.0[65] = v;
        self
    }
    pub fn nth66(mut self, v: BlsPubkey) -> Self {
        self.0[66] = v;
        self
    }
    pub fn nth67(mut self, v: BlsPubkey) -> Self {
        self.0[67] = v;
        self
    }
    pub fn nth68(mut self, v: BlsPubkey) -> Self {
        self.0[68] = v;
        self
    }
    pub fn nth69(mut self, v: BlsPubkey) -> Self {
        self.0[69] = v;
        self
    }
    pub fn nth70(mut self, v: BlsPubkey) -> Self {
        self.0[70] = v;
        self
    }
    pub fn nth71(mut self, v: BlsPubkey) -> Self {
        self.0[71] = v;
        self
    }
    pub fn nth72(mut self, v: BlsPubkey) -> Self {
        self.0[72] = v;
        self
    }
    pub fn nth73(mut self, v: BlsPubkey) -> Self {
        self.0[73] = v;
        self
    }
    pub fn nth74(mut self, v: BlsPubkey) -> Self {
        self.0[74] = v;
        self
    }
    pub fn nth75(mut self, v: BlsPubkey) -> Self {
        self.0[75] = v;
        self
    }
    pub fn nth76(mut self, v: BlsPubkey) -> Self {
        self.0[76] = v;
        self
    }
    pub fn nth77(mut self, v: BlsPubkey) -> Self {
        self.0[77] = v;
        self
    }
    pub fn nth78(mut self, v: BlsPubkey) -> Self {
        self.0[78] = v;
        self
    }
    pub fn nth79(mut self, v: BlsPubkey) -> Self {
        self.0[79] = v;
        self
    }
    pub fn nth80(mut self, v: BlsPubkey) -> Self {
        self.0[80] = v;
        self
    }
    pub fn nth81(mut self, v: BlsPubkey) -> Self {
        self.0[81] = v;
        self
    }
    pub fn nth82(mut self, v: BlsPubkey) -> Self {
        self.0[82] = v;
        self
    }
    pub fn nth83(mut self, v: BlsPubkey) -> Self {
        self.0[83] = v;
        self
    }
    pub fn nth84(mut self, v: BlsPubkey) -> Self {
        self.0[84] = v;
        self
    }
    pub fn nth85(mut self, v: BlsPubkey) -> Self {
        self.0[85] = v;
        self
    }
    pub fn nth86(mut self, v: BlsPubkey) -> Self {
        self.0[86] = v;
        self
    }
    pub fn nth87(mut self, v: BlsPubkey) -> Self {
        self.0[87] = v;
        self
    }
    pub fn nth88(mut self, v: BlsPubkey) -> Self {
        self.0[88] = v;
        self
    }
    pub fn nth89(mut self, v: BlsPubkey) -> Self {
        self.0[89] = v;
        self
    }
    pub fn nth90(mut self, v: BlsPubkey) -> Self {
        self.0[90] = v;
        self
    }
    pub fn nth91(mut self, v: BlsPubkey) -> Self {
        self.0[91] = v;
        self
    }
    pub fn nth92(mut self, v: BlsPubkey) -> Self {
        self.0[92] = v;
        self
    }
    pub fn nth93(mut self, v: BlsPubkey) -> Self {
        self.0[93] = v;
        self
    }
    pub fn nth94(mut self, v: BlsPubkey) -> Self {
        self.0[94] = v;
        self
    }
    pub fn nth95(mut self, v: BlsPubkey) -> Self {
        self.0[95] = v;
        self
    }
    pub fn nth96(mut self, v: BlsPubkey) -> Self {
        self.0[96] = v;
        self
    }
    pub fn nth97(mut self, v: BlsPubkey) -> Self {
        self.0[97] = v;
        self
    }
    pub fn nth98(mut self, v: BlsPubkey) -> Self {
        self.0[98] = v;
        self
    }
    pub fn nth99(mut self, v: BlsPubkey) -> Self {
        self.0[99] = v;
        self
    }
    pub fn nth100(mut self, v: BlsPubkey) -> Self {
        self.0[100] = v;
        self
    }
    pub fn nth101(mut self, v: BlsPubkey) -> Self {
        self.0[101] = v;
        self
    }
    pub fn nth102(mut self, v: BlsPubkey) -> Self {
        self.0[102] = v;
        self
    }
    pub fn nth103(mut self, v: BlsPubkey) -> Self {
        self.0[103] = v;
        self
    }
    pub fn nth104(mut self, v: BlsPubkey) -> Self {
        self.0[104] = v;
        self
    }
    pub fn nth105(mut self, v: BlsPubkey) -> Self {
        self.0[105] = v;
        self
    }
    pub fn nth106(mut self, v: BlsPubkey) -> Self {
        self.0[106] = v;
        self
    }
    pub fn nth107(mut self, v: BlsPubkey) -> Self {
        self.0[107] = v;
        self
    }
    pub fn nth108(mut self, v: BlsPubkey) -> Self {
        self.0[108] = v;
        self
    }
    pub fn nth109(mut self, v: BlsPubkey) -> Self {
        self.0[109] = v;
        self
    }
    pub fn nth110(mut self, v: BlsPubkey) -> Self {
        self.0[110] = v;
        self
    }
    pub fn nth111(mut self, v: BlsPubkey) -> Self {
        self.0[111] = v;
        self
    }
    pub fn nth112(mut self, v: BlsPubkey) -> Self {
        self.0[112] = v;
        self
    }
    pub fn nth113(mut self, v: BlsPubkey) -> Self {
        self.0[113] = v;
        self
    }
    pub fn nth114(mut self, v: BlsPubkey) -> Self {
        self.0[114] = v;
        self
    }
    pub fn nth115(mut self, v: BlsPubkey) -> Self {
        self.0[115] = v;
        self
    }
    pub fn nth116(mut self, v: BlsPubkey) -> Self {
        self.0[116] = v;
        self
    }
    pub fn nth117(mut self, v: BlsPubkey) -> Self {
        self.0[117] = v;
        self
    }
    pub fn nth118(mut self, v: BlsPubkey) -> Self {
        self.0[118] = v;
        self
    }
    pub fn nth119(mut self, v: BlsPubkey) -> Self {
        self.0[119] = v;
        self
    }
    pub fn nth120(mut self, v: BlsPubkey) -> Self {
        self.0[120] = v;
        self
    }
    pub fn nth121(mut self, v: BlsPubkey) -> Self {
        self.0[121] = v;
        self
    }
    pub fn nth122(mut self, v: BlsPubkey) -> Self {
        self.0[122] = v;
        self
    }
    pub fn nth123(mut self, v: BlsPubkey) -> Self {
        self.0[123] = v;
        self
    }
    pub fn nth124(mut self, v: BlsPubkey) -> Self {
        self.0[124] = v;
        self
    }
    pub fn nth125(mut self, v: BlsPubkey) -> Self {
        self.0[125] = v;
        self
    }
    pub fn nth126(mut self, v: BlsPubkey) -> Self {
        self.0[126] = v;
        self
    }
    pub fn nth127(mut self, v: BlsPubkey) -> Self {
        self.0[127] = v;
        self
    }
    pub fn nth128(mut self, v: BlsPubkey) -> Self {
        self.0[128] = v;
        self
    }
    pub fn nth129(mut self, v: BlsPubkey) -> Self {
        self.0[129] = v;
        self
    }
    pub fn nth130(mut self, v: BlsPubkey) -> Self {
        self.0[130] = v;
        self
    }
    pub fn nth131(mut self, v: BlsPubkey) -> Self {
        self.0[131] = v;
        self
    }
    pub fn nth132(mut self, v: BlsPubkey) -> Self {
        self.0[132] = v;
        self
    }
    pub fn nth133(mut self, v: BlsPubkey) -> Self {
        self.0[133] = v;
        self
    }
    pub fn nth134(mut self, v: BlsPubkey) -> Self {
        self.0[134] = v;
        self
    }
    pub fn nth135(mut self, v: BlsPubkey) -> Self {
        self.0[135] = v;
        self
    }
    pub fn nth136(mut self, v: BlsPubkey) -> Self {
        self.0[136] = v;
        self
    }
    pub fn nth137(mut self, v: BlsPubkey) -> Self {
        self.0[137] = v;
        self
    }
    pub fn nth138(mut self, v: BlsPubkey) -> Self {
        self.0[138] = v;
        self
    }
    pub fn nth139(mut self, v: BlsPubkey) -> Self {
        self.0[139] = v;
        self
    }
    pub fn nth140(mut self, v: BlsPubkey) -> Self {
        self.0[140] = v;
        self
    }
    pub fn nth141(mut self, v: BlsPubkey) -> Self {
        self.0[141] = v;
        self
    }
    pub fn nth142(mut self, v: BlsPubkey) -> Self {
        self.0[142] = v;
        self
    }
    pub fn nth143(mut self, v: BlsPubkey) -> Self {
        self.0[143] = v;
        self
    }
    pub fn nth144(mut self, v: BlsPubkey) -> Self {
        self.0[144] = v;
        self
    }
    pub fn nth145(mut self, v: BlsPubkey) -> Self {
        self.0[145] = v;
        self
    }
    pub fn nth146(mut self, v: BlsPubkey) -> Self {
        self.0[146] = v;
        self
    }
    pub fn nth147(mut self, v: BlsPubkey) -> Self {
        self.0[147] = v;
        self
    }
    pub fn nth148(mut self, v: BlsPubkey) -> Self {
        self.0[148] = v;
        self
    }
    pub fn nth149(mut self, v: BlsPubkey) -> Self {
        self.0[149] = v;
        self
    }
    pub fn nth150(mut self, v: BlsPubkey) -> Self {
        self.0[150] = v;
        self
    }
    pub fn nth151(mut self, v: BlsPubkey) -> Self {
        self.0[151] = v;
        self
    }
    pub fn nth152(mut self, v: BlsPubkey) -> Self {
        self.0[152] = v;
        self
    }
    pub fn nth153(mut self, v: BlsPubkey) -> Self {
        self.0[153] = v;
        self
    }
    pub fn nth154(mut self, v: BlsPubkey) -> Self {
        self.0[154] = v;
        self
    }
    pub fn nth155(mut self, v: BlsPubkey) -> Self {
        self.0[155] = v;
        self
    }
    pub fn nth156(mut self, v: BlsPubkey) -> Self {
        self.0[156] = v;
        self
    }
    pub fn nth157(mut self, v: BlsPubkey) -> Self {
        self.0[157] = v;
        self
    }
    pub fn nth158(mut self, v: BlsPubkey) -> Self {
        self.0[158] = v;
        self
    }
    pub fn nth159(mut self, v: BlsPubkey) -> Self {
        self.0[159] = v;
        self
    }
    pub fn nth160(mut self, v: BlsPubkey) -> Self {
        self.0[160] = v;
        self
    }
    pub fn nth161(mut self, v: BlsPubkey) -> Self {
        self.0[161] = v;
        self
    }
    pub fn nth162(mut self, v: BlsPubkey) -> Self {
        self.0[162] = v;
        self
    }
    pub fn nth163(mut self, v: BlsPubkey) -> Self {
        self.0[163] = v;
        self
    }
    pub fn nth164(mut self, v: BlsPubkey) -> Self {
        self.0[164] = v;
        self
    }
    pub fn nth165(mut self, v: BlsPubkey) -> Self {
        self.0[165] = v;
        self
    }
    pub fn nth166(mut self, v: BlsPubkey) -> Self {
        self.0[166] = v;
        self
    }
    pub fn nth167(mut self, v: BlsPubkey) -> Self {
        self.0[167] = v;
        self
    }
    pub fn nth168(mut self, v: BlsPubkey) -> Self {
        self.0[168] = v;
        self
    }
    pub fn nth169(mut self, v: BlsPubkey) -> Self {
        self.0[169] = v;
        self
    }
    pub fn nth170(mut self, v: BlsPubkey) -> Self {
        self.0[170] = v;
        self
    }
    pub fn nth171(mut self, v: BlsPubkey) -> Self {
        self.0[171] = v;
        self
    }
    pub fn nth172(mut self, v: BlsPubkey) -> Self {
        self.0[172] = v;
        self
    }
    pub fn nth173(mut self, v: BlsPubkey) -> Self {
        self.0[173] = v;
        self
    }
    pub fn nth174(mut self, v: BlsPubkey) -> Self {
        self.0[174] = v;
        self
    }
    pub fn nth175(mut self, v: BlsPubkey) -> Self {
        self.0[175] = v;
        self
    }
    pub fn nth176(mut self, v: BlsPubkey) -> Self {
        self.0[176] = v;
        self
    }
    pub fn nth177(mut self, v: BlsPubkey) -> Self {
        self.0[177] = v;
        self
    }
    pub fn nth178(mut self, v: BlsPubkey) -> Self {
        self.0[178] = v;
        self
    }
    pub fn nth179(mut self, v: BlsPubkey) -> Self {
        self.0[179] = v;
        self
    }
    pub fn nth180(mut self, v: BlsPubkey) -> Self {
        self.0[180] = v;
        self
    }
    pub fn nth181(mut self, v: BlsPubkey) -> Self {
        self.0[181] = v;
        self
    }
    pub fn nth182(mut self, v: BlsPubkey) -> Self {
        self.0[182] = v;
        self
    }
    pub fn nth183(mut self, v: BlsPubkey) -> Self {
        self.0[183] = v;
        self
    }
    pub fn nth184(mut self, v: BlsPubkey) -> Self {
        self.0[184] = v;
        self
    }
    pub fn nth185(mut self, v: BlsPubkey) -> Self {
        self.0[185] = v;
        self
    }
    pub fn nth186(mut self, v: BlsPubkey) -> Self {
        self.0[186] = v;
        self
    }
    pub fn nth187(mut self, v: BlsPubkey) -> Self {
        self.0[187] = v;
        self
    }
    pub fn nth188(mut self, v: BlsPubkey) -> Self {
        self.0[188] = v;
        self
    }
    pub fn nth189(mut self, v: BlsPubkey) -> Self {
        self.0[189] = v;
        self
    }
    pub fn nth190(mut self, v: BlsPubkey) -> Self {
        self.0[190] = v;
        self
    }
    pub fn nth191(mut self, v: BlsPubkey) -> Self {
        self.0[191] = v;
        self
    }
    pub fn nth192(mut self, v: BlsPubkey) -> Self {
        self.0[192] = v;
        self
    }
    pub fn nth193(mut self, v: BlsPubkey) -> Self {
        self.0[193] = v;
        self
    }
    pub fn nth194(mut self, v: BlsPubkey) -> Self {
        self.0[194] = v;
        self
    }
    pub fn nth195(mut self, v: BlsPubkey) -> Self {
        self.0[195] = v;
        self
    }
    pub fn nth196(mut self, v: BlsPubkey) -> Self {
        self.0[196] = v;
        self
    }
    pub fn nth197(mut self, v: BlsPubkey) -> Self {
        self.0[197] = v;
        self
    }
    pub fn nth198(mut self, v: BlsPubkey) -> Self {
        self.0[198] = v;
        self
    }
    pub fn nth199(mut self, v: BlsPubkey) -> Self {
        self.0[199] = v;
        self
    }
    pub fn nth200(mut self, v: BlsPubkey) -> Self {
        self.0[200] = v;
        self
    }
    pub fn nth201(mut self, v: BlsPubkey) -> Self {
        self.0[201] = v;
        self
    }
    pub fn nth202(mut self, v: BlsPubkey) -> Self {
        self.0[202] = v;
        self
    }
    pub fn nth203(mut self, v: BlsPubkey) -> Self {
        self.0[203] = v;
        self
    }
    pub fn nth204(mut self, v: BlsPubkey) -> Self {
        self.0[204] = v;
        self
    }
    pub fn nth205(mut self, v: BlsPubkey) -> Self {
        self.0[205] = v;
        self
    }
    pub fn nth206(mut self, v: BlsPubkey) -> Self {
        self.0[206] = v;
        self
    }
    pub fn nth207(mut self, v: BlsPubkey) -> Self {
        self.0[207] = v;
        self
    }
    pub fn nth208(mut self, v: BlsPubkey) -> Self {
        self.0[208] = v;
        self
    }
    pub fn nth209(mut self, v: BlsPubkey) -> Self {
        self.0[209] = v;
        self
    }
    pub fn nth210(mut self, v: BlsPubkey) -> Self {
        self.0[210] = v;
        self
    }
    pub fn nth211(mut self, v: BlsPubkey) -> Self {
        self.0[211] = v;
        self
    }
    pub fn nth212(mut self, v: BlsPubkey) -> Self {
        self.0[212] = v;
        self
    }
    pub fn nth213(mut self, v: BlsPubkey) -> Self {
        self.0[213] = v;
        self
    }
    pub fn nth214(mut self, v: BlsPubkey) -> Self {
        self.0[214] = v;
        self
    }
    pub fn nth215(mut self, v: BlsPubkey) -> Self {
        self.0[215] = v;
        self
    }
    pub fn nth216(mut self, v: BlsPubkey) -> Self {
        self.0[216] = v;
        self
    }
    pub fn nth217(mut self, v: BlsPubkey) -> Self {
        self.0[217] = v;
        self
    }
    pub fn nth218(mut self, v: BlsPubkey) -> Self {
        self.0[218] = v;
        self
    }
    pub fn nth219(mut self, v: BlsPubkey) -> Self {
        self.0[219] = v;
        self
    }
    pub fn nth220(mut self, v: BlsPubkey) -> Self {
        self.0[220] = v;
        self
    }
    pub fn nth221(mut self, v: BlsPubkey) -> Self {
        self.0[221] = v;
        self
    }
    pub fn nth222(mut self, v: BlsPubkey) -> Self {
        self.0[222] = v;
        self
    }
    pub fn nth223(mut self, v: BlsPubkey) -> Self {
        self.0[223] = v;
        self
    }
    pub fn nth224(mut self, v: BlsPubkey) -> Self {
        self.0[224] = v;
        self
    }
    pub fn nth225(mut self, v: BlsPubkey) -> Self {
        self.0[225] = v;
        self
    }
    pub fn nth226(mut self, v: BlsPubkey) -> Self {
        self.0[226] = v;
        self
    }
    pub fn nth227(mut self, v: BlsPubkey) -> Self {
        self.0[227] = v;
        self
    }
    pub fn nth228(mut self, v: BlsPubkey) -> Self {
        self.0[228] = v;
        self
    }
    pub fn nth229(mut self, v: BlsPubkey) -> Self {
        self.0[229] = v;
        self
    }
    pub fn nth230(mut self, v: BlsPubkey) -> Self {
        self.0[230] = v;
        self
    }
    pub fn nth231(mut self, v: BlsPubkey) -> Self {
        self.0[231] = v;
        self
    }
    pub fn nth232(mut self, v: BlsPubkey) -> Self {
        self.0[232] = v;
        self
    }
    pub fn nth233(mut self, v: BlsPubkey) -> Self {
        self.0[233] = v;
        self
    }
    pub fn nth234(mut self, v: BlsPubkey) -> Self {
        self.0[234] = v;
        self
    }
    pub fn nth235(mut self, v: BlsPubkey) -> Self {
        self.0[235] = v;
        self
    }
    pub fn nth236(mut self, v: BlsPubkey) -> Self {
        self.0[236] = v;
        self
    }
    pub fn nth237(mut self, v: BlsPubkey) -> Self {
        self.0[237] = v;
        self
    }
    pub fn nth238(mut self, v: BlsPubkey) -> Self {
        self.0[238] = v;
        self
    }
    pub fn nth239(mut self, v: BlsPubkey) -> Self {
        self.0[239] = v;
        self
    }
    pub fn nth240(mut self, v: BlsPubkey) -> Self {
        self.0[240] = v;
        self
    }
    pub fn nth241(mut self, v: BlsPubkey) -> Self {
        self.0[241] = v;
        self
    }
    pub fn nth242(mut self, v: BlsPubkey) -> Self {
        self.0[242] = v;
        self
    }
    pub fn nth243(mut self, v: BlsPubkey) -> Self {
        self.0[243] = v;
        self
    }
    pub fn nth244(mut self, v: BlsPubkey) -> Self {
        self.0[244] = v;
        self
    }
    pub fn nth245(mut self, v: BlsPubkey) -> Self {
        self.0[245] = v;
        self
    }
    pub fn nth246(mut self, v: BlsPubkey) -> Self {
        self.0[246] = v;
        self
    }
    pub fn nth247(mut self, v: BlsPubkey) -> Self {
        self.0[247] = v;
        self
    }
    pub fn nth248(mut self, v: BlsPubkey) -> Self {
        self.0[248] = v;
        self
    }
    pub fn nth249(mut self, v: BlsPubkey) -> Self {
        self.0[249] = v;
        self
    }
    pub fn nth250(mut self, v: BlsPubkey) -> Self {
        self.0[250] = v;
        self
    }
    pub fn nth251(mut self, v: BlsPubkey) -> Self {
        self.0[251] = v;
        self
    }
    pub fn nth252(mut self, v: BlsPubkey) -> Self {
        self.0[252] = v;
        self
    }
    pub fn nth253(mut self, v: BlsPubkey) -> Self {
        self.0[253] = v;
        self
    }
    pub fn nth254(mut self, v: BlsPubkey) -> Self {
        self.0[254] = v;
        self
    }
    pub fn nth255(mut self, v: BlsPubkey) -> Self {
        self.0[255] = v;
        self
    }
    pub fn nth256(mut self, v: BlsPubkey) -> Self {
        self.0[256] = v;
        self
    }
    pub fn nth257(mut self, v: BlsPubkey) -> Self {
        self.0[257] = v;
        self
    }
    pub fn nth258(mut self, v: BlsPubkey) -> Self {
        self.0[258] = v;
        self
    }
    pub fn nth259(mut self, v: BlsPubkey) -> Self {
        self.0[259] = v;
        self
    }
    pub fn nth260(mut self, v: BlsPubkey) -> Self {
        self.0[260] = v;
        self
    }
    pub fn nth261(mut self, v: BlsPubkey) -> Self {
        self.0[261] = v;
        self
    }
    pub fn nth262(mut self, v: BlsPubkey) -> Self {
        self.0[262] = v;
        self
    }
    pub fn nth263(mut self, v: BlsPubkey) -> Self {
        self.0[263] = v;
        self
    }
    pub fn nth264(mut self, v: BlsPubkey) -> Self {
        self.0[264] = v;
        self
    }
    pub fn nth265(mut self, v: BlsPubkey) -> Self {
        self.0[265] = v;
        self
    }
    pub fn nth266(mut self, v: BlsPubkey) -> Self {
        self.0[266] = v;
        self
    }
    pub fn nth267(mut self, v: BlsPubkey) -> Self {
        self.0[267] = v;
        self
    }
    pub fn nth268(mut self, v: BlsPubkey) -> Self {
        self.0[268] = v;
        self
    }
    pub fn nth269(mut self, v: BlsPubkey) -> Self {
        self.0[269] = v;
        self
    }
    pub fn nth270(mut self, v: BlsPubkey) -> Self {
        self.0[270] = v;
        self
    }
    pub fn nth271(mut self, v: BlsPubkey) -> Self {
        self.0[271] = v;
        self
    }
    pub fn nth272(mut self, v: BlsPubkey) -> Self {
        self.0[272] = v;
        self
    }
    pub fn nth273(mut self, v: BlsPubkey) -> Self {
        self.0[273] = v;
        self
    }
    pub fn nth274(mut self, v: BlsPubkey) -> Self {
        self.0[274] = v;
        self
    }
    pub fn nth275(mut self, v: BlsPubkey) -> Self {
        self.0[275] = v;
        self
    }
    pub fn nth276(mut self, v: BlsPubkey) -> Self {
        self.0[276] = v;
        self
    }
    pub fn nth277(mut self, v: BlsPubkey) -> Self {
        self.0[277] = v;
        self
    }
    pub fn nth278(mut self, v: BlsPubkey) -> Self {
        self.0[278] = v;
        self
    }
    pub fn nth279(mut self, v: BlsPubkey) -> Self {
        self.0[279] = v;
        self
    }
    pub fn nth280(mut self, v: BlsPubkey) -> Self {
        self.0[280] = v;
        self
    }
    pub fn nth281(mut self, v: BlsPubkey) -> Self {
        self.0[281] = v;
        self
    }
    pub fn nth282(mut self, v: BlsPubkey) -> Self {
        self.0[282] = v;
        self
    }
    pub fn nth283(mut self, v: BlsPubkey) -> Self {
        self.0[283] = v;
        self
    }
    pub fn nth284(mut self, v: BlsPubkey) -> Self {
        self.0[284] = v;
        self
    }
    pub fn nth285(mut self, v: BlsPubkey) -> Self {
        self.0[285] = v;
        self
    }
    pub fn nth286(mut self, v: BlsPubkey) -> Self {
        self.0[286] = v;
        self
    }
    pub fn nth287(mut self, v: BlsPubkey) -> Self {
        self.0[287] = v;
        self
    }
    pub fn nth288(mut self, v: BlsPubkey) -> Self {
        self.0[288] = v;
        self
    }
    pub fn nth289(mut self, v: BlsPubkey) -> Self {
        self.0[289] = v;
        self
    }
    pub fn nth290(mut self, v: BlsPubkey) -> Self {
        self.0[290] = v;
        self
    }
    pub fn nth291(mut self, v: BlsPubkey) -> Self {
        self.0[291] = v;
        self
    }
    pub fn nth292(mut self, v: BlsPubkey) -> Self {
        self.0[292] = v;
        self
    }
    pub fn nth293(mut self, v: BlsPubkey) -> Self {
        self.0[293] = v;
        self
    }
    pub fn nth294(mut self, v: BlsPubkey) -> Self {
        self.0[294] = v;
        self
    }
    pub fn nth295(mut self, v: BlsPubkey) -> Self {
        self.0[295] = v;
        self
    }
    pub fn nth296(mut self, v: BlsPubkey) -> Self {
        self.0[296] = v;
        self
    }
    pub fn nth297(mut self, v: BlsPubkey) -> Self {
        self.0[297] = v;
        self
    }
    pub fn nth298(mut self, v: BlsPubkey) -> Self {
        self.0[298] = v;
        self
    }
    pub fn nth299(mut self, v: BlsPubkey) -> Self {
        self.0[299] = v;
        self
    }
    pub fn nth300(mut self, v: BlsPubkey) -> Self {
        self.0[300] = v;
        self
    }
    pub fn nth301(mut self, v: BlsPubkey) -> Self {
        self.0[301] = v;
        self
    }
    pub fn nth302(mut self, v: BlsPubkey) -> Self {
        self.0[302] = v;
        self
    }
    pub fn nth303(mut self, v: BlsPubkey) -> Self {
        self.0[303] = v;
        self
    }
    pub fn nth304(mut self, v: BlsPubkey) -> Self {
        self.0[304] = v;
        self
    }
    pub fn nth305(mut self, v: BlsPubkey) -> Self {
        self.0[305] = v;
        self
    }
    pub fn nth306(mut self, v: BlsPubkey) -> Self {
        self.0[306] = v;
        self
    }
    pub fn nth307(mut self, v: BlsPubkey) -> Self {
        self.0[307] = v;
        self
    }
    pub fn nth308(mut self, v: BlsPubkey) -> Self {
        self.0[308] = v;
        self
    }
    pub fn nth309(mut self, v: BlsPubkey) -> Self {
        self.0[309] = v;
        self
    }
    pub fn nth310(mut self, v: BlsPubkey) -> Self {
        self.0[310] = v;
        self
    }
    pub fn nth311(mut self, v: BlsPubkey) -> Self {
        self.0[311] = v;
        self
    }
    pub fn nth312(mut self, v: BlsPubkey) -> Self {
        self.0[312] = v;
        self
    }
    pub fn nth313(mut self, v: BlsPubkey) -> Self {
        self.0[313] = v;
        self
    }
    pub fn nth314(mut self, v: BlsPubkey) -> Self {
        self.0[314] = v;
        self
    }
    pub fn nth315(mut self, v: BlsPubkey) -> Self {
        self.0[315] = v;
        self
    }
    pub fn nth316(mut self, v: BlsPubkey) -> Self {
        self.0[316] = v;
        self
    }
    pub fn nth317(mut self, v: BlsPubkey) -> Self {
        self.0[317] = v;
        self
    }
    pub fn nth318(mut self, v: BlsPubkey) -> Self {
        self.0[318] = v;
        self
    }
    pub fn nth319(mut self, v: BlsPubkey) -> Self {
        self.0[319] = v;
        self
    }
    pub fn nth320(mut self, v: BlsPubkey) -> Self {
        self.0[320] = v;
        self
    }
    pub fn nth321(mut self, v: BlsPubkey) -> Self {
        self.0[321] = v;
        self
    }
    pub fn nth322(mut self, v: BlsPubkey) -> Self {
        self.0[322] = v;
        self
    }
    pub fn nth323(mut self, v: BlsPubkey) -> Self {
        self.0[323] = v;
        self
    }
    pub fn nth324(mut self, v: BlsPubkey) -> Self {
        self.0[324] = v;
        self
    }
    pub fn nth325(mut self, v: BlsPubkey) -> Self {
        self.0[325] = v;
        self
    }
    pub fn nth326(mut self, v: BlsPubkey) -> Self {
        self.0[326] = v;
        self
    }
    pub fn nth327(mut self, v: BlsPubkey) -> Self {
        self.0[327] = v;
        self
    }
    pub fn nth328(mut self, v: BlsPubkey) -> Self {
        self.0[328] = v;
        self
    }
    pub fn nth329(mut self, v: BlsPubkey) -> Self {
        self.0[329] = v;
        self
    }
    pub fn nth330(mut self, v: BlsPubkey) -> Self {
        self.0[330] = v;
        self
    }
    pub fn nth331(mut self, v: BlsPubkey) -> Self {
        self.0[331] = v;
        self
    }
    pub fn nth332(mut self, v: BlsPubkey) -> Self {
        self.0[332] = v;
        self
    }
    pub fn nth333(mut self, v: BlsPubkey) -> Self {
        self.0[333] = v;
        self
    }
    pub fn nth334(mut self, v: BlsPubkey) -> Self {
        self.0[334] = v;
        self
    }
    pub fn nth335(mut self, v: BlsPubkey) -> Self {
        self.0[335] = v;
        self
    }
    pub fn nth336(mut self, v: BlsPubkey) -> Self {
        self.0[336] = v;
        self
    }
    pub fn nth337(mut self, v: BlsPubkey) -> Self {
        self.0[337] = v;
        self
    }
    pub fn nth338(mut self, v: BlsPubkey) -> Self {
        self.0[338] = v;
        self
    }
    pub fn nth339(mut self, v: BlsPubkey) -> Self {
        self.0[339] = v;
        self
    }
    pub fn nth340(mut self, v: BlsPubkey) -> Self {
        self.0[340] = v;
        self
    }
    pub fn nth341(mut self, v: BlsPubkey) -> Self {
        self.0[341] = v;
        self
    }
    pub fn nth342(mut self, v: BlsPubkey) -> Self {
        self.0[342] = v;
        self
    }
    pub fn nth343(mut self, v: BlsPubkey) -> Self {
        self.0[343] = v;
        self
    }
    pub fn nth344(mut self, v: BlsPubkey) -> Self {
        self.0[344] = v;
        self
    }
    pub fn nth345(mut self, v: BlsPubkey) -> Self {
        self.0[345] = v;
        self
    }
    pub fn nth346(mut self, v: BlsPubkey) -> Self {
        self.0[346] = v;
        self
    }
    pub fn nth347(mut self, v: BlsPubkey) -> Self {
        self.0[347] = v;
        self
    }
    pub fn nth348(mut self, v: BlsPubkey) -> Self {
        self.0[348] = v;
        self
    }
    pub fn nth349(mut self, v: BlsPubkey) -> Self {
        self.0[349] = v;
        self
    }
    pub fn nth350(mut self, v: BlsPubkey) -> Self {
        self.0[350] = v;
        self
    }
    pub fn nth351(mut self, v: BlsPubkey) -> Self {
        self.0[351] = v;
        self
    }
    pub fn nth352(mut self, v: BlsPubkey) -> Self {
        self.0[352] = v;
        self
    }
    pub fn nth353(mut self, v: BlsPubkey) -> Self {
        self.0[353] = v;
        self
    }
    pub fn nth354(mut self, v: BlsPubkey) -> Self {
        self.0[354] = v;
        self
    }
    pub fn nth355(mut self, v: BlsPubkey) -> Self {
        self.0[355] = v;
        self
    }
    pub fn nth356(mut self, v: BlsPubkey) -> Self {
        self.0[356] = v;
        self
    }
    pub fn nth357(mut self, v: BlsPubkey) -> Self {
        self.0[357] = v;
        self
    }
    pub fn nth358(mut self, v: BlsPubkey) -> Self {
        self.0[358] = v;
        self
    }
    pub fn nth359(mut self, v: BlsPubkey) -> Self {
        self.0[359] = v;
        self
    }
    pub fn nth360(mut self, v: BlsPubkey) -> Self {
        self.0[360] = v;
        self
    }
    pub fn nth361(mut self, v: BlsPubkey) -> Self {
        self.0[361] = v;
        self
    }
    pub fn nth362(mut self, v: BlsPubkey) -> Self {
        self.0[362] = v;
        self
    }
    pub fn nth363(mut self, v: BlsPubkey) -> Self {
        self.0[363] = v;
        self
    }
    pub fn nth364(mut self, v: BlsPubkey) -> Self {
        self.0[364] = v;
        self
    }
    pub fn nth365(mut self, v: BlsPubkey) -> Self {
        self.0[365] = v;
        self
    }
    pub fn nth366(mut self, v: BlsPubkey) -> Self {
        self.0[366] = v;
        self
    }
    pub fn nth367(mut self, v: BlsPubkey) -> Self {
        self.0[367] = v;
        self
    }
    pub fn nth368(mut self, v: BlsPubkey) -> Self {
        self.0[368] = v;
        self
    }
    pub fn nth369(mut self, v: BlsPubkey) -> Self {
        self.0[369] = v;
        self
    }
    pub fn nth370(mut self, v: BlsPubkey) -> Self {
        self.0[370] = v;
        self
    }
    pub fn nth371(mut self, v: BlsPubkey) -> Self {
        self.0[371] = v;
        self
    }
    pub fn nth372(mut self, v: BlsPubkey) -> Self {
        self.0[372] = v;
        self
    }
    pub fn nth373(mut self, v: BlsPubkey) -> Self {
        self.0[373] = v;
        self
    }
    pub fn nth374(mut self, v: BlsPubkey) -> Self {
        self.0[374] = v;
        self
    }
    pub fn nth375(mut self, v: BlsPubkey) -> Self {
        self.0[375] = v;
        self
    }
    pub fn nth376(mut self, v: BlsPubkey) -> Self {
        self.0[376] = v;
        self
    }
    pub fn nth377(mut self, v: BlsPubkey) -> Self {
        self.0[377] = v;
        self
    }
    pub fn nth378(mut self, v: BlsPubkey) -> Self {
        self.0[378] = v;
        self
    }
    pub fn nth379(mut self, v: BlsPubkey) -> Self {
        self.0[379] = v;
        self
    }
    pub fn nth380(mut self, v: BlsPubkey) -> Self {
        self.0[380] = v;
        self
    }
    pub fn nth381(mut self, v: BlsPubkey) -> Self {
        self.0[381] = v;
        self
    }
    pub fn nth382(mut self, v: BlsPubkey) -> Self {
        self.0[382] = v;
        self
    }
    pub fn nth383(mut self, v: BlsPubkey) -> Self {
        self.0[383] = v;
        self
    }
    pub fn nth384(mut self, v: BlsPubkey) -> Self {
        self.0[384] = v;
        self
    }
    pub fn nth385(mut self, v: BlsPubkey) -> Self {
        self.0[385] = v;
        self
    }
    pub fn nth386(mut self, v: BlsPubkey) -> Self {
        self.0[386] = v;
        self
    }
    pub fn nth387(mut self, v: BlsPubkey) -> Self {
        self.0[387] = v;
        self
    }
    pub fn nth388(mut self, v: BlsPubkey) -> Self {
        self.0[388] = v;
        self
    }
    pub fn nth389(mut self, v: BlsPubkey) -> Self {
        self.0[389] = v;
        self
    }
    pub fn nth390(mut self, v: BlsPubkey) -> Self {
        self.0[390] = v;
        self
    }
    pub fn nth391(mut self, v: BlsPubkey) -> Self {
        self.0[391] = v;
        self
    }
    pub fn nth392(mut self, v: BlsPubkey) -> Self {
        self.0[392] = v;
        self
    }
    pub fn nth393(mut self, v: BlsPubkey) -> Self {
        self.0[393] = v;
        self
    }
    pub fn nth394(mut self, v: BlsPubkey) -> Self {
        self.0[394] = v;
        self
    }
    pub fn nth395(mut self, v: BlsPubkey) -> Self {
        self.0[395] = v;
        self
    }
    pub fn nth396(mut self, v: BlsPubkey) -> Self {
        self.0[396] = v;
        self
    }
    pub fn nth397(mut self, v: BlsPubkey) -> Self {
        self.0[397] = v;
        self
    }
    pub fn nth398(mut self, v: BlsPubkey) -> Self {
        self.0[398] = v;
        self
    }
    pub fn nth399(mut self, v: BlsPubkey) -> Self {
        self.0[399] = v;
        self
    }
    pub fn nth400(mut self, v: BlsPubkey) -> Self {
        self.0[400] = v;
        self
    }
    pub fn nth401(mut self, v: BlsPubkey) -> Self {
        self.0[401] = v;
        self
    }
    pub fn nth402(mut self, v: BlsPubkey) -> Self {
        self.0[402] = v;
        self
    }
    pub fn nth403(mut self, v: BlsPubkey) -> Self {
        self.0[403] = v;
        self
    }
    pub fn nth404(mut self, v: BlsPubkey) -> Self {
        self.0[404] = v;
        self
    }
    pub fn nth405(mut self, v: BlsPubkey) -> Self {
        self.0[405] = v;
        self
    }
    pub fn nth406(mut self, v: BlsPubkey) -> Self {
        self.0[406] = v;
        self
    }
    pub fn nth407(mut self, v: BlsPubkey) -> Self {
        self.0[407] = v;
        self
    }
    pub fn nth408(mut self, v: BlsPubkey) -> Self {
        self.0[408] = v;
        self
    }
    pub fn nth409(mut self, v: BlsPubkey) -> Self {
        self.0[409] = v;
        self
    }
    pub fn nth410(mut self, v: BlsPubkey) -> Self {
        self.0[410] = v;
        self
    }
    pub fn nth411(mut self, v: BlsPubkey) -> Self {
        self.0[411] = v;
        self
    }
    pub fn nth412(mut self, v: BlsPubkey) -> Self {
        self.0[412] = v;
        self
    }
    pub fn nth413(mut self, v: BlsPubkey) -> Self {
        self.0[413] = v;
        self
    }
    pub fn nth414(mut self, v: BlsPubkey) -> Self {
        self.0[414] = v;
        self
    }
    pub fn nth415(mut self, v: BlsPubkey) -> Self {
        self.0[415] = v;
        self
    }
    pub fn nth416(mut self, v: BlsPubkey) -> Self {
        self.0[416] = v;
        self
    }
    pub fn nth417(mut self, v: BlsPubkey) -> Self {
        self.0[417] = v;
        self
    }
    pub fn nth418(mut self, v: BlsPubkey) -> Self {
        self.0[418] = v;
        self
    }
    pub fn nth419(mut self, v: BlsPubkey) -> Self {
        self.0[419] = v;
        self
    }
    pub fn nth420(mut self, v: BlsPubkey) -> Self {
        self.0[420] = v;
        self
    }
    pub fn nth421(mut self, v: BlsPubkey) -> Self {
        self.0[421] = v;
        self
    }
    pub fn nth422(mut self, v: BlsPubkey) -> Self {
        self.0[422] = v;
        self
    }
    pub fn nth423(mut self, v: BlsPubkey) -> Self {
        self.0[423] = v;
        self
    }
    pub fn nth424(mut self, v: BlsPubkey) -> Self {
        self.0[424] = v;
        self
    }
    pub fn nth425(mut self, v: BlsPubkey) -> Self {
        self.0[425] = v;
        self
    }
    pub fn nth426(mut self, v: BlsPubkey) -> Self {
        self.0[426] = v;
        self
    }
    pub fn nth427(mut self, v: BlsPubkey) -> Self {
        self.0[427] = v;
        self
    }
    pub fn nth428(mut self, v: BlsPubkey) -> Self {
        self.0[428] = v;
        self
    }
    pub fn nth429(mut self, v: BlsPubkey) -> Self {
        self.0[429] = v;
        self
    }
    pub fn nth430(mut self, v: BlsPubkey) -> Self {
        self.0[430] = v;
        self
    }
    pub fn nth431(mut self, v: BlsPubkey) -> Self {
        self.0[431] = v;
        self
    }
    pub fn nth432(mut self, v: BlsPubkey) -> Self {
        self.0[432] = v;
        self
    }
    pub fn nth433(mut self, v: BlsPubkey) -> Self {
        self.0[433] = v;
        self
    }
    pub fn nth434(mut self, v: BlsPubkey) -> Self {
        self.0[434] = v;
        self
    }
    pub fn nth435(mut self, v: BlsPubkey) -> Self {
        self.0[435] = v;
        self
    }
    pub fn nth436(mut self, v: BlsPubkey) -> Self {
        self.0[436] = v;
        self
    }
    pub fn nth437(mut self, v: BlsPubkey) -> Self {
        self.0[437] = v;
        self
    }
    pub fn nth438(mut self, v: BlsPubkey) -> Self {
        self.0[438] = v;
        self
    }
    pub fn nth439(mut self, v: BlsPubkey) -> Self {
        self.0[439] = v;
        self
    }
    pub fn nth440(mut self, v: BlsPubkey) -> Self {
        self.0[440] = v;
        self
    }
    pub fn nth441(mut self, v: BlsPubkey) -> Self {
        self.0[441] = v;
        self
    }
    pub fn nth442(mut self, v: BlsPubkey) -> Self {
        self.0[442] = v;
        self
    }
    pub fn nth443(mut self, v: BlsPubkey) -> Self {
        self.0[443] = v;
        self
    }
    pub fn nth444(mut self, v: BlsPubkey) -> Self {
        self.0[444] = v;
        self
    }
    pub fn nth445(mut self, v: BlsPubkey) -> Self {
        self.0[445] = v;
        self
    }
    pub fn nth446(mut self, v: BlsPubkey) -> Self {
        self.0[446] = v;
        self
    }
    pub fn nth447(mut self, v: BlsPubkey) -> Self {
        self.0[447] = v;
        self
    }
    pub fn nth448(mut self, v: BlsPubkey) -> Self {
        self.0[448] = v;
        self
    }
    pub fn nth449(mut self, v: BlsPubkey) -> Self {
        self.0[449] = v;
        self
    }
    pub fn nth450(mut self, v: BlsPubkey) -> Self {
        self.0[450] = v;
        self
    }
    pub fn nth451(mut self, v: BlsPubkey) -> Self {
        self.0[451] = v;
        self
    }
    pub fn nth452(mut self, v: BlsPubkey) -> Self {
        self.0[452] = v;
        self
    }
    pub fn nth453(mut self, v: BlsPubkey) -> Self {
        self.0[453] = v;
        self
    }
    pub fn nth454(mut self, v: BlsPubkey) -> Self {
        self.0[454] = v;
        self
    }
    pub fn nth455(mut self, v: BlsPubkey) -> Self {
        self.0[455] = v;
        self
    }
    pub fn nth456(mut self, v: BlsPubkey) -> Self {
        self.0[456] = v;
        self
    }
    pub fn nth457(mut self, v: BlsPubkey) -> Self {
        self.0[457] = v;
        self
    }
    pub fn nth458(mut self, v: BlsPubkey) -> Self {
        self.0[458] = v;
        self
    }
    pub fn nth459(mut self, v: BlsPubkey) -> Self {
        self.0[459] = v;
        self
    }
    pub fn nth460(mut self, v: BlsPubkey) -> Self {
        self.0[460] = v;
        self
    }
    pub fn nth461(mut self, v: BlsPubkey) -> Self {
        self.0[461] = v;
        self
    }
    pub fn nth462(mut self, v: BlsPubkey) -> Self {
        self.0[462] = v;
        self
    }
    pub fn nth463(mut self, v: BlsPubkey) -> Self {
        self.0[463] = v;
        self
    }
    pub fn nth464(mut self, v: BlsPubkey) -> Self {
        self.0[464] = v;
        self
    }
    pub fn nth465(mut self, v: BlsPubkey) -> Self {
        self.0[465] = v;
        self
    }
    pub fn nth466(mut self, v: BlsPubkey) -> Self {
        self.0[466] = v;
        self
    }
    pub fn nth467(mut self, v: BlsPubkey) -> Self {
        self.0[467] = v;
        self
    }
    pub fn nth468(mut self, v: BlsPubkey) -> Self {
        self.0[468] = v;
        self
    }
    pub fn nth469(mut self, v: BlsPubkey) -> Self {
        self.0[469] = v;
        self
    }
    pub fn nth470(mut self, v: BlsPubkey) -> Self {
        self.0[470] = v;
        self
    }
    pub fn nth471(mut self, v: BlsPubkey) -> Self {
        self.0[471] = v;
        self
    }
    pub fn nth472(mut self, v: BlsPubkey) -> Self {
        self.0[472] = v;
        self
    }
    pub fn nth473(mut self, v: BlsPubkey) -> Self {
        self.0[473] = v;
        self
    }
    pub fn nth474(mut self, v: BlsPubkey) -> Self {
        self.0[474] = v;
        self
    }
    pub fn nth475(mut self, v: BlsPubkey) -> Self {
        self.0[475] = v;
        self
    }
    pub fn nth476(mut self, v: BlsPubkey) -> Self {
        self.0[476] = v;
        self
    }
    pub fn nth477(mut self, v: BlsPubkey) -> Self {
        self.0[477] = v;
        self
    }
    pub fn nth478(mut self, v: BlsPubkey) -> Self {
        self.0[478] = v;
        self
    }
    pub fn nth479(mut self, v: BlsPubkey) -> Self {
        self.0[479] = v;
        self
    }
    pub fn nth480(mut self, v: BlsPubkey) -> Self {
        self.0[480] = v;
        self
    }
    pub fn nth481(mut self, v: BlsPubkey) -> Self {
        self.0[481] = v;
        self
    }
    pub fn nth482(mut self, v: BlsPubkey) -> Self {
        self.0[482] = v;
        self
    }
    pub fn nth483(mut self, v: BlsPubkey) -> Self {
        self.0[483] = v;
        self
    }
    pub fn nth484(mut self, v: BlsPubkey) -> Self {
        self.0[484] = v;
        self
    }
    pub fn nth485(mut self, v: BlsPubkey) -> Self {
        self.0[485] = v;
        self
    }
    pub fn nth486(mut self, v: BlsPubkey) -> Self {
        self.0[486] = v;
        self
    }
    pub fn nth487(mut self, v: BlsPubkey) -> Self {
        self.0[487] = v;
        self
    }
    pub fn nth488(mut self, v: BlsPubkey) -> Self {
        self.0[488] = v;
        self
    }
    pub fn nth489(mut self, v: BlsPubkey) -> Self {
        self.0[489] = v;
        self
    }
    pub fn nth490(mut self, v: BlsPubkey) -> Self {
        self.0[490] = v;
        self
    }
    pub fn nth491(mut self, v: BlsPubkey) -> Self {
        self.0[491] = v;
        self
    }
    pub fn nth492(mut self, v: BlsPubkey) -> Self {
        self.0[492] = v;
        self
    }
    pub fn nth493(mut self, v: BlsPubkey) -> Self {
        self.0[493] = v;
        self
    }
    pub fn nth494(mut self, v: BlsPubkey) -> Self {
        self.0[494] = v;
        self
    }
    pub fn nth495(mut self, v: BlsPubkey) -> Self {
        self.0[495] = v;
        self
    }
    pub fn nth496(mut self, v: BlsPubkey) -> Self {
        self.0[496] = v;
        self
    }
    pub fn nth497(mut self, v: BlsPubkey) -> Self {
        self.0[497] = v;
        self
    }
    pub fn nth498(mut self, v: BlsPubkey) -> Self {
        self.0[498] = v;
        self
    }
    pub fn nth499(mut self, v: BlsPubkey) -> Self {
        self.0[499] = v;
        self
    }
    pub fn nth500(mut self, v: BlsPubkey) -> Self {
        self.0[500] = v;
        self
    }
    pub fn nth501(mut self, v: BlsPubkey) -> Self {
        self.0[501] = v;
        self
    }
    pub fn nth502(mut self, v: BlsPubkey) -> Self {
        self.0[502] = v;
        self
    }
    pub fn nth503(mut self, v: BlsPubkey) -> Self {
        self.0[503] = v;
        self
    }
    pub fn nth504(mut self, v: BlsPubkey) -> Self {
        self.0[504] = v;
        self
    }
    pub fn nth505(mut self, v: BlsPubkey) -> Self {
        self.0[505] = v;
        self
    }
    pub fn nth506(mut self, v: BlsPubkey) -> Self {
        self.0[506] = v;
        self
    }
    pub fn nth507(mut self, v: BlsPubkey) -> Self {
        self.0[507] = v;
        self
    }
    pub fn nth508(mut self, v: BlsPubkey) -> Self {
        self.0[508] = v;
        self
    }
    pub fn nth509(mut self, v: BlsPubkey) -> Self {
        self.0[509] = v;
        self
    }
    pub fn nth510(mut self, v: BlsPubkey) -> Self {
        self.0[510] = v;
        self
    }
    pub fn nth511(mut self, v: BlsPubkey) -> Self {
        self.0[511] = v;
        self
    }
}
impl molecule::prelude::Builder for BlsPubkeyArrayBuilder {
    type Entity = BlsPubkeyArray;
    const NAME: &'static str = "BlsPubkeyArrayBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.0[0].as_slice())?;
        writer.write_all(self.0[1].as_slice())?;
        writer.write_all(self.0[2].as_slice())?;
        writer.write_all(self.0[3].as_slice())?;
        writer.write_all(self.0[4].as_slice())?;
        writer.write_all(self.0[5].as_slice())?;
        writer.write_all(self.0[6].as_slice())?;
        writer.write_all(self.0[7].as_slice())?;
        writer.write_all(self.0[8].as_slice())?;
        writer.write_all(self.0[9].as_slice())?;
        writer.write_all(self.0[10].as_slice())?;
        writer.write_all(self.0[11].as_slice())?;
        writer.write_all(self.0[12].as_slice())?;
        writer.write_all(self.0[13].as_slice())?;
        writer.write_all(self.0[14].as_slice())?;
        writer.write_all(self.0[15].as_slice())?;
        writer.write_all(self.0[16].as_slice())?;
        writer.write_all(self.0[17].as_slice())?;
        writer.write_all(self.0[18].as_slice())?;
        writer.write_all(self.0[19].as_slice())?;
        writer.write_all(self.0[20].as_slice())?;
        writer.write_all(self.0[21].as_slice())?;
        writer.write_all(self.0[22].as_slice())?;
        writer.write_all(self.0[23].as_slice())?;
        writer.write_all(self.0[24].as_slice())?;
        writer.write_all(self.0[25].as_slice())?;
        writer.write_all(self.0[26].as_slice())?;
        writer.write_all(self.0[27].as_slice())?;
        writer.write_all(self.0[28].as_slice())?;
        writer.write_all(self.0[29].as_slice())?;
        writer.write_all(self.0[30].as_slice())?;
        writer.write_all(self.0[31].as_slice())?;
        writer.write_all(self.0[32].as_slice())?;
        writer.write_all(self.0[33].as_slice())?;
        writer.write_all(self.0[34].as_slice())?;
        writer.write_all(self.0[35].as_slice())?;
        writer.write_all(self.0[36].as_slice())?;
        writer.write_all(self.0[37].as_slice())?;
        writer.write_all(self.0[38].as_slice())?;
        writer.write_all(self.0[39].as_slice())?;
        writer.write_all(self.0[40].as_slice())?;
        writer.write_all(self.0[41].as_slice())?;
        writer.write_all(self.0[42].as_slice())?;
        writer.write_all(self.0[43].as_slice())?;
        writer.write_all(self.0[44].as_slice())?;
        writer.write_all(self.0[45].as_slice())?;
        writer.write_all(self.0[46].as_slice())?;
        writer.write_all(self.0[47].as_slice())?;
        writer.write_all(self.0[48].as_slice())?;
        writer.write_all(self.0[49].as_slice())?;
        writer.write_all(self.0[50].as_slice())?;
        writer.write_all(self.0[51].as_slice())?;
        writer.write_all(self.0[52].as_slice())?;
        writer.write_all(self.0[53].as_slice())?;
        writer.write_all(self.0[54].as_slice())?;
        writer.write_all(self.0[55].as_slice())?;
        writer.write_all(self.0[56].as_slice())?;
        writer.write_all(self.0[57].as_slice())?;
        writer.write_all(self.0[58].as_slice())?;
        writer.write_all(self.0[59].as_slice())?;
        writer.write_all(self.0[60].as_slice())?;
        writer.write_all(self.0[61].as_slice())?;
        writer.write_all(self.0[62].as_slice())?;
        writer.write_all(self.0[63].as_slice())?;
        writer.write_all(self.0[64].as_slice())?;
        writer.write_all(self.0[65].as_slice())?;
        writer.write_all(self.0[66].as_slice())?;
        writer.write_all(self.0[67].as_slice())?;
        writer.write_all(self.0[68].as_slice())?;
        writer.write_all(self.0[69].as_slice())?;
        writer.write_all(self.0[70].as_slice())?;
        writer.write_all(self.0[71].as_slice())?;
        writer.write_all(self.0[72].as_slice())?;
        writer.write_all(self.0[73].as_slice())?;
        writer.write_all(self.0[74].as_slice())?;
        writer.write_all(self.0[75].as_slice())?;
        writer.write_all(self.0[76].as_slice())?;
        writer.write_all(self.0[77].as_slice())?;
        writer.write_all(self.0[78].as_slice())?;
        writer.write_all(self.0[79].as_slice())?;
        writer.write_all(self.0[80].as_slice())?;
        writer.write_all(self.0[81].as_slice())?;
        writer.write_all(self.0[82].as_slice())?;
        writer.write_all(self.0[83].as_slice())?;
        writer.write_all(self.0[84].as_slice())?;
        writer.write_all(self.0[85].as_slice())?;
        writer.write_all(self.0[86].as_slice())?;
        writer.write_all(self.0[87].as_slice())?;
        writer.write_all(self.0[88].as_slice())?;
        writer.write_all(self.0[89].as_slice())?;
        writer.write_all(self.0[90].as_slice())?;
        writer.write_all(self.0[91].as_slice())?;
        writer.write_all(self.0[92].as_slice())?;
        writer.write_all(self.0[93].as_slice())?;
        writer.write_all(self.0[94].as_slice())?;
        writer.write_all(self.0[95].as_slice())?;
        writer.write_all(self.0[96].as_slice())?;
        writer.write_all(self.0[97].as_slice())?;
        writer.write_all(self.0[98].as_slice())?;
        writer.write_all(self.0[99].as_slice())?;
        writer.write_all(self.0[100].as_slice())?;
        writer.write_all(self.0[101].as_slice())?;
        writer.write_all(self.0[102].as_slice())?;
        writer.write_all(self.0[103].as_slice())?;
        writer.write_all(self.0[104].as_slice())?;
        writer.write_all(self.0[105].as_slice())?;
        writer.write_all(self.0[106].as_slice())?;
        writer.write_all(self.0[107].as_slice())?;
        writer.write_all(self.0[108].as_slice())?;
        writer.write_all(self.0[109].as_slice())?;
        writer.write_all(self.0[110].as_slice())?;
        writer.write_all(self.0[111].as_slice())?;
        writer.write_all(self.0[112].as_slice())?;
        writer.write_all(self.0[113].as_slice())?;
        writer.write_all(self.0[114].as_slice())?;
        writer.write_all(self.0[115].as_slice())?;
        writer.write_all(self.0[116].as_slice())?;
        writer.write_all(self.0[117].as_slice())?;
        writer.write_all(self.0[118].as_slice())?;
        writer.write_all(self.0[119].as_slice())?;
        writer.write_all(self.0[120].as_slice())?;
        writer.write_all(self.0[121].as_slice())?;
        writer.write_all(self.0[122].as_slice())?;
        writer.write_all(self.0[123].as_slice())?;
        writer.write_all(self.0[124].as_slice())?;
        writer.write_all(self.0[125].as_slice())?;
        writer.write_all(self.0[126].as_slice())?;
        writer.write_all(self.0[127].as_slice())?;
        writer.write_all(self.0[128].as_slice())?;
        writer.write_all(self.0[129].as_slice())?;
        writer.write_all(self.0[130].as_slice())?;
        writer.write_all(self.0[131].as_slice())?;
        writer.write_all(self.0[132].as_slice())?;
        writer.write_all(self.0[133].as_slice())?;
        writer.write_all(self.0[134].as_slice())?;
        writer.write_all(self.0[135].as_slice())?;
        writer.write_all(self.0[136].as_slice())?;
        writer.write_all(self.0[137].as_slice())?;
        writer.write_all(self.0[138].as_slice())?;
        writer.write_all(self.0[139].as_slice())?;
        writer.write_all(self.0[140].as_slice())?;
        writer.write_all(self.0[141].as_slice())?;
        writer.write_all(self.0[142].as_slice())?;
        writer.write_all(self.0[143].as_slice())?;
        writer.write_all(self.0[144].as_slice())?;
        writer.write_all(self.0[145].as_slice())?;
        writer.write_all(self.0[146].as_slice())?;
        writer.write_all(self.0[147].as_slice())?;
        writer.write_all(self.0[148].as_slice())?;
        writer.write_all(self.0[149].as_slice())?;
        writer.write_all(self.0[150].as_slice())?;
        writer.write_all(self.0[151].as_slice())?;
        writer.write_all(self.0[152].as_slice())?;
        writer.write_all(self.0[153].as_slice())?;
        writer.write_all(self.0[154].as_slice())?;
        writer.write_all(self.0[155].as_slice())?;
        writer.write_all(self.0[156].as_slice())?;
        writer.write_all(self.0[157].as_slice())?;
        writer.write_all(self.0[158].as_slice())?;
        writer.write_all(self.0[159].as_slice())?;
        writer.write_all(self.0[160].as_slice())?;
        writer.write_all(self.0[161].as_slice())?;
        writer.write_all(self.0[162].as_slice())?;
        writer.write_all(self.0[163].as_slice())?;
        writer.write_all(self.0[164].as_slice())?;
        writer.write_all(self.0[165].as_slice())?;
        writer.write_all(self.0[166].as_slice())?;
        writer.write_all(self.0[167].as_slice())?;
        writer.write_all(self.0[168].as_slice())?;
        writer.write_all(self.0[169].as_slice())?;
        writer.write_all(self.0[170].as_slice())?;
        writer.write_all(self.0[171].as_slice())?;
        writer.write_all(self.0[172].as_slice())?;
        writer.write_all(self.0[173].as_slice())?;
        writer.write_all(self.0[174].as_slice())?;
        writer.write_all(self.0[175].as_slice())?;
        writer.write_all(self.0[176].as_slice())?;
        writer.write_all(self.0[177].as_slice())?;
        writer.write_all(self.0[178].as_slice())?;
        writer.write_all(self.0[179].as_slice())?;
        writer.write_all(self.0[180].as_slice())?;
        writer.write_all(self.0[181].as_slice())?;
        writer.write_all(self.0[182].as_slice())?;
        writer.write_all(self.0[183].as_slice())?;
        writer.write_all(self.0[184].as_slice())?;
        writer.write_all(self.0[185].as_slice())?;
        writer.write_all(self.0[186].as_slice())?;
        writer.write_all(self.0[187].as_slice())?;
        writer.write_all(self.0[188].as_slice())?;
        writer.write_all(self.0[189].as_slice())?;
        writer.write_all(self.0[190].as_slice())?;
        writer.write_all(self.0[191].as_slice())?;
        writer.write_all(self.0[192].as_slice())?;
        writer.write_all(self.0[193].as_slice())?;
        writer.write_all(self.0[194].as_slice())?;
        writer.write_all(self.0[195].as_slice())?;
        writer.write_all(self.0[196].as_slice())?;
        writer.write_all(self.0[197].as_slice())?;
        writer.write_all(self.0[198].as_slice())?;
        writer.write_all(self.0[199].as_slice())?;
        writer.write_all(self.0[200].as_slice())?;
        writer.write_all(self.0[201].as_slice())?;
        writer.write_all(self.0[202].as_slice())?;
        writer.write_all(self.0[203].as_slice())?;
        writer.write_all(self.0[204].as_slice())?;
        writer.write_all(self.0[205].as_slice())?;
        writer.write_all(self.0[206].as_slice())?;
        writer.write_all(self.0[207].as_slice())?;
        writer.write_all(self.0[208].as_slice())?;
        writer.write_all(self.0[209].as_slice())?;
        writer.write_all(self.0[210].as_slice())?;
        writer.write_all(self.0[211].as_slice())?;
        writer.write_all(self.0[212].as_slice())?;
        writer.write_all(self.0[213].as_slice())?;
        writer.write_all(self.0[214].as_slice())?;
        writer.write_all(self.0[215].as_slice())?;
        writer.write_all(self.0[216].as_slice())?;
        writer.write_all(self.0[217].as_slice())?;
        writer.write_all(self.0[218].as_slice())?;
        writer.write_all(self.0[219].as_slice())?;
        writer.write_all(self.0[220].as_slice())?;
        writer.write_all(self.0[221].as_slice())?;
        writer.write_all(self.0[222].as_slice())?;
        writer.write_all(self.0[223].as_slice())?;
        writer.write_all(self.0[224].as_slice())?;
        writer.write_all(self.0[225].as_slice())?;
        writer.write_all(self.0[226].as_slice())?;
        writer.write_all(self.0[227].as_slice())?;
        writer.write_all(self.0[228].as_slice())?;
        writer.write_all(self.0[229].as_slice())?;
        writer.write_all(self.0[230].as_slice())?;
        writer.write_all(self.0[231].as_slice())?;
        writer.write_all(self.0[232].as_slice())?;
        writer.write_all(self.0[233].as_slice())?;
        writer.write_all(self.0[234].as_slice())?;
        writer.write_all(self.0[235].as_slice())?;
        writer.write_all(self.0[236].as_slice())?;
        writer.write_all(self.0[237].as_slice())?;
        writer.write_all(self.0[238].as_slice())?;
        writer.write_all(self.0[239].as_slice())?;
        writer.write_all(self.0[240].as_slice())?;
        writer.write_all(self.0[241].as_slice())?;
        writer.write_all(self.0[242].as_slice())?;
        writer.write_all(self.0[243].as_slice())?;
        writer.write_all(self.0[244].as_slice())?;
        writer.write_all(self.0[245].as_slice())?;
        writer.write_all(self.0[246].as_slice())?;
        writer.write_all(self.0[247].as_slice())?;
        writer.write_all(self.0[248].as_slice())?;
        writer.write_all(self.0[249].as_slice())?;
        writer.write_all(self.0[250].as_slice())?;
        writer.write_all(self.0[251].as_slice())?;
        writer.write_all(self.0[252].as_slice())?;
        writer.write_all(self.0[253].as_slice())?;
        writer.write_all(self.0[254].as_slice())?;
        writer.write_all(self.0[255].as_slice())?;
        writer.write_all(self.0[256].as_slice())?;
        writer.write_all(self.0[257].as_slice())?;
        writer.write_all(self.0[258].as_slice())?;
        writer.write_all(self.0[259].as_slice())?;
        writer.write_all(self.0[260].as_slice())?;
        writer.write_all(self.0[261].as_slice())?;
        writer.write_all(self.0[262].as_slice())?;
        writer.write_all(self.0[263].as_slice())?;
        writer.write_all(self.0[264].as_slice())?;
        writer.write_all(self.0[265].as_slice())?;
        writer.write_all(self.0[266].as_slice())?;
        writer.write_all(self.0[267].as_slice())?;
        writer.write_all(self.0[268].as_slice())?;
        writer.write_all(self.0[269].as_slice())?;
        writer.write_all(self.0[270].as_slice())?;
        writer.write_all(self.0[271].as_slice())?;
        writer.write_all(self.0[272].as_slice())?;
        writer.write_all(self.0[273].as_slice())?;
        writer.write_all(self.0[274].as_slice())?;
        writer.write_all(self.0[275].as_slice())?;
        writer.write_all(self.0[276].as_slice())?;
        writer.write_all(self.0[277].as_slice())?;
        writer.write_all(self.0[278].as_slice())?;
        writer.write_all(self.0[279].as_slice())?;
        writer.write_all(self.0[280].as_slice())?;
        writer.write_all(self.0[281].as_slice())?;
        writer.write_all(self.0[282].as_slice())?;
        writer.write_all(self.0[283].as_slice())?;
        writer.write_all(self.0[284].as_slice())?;
        writer.write_all(self.0[285].as_slice())?;
        writer.write_all(self.0[286].as_slice())?;
        writer.write_all(self.0[287].as_slice())?;
        writer.write_all(self.0[288].as_slice())?;
        writer.write_all(self.0[289].as_slice())?;
        writer.write_all(self.0[290].as_slice())?;
        writer.write_all(self.0[291].as_slice())?;
        writer.write_all(self.0[292].as_slice())?;
        writer.write_all(self.0[293].as_slice())?;
        writer.write_all(self.0[294].as_slice())?;
        writer.write_all(self.0[295].as_slice())?;
        writer.write_all(self.0[296].as_slice())?;
        writer.write_all(self.0[297].as_slice())?;
        writer.write_all(self.0[298].as_slice())?;
        writer.write_all(self.0[299].as_slice())?;
        writer.write_all(self.0[300].as_slice())?;
        writer.write_all(self.0[301].as_slice())?;
        writer.write_all(self.0[302].as_slice())?;
        writer.write_all(self.0[303].as_slice())?;
        writer.write_all(self.0[304].as_slice())?;
        writer.write_all(self.0[305].as_slice())?;
        writer.write_all(self.0[306].as_slice())?;
        writer.write_all(self.0[307].as_slice())?;
        writer.write_all(self.0[308].as_slice())?;
        writer.write_all(self.0[309].as_slice())?;
        writer.write_all(self.0[310].as_slice())?;
        writer.write_all(self.0[311].as_slice())?;
        writer.write_all(self.0[312].as_slice())?;
        writer.write_all(self.0[313].as_slice())?;
        writer.write_all(self.0[314].as_slice())?;
        writer.write_all(self.0[315].as_slice())?;
        writer.write_all(self.0[316].as_slice())?;
        writer.write_all(self.0[317].as_slice())?;
        writer.write_all(self.0[318].as_slice())?;
        writer.write_all(self.0[319].as_slice())?;
        writer.write_all(self.0[320].as_slice())?;
        writer.write_all(self.0[321].as_slice())?;
        writer.write_all(self.0[322].as_slice())?;
        writer.write_all(self.0[323].as_slice())?;
        writer.write_all(self.0[324].as_slice())?;
        writer.write_all(self.0[325].as_slice())?;
        writer.write_all(self.0[326].as_slice())?;
        writer.write_all(self.0[327].as_slice())?;
        writer.write_all(self.0[328].as_slice())?;
        writer.write_all(self.0[329].as_slice())?;
        writer.write_all(self.0[330].as_slice())?;
        writer.write_all(self.0[331].as_slice())?;
        writer.write_all(self.0[332].as_slice())?;
        writer.write_all(self.0[333].as_slice())?;
        writer.write_all(self.0[334].as_slice())?;
        writer.write_all(self.0[335].as_slice())?;
        writer.write_all(self.0[336].as_slice())?;
        writer.write_all(self.0[337].as_slice())?;
        writer.write_all(self.0[338].as_slice())?;
        writer.write_all(self.0[339].as_slice())?;
        writer.write_all(self.0[340].as_slice())?;
        writer.write_all(self.0[341].as_slice())?;
        writer.write_all(self.0[342].as_slice())?;
        writer.write_all(self.0[343].as_slice())?;
        writer.write_all(self.0[344].as_slice())?;
        writer.write_all(self.0[345].as_slice())?;
        writer.write_all(self.0[346].as_slice())?;
        writer.write_all(self.0[347].as_slice())?;
        writer.write_all(self.0[348].as_slice())?;
        writer.write_all(self.0[349].as_slice())?;
        writer.write_all(self.0[350].as_slice())?;
        writer.write_all(self.0[351].as_slice())?;
        writer.write_all(self.0[352].as_slice())?;
        writer.write_all(self.0[353].as_slice())?;
        writer.write_all(self.0[354].as_slice())?;
        writer.write_all(self.0[355].as_slice())?;
        writer.write_all(self.0[356].as_slice())?;
        writer.write_all(self.0[357].as_slice())?;
        writer.write_all(self.0[358].as_slice())?;
        writer.write_all(self.0[359].as_slice())?;
        writer.write_all(self.0[360].as_slice())?;
        writer.write_all(self.0[361].as_slice())?;
        writer.write_all(self.0[362].as_slice())?;
        writer.write_all(self.0[363].as_slice())?;
        writer.write_all(self.0[364].as_slice())?;
        writer.write_all(self.0[365].as_slice())?;
        writer.write_all(self.0[366].as_slice())?;
        writer.write_all(self.0[367].as_slice())?;
        writer.write_all(self.0[368].as_slice())?;
        writer.write_all(self.0[369].as_slice())?;
        writer.write_all(self.0[370].as_slice())?;
        writer.write_all(self.0[371].as_slice())?;
        writer.write_all(self.0[372].as_slice())?;
        writer.write_all(self.0[373].as_slice())?;
        writer.write_all(self.0[374].as_slice())?;
        writer.write_all(self.0[375].as_slice())?;
        writer.write_all(self.0[376].as_slice())?;
        writer.write_all(self.0[377].as_slice())?;
        writer.write_all(self.0[378].as_slice())?;
        writer.write_all(self.0[379].as_slice())?;
        writer.write_all(self.0[380].as_slice())?;
        writer.write_all(self.0[381].as_slice())?;
        writer.write_all(self.0[382].as_slice())?;
        writer.write_all(self.0[383].as_slice())?;
        writer.write_all(self.0[384].as_slice())?;
        writer.write_all(self.0[385].as_slice())?;
        writer.write_all(self.0[386].as_slice())?;
        writer.write_all(self.0[387].as_slice())?;
        writer.write_all(self.0[388].as_slice())?;
        writer.write_all(self.0[389].as_slice())?;
        writer.write_all(self.0[390].as_slice())?;
        writer.write_all(self.0[391].as_slice())?;
        writer.write_all(self.0[392].as_slice())?;
        writer.write_all(self.0[393].as_slice())?;
        writer.write_all(self.0[394].as_slice())?;
        writer.write_all(self.0[395].as_slice())?;
        writer.write_all(self.0[396].as_slice())?;
        writer.write_all(self.0[397].as_slice())?;
        writer.write_all(self.0[398].as_slice())?;
        writer.write_all(self.0[399].as_slice())?;
        writer.write_all(self.0[400].as_slice())?;
        writer.write_all(self.0[401].as_slice())?;
        writer.write_all(self.0[402].as_slice())?;
        writer.write_all(self.0[403].as_slice())?;
        writer.write_all(self.0[404].as_slice())?;
        writer.write_all(self.0[405].as_slice())?;
        writer.write_all(self.0[406].as_slice())?;
        writer.write_all(self.0[407].as_slice())?;
        writer.write_all(self.0[408].as_slice())?;
        writer.write_all(self.0[409].as_slice())?;
        writer.write_all(self.0[410].as_slice())?;
        writer.write_all(self.0[411].as_slice())?;
        writer.write_all(self.0[412].as_slice())?;
        writer.write_all(self.0[413].as_slice())?;
        writer.write_all(self.0[414].as_slice())?;
        writer.write_all(self.0[415].as_slice())?;
        writer.write_all(self.0[416].as_slice())?;
        writer.write_all(self.0[417].as_slice())?;
        writer.write_all(self.0[418].as_slice())?;
        writer.write_all(self.0[419].as_slice())?;
        writer.write_all(self.0[420].as_slice())?;
        writer.write_all(self.0[421].as_slice())?;
        writer.write_all(self.0[422].as_slice())?;
        writer.write_all(self.0[423].as_slice())?;
        writer.write_all(self.0[424].as_slice())?;
        writer.write_all(self.0[425].as_slice())?;
        writer.write_all(self.0[426].as_slice())?;
        writer.write_all(self.0[427].as_slice())?;
        writer.write_all(self.0[428].as_slice())?;
        writer.write_all(self.0[429].as_slice())?;
        writer.write_all(self.0[430].as_slice())?;
        writer.write_all(self.0[431].as_slice())?;
        writer.write_all(self.0[432].as_slice())?;
        writer.write_all(self.0[433].as_slice())?;
        writer.write_all(self.0[434].as_slice())?;
        writer.write_all(self.0[435].as_slice())?;
        writer.write_all(self.0[436].as_slice())?;
        writer.write_all(self.0[437].as_slice())?;
        writer.write_all(self.0[438].as_slice())?;
        writer.write_all(self.0[439].as_slice())?;
        writer.write_all(self.0[440].as_slice())?;
        writer.write_all(self.0[441].as_slice())?;
        writer.write_all(self.0[442].as_slice())?;
        writer.write_all(self.0[443].as_slice())?;
        writer.write_all(self.0[444].as_slice())?;
        writer.write_all(self.0[445].as_slice())?;
        writer.write_all(self.0[446].as_slice())?;
        writer.write_all(self.0[447].as_slice())?;
        writer.write_all(self.0[448].as_slice())?;
        writer.write_all(self.0[449].as_slice())?;
        writer.write_all(self.0[450].as_slice())?;
        writer.write_all(self.0[451].as_slice())?;
        writer.write_all(self.0[452].as_slice())?;
        writer.write_all(self.0[453].as_slice())?;
        writer.write_all(self.0[454].as_slice())?;
        writer.write_all(self.0[455].as_slice())?;
        writer.write_all(self.0[456].as_slice())?;
        writer.write_all(self.0[457].as_slice())?;
        writer.write_all(self.0[458].as_slice())?;
        writer.write_all(self.0[459].as_slice())?;
        writer.write_all(self.0[460].as_slice())?;
        writer.write_all(self.0[461].as_slice())?;
        writer.write_all(self.0[462].as_slice())?;
        writer.write_all(self.0[463].as_slice())?;
        writer.write_all(self.0[464].as_slice())?;
        writer.write_all(self.0[465].as_slice())?;
        writer.write_all(self.0[466].as_slice())?;
        writer.write_all(self.0[467].as_slice())?;
        writer.write_all(self.0[468].as_slice())?;
        writer.write_all(self.0[469].as_slice())?;
        writer.write_all(self.0[470].as_slice())?;
        writer.write_all(self.0[471].as_slice())?;
        writer.write_all(self.0[472].as_slice())?;
        writer.write_all(self.0[473].as_slice())?;
        writer.write_all(self.0[474].as_slice())?;
        writer.write_all(self.0[475].as_slice())?;
        writer.write_all(self.0[476].as_slice())?;
        writer.write_all(self.0[477].as_slice())?;
        writer.write_all(self.0[478].as_slice())?;
        writer.write_all(self.0[479].as_slice())?;
        writer.write_all(self.0[480].as_slice())?;
        writer.write_all(self.0[481].as_slice())?;
        writer.write_all(self.0[482].as_slice())?;
        writer.write_all(self.0[483].as_slice())?;
        writer.write_all(self.0[484].as_slice())?;
        writer.write_all(self.0[485].as_slice())?;
        writer.write_all(self.0[486].as_slice())?;
        writer.write_all(self.0[487].as_slice())?;
        writer.write_all(self.0[488].as_slice())?;
        writer.write_all(self.0[489].as_slice())?;
        writer.write_all(self.0[490].as_slice())?;
        writer.write_all(self.0[491].as_slice())?;
        writer.write_all(self.0[492].as_slice())?;
        writer.write_all(self.0[493].as_slice())?;
        writer.write_all(self.0[494].as_slice())?;
        writer.write_all(self.0[495].as_slice())?;
        writer.write_all(self.0[496].as_slice())?;
        writer.write_all(self.0[497].as_slice())?;
        writer.write_all(self.0[498].as_slice())?;
        writer.write_all(self.0[499].as_slice())?;
        writer.write_all(self.0[500].as_slice())?;
        writer.write_all(self.0[501].as_slice())?;
        writer.write_all(self.0[502].as_slice())?;
        writer.write_all(self.0[503].as_slice())?;
        writer.write_all(self.0[504].as_slice())?;
        writer.write_all(self.0[505].as_slice())?;
        writer.write_all(self.0[506].as_slice())?;
        writer.write_all(self.0[507].as_slice())?;
        writer.write_all(self.0[508].as_slice())?;
        writer.write_all(self.0[509].as_slice())?;
        writer.write_all(self.0[510].as_slice())?;
        writer.write_all(self.0[511].as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        BlsPubkeyArray::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct SszProof(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for SszProof {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for SszProof {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for SszProof {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl ::core::default::Default for SszProof {
    fn default() -> Self {
        let v: Vec<u8> = vec![0, 0, 0, 0];
        SszProof::new_unchecked(v.into())
    }
}
impl SszProof {
    pub const ITEM_SIZE: usize = 32;
    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()
    }
    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<Hash> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> Hash {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        Hash::new_unchecked(self.0.slice(start..end))
    }
    pub fn as_reader<'r>(&'r self) -> SszProofReader<'r> {
        SszProofReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for SszProof {
    type Builder = SszProofBuilder;
    const NAME: &'static str = "SszProof";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        SszProof(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SszProofReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SszProofReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct SszProofReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for SszProofReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for SszProofReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for SszProofReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> SszProofReader<'r> {
    pub const ITEM_SIZE: usize = 32;
    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()
    }
    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<HashReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> HashReader<'r> {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        HashReader::new_unchecked(&self.as_slice()[start..end])
    }
}
impl<'r> molecule::prelude::Reader<'r> for SszProofReader<'r> {
    type Entity = SszProof;
    const NAME: &'static str = "SszProofReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        SszProofReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_count = molecule::unpack_number(slice) as usize;
        if item_count == 0 {
            if slice_len != molecule::NUMBER_SIZE {
                return ve!(Self, TotalSizeNotMatch, molecule::NUMBER_SIZE, slice_len);
            }
            return Ok(());
        }
        let total_size = molecule::NUMBER_SIZE + Self::ITEM_SIZE * item_count;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct SszProofBuilder(pub(crate) Vec<Hash>);
impl SszProofBuilder {
    pub const ITEM_SIZE: usize = 32;
    pub fn set(mut self, v: Vec<Hash>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: Hash) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = Hash>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
    pub fn replace(&mut self, index: usize, v: Hash) -> Option<Hash> {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v))
    }
}
impl molecule::prelude::Builder for SszProofBuilder {
    type Entity = SszProof;
    const NAME: &'static str = "SszProofBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.0.len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.len() as molecule::Number))?;
        for inner in &self.0[..] {
            writer.write_all(inner.as_slice())?;
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        SszProof::new_unchecked(inner.into())
    }
}
pub struct SszProofIterator(SszProof, usize, usize);
impl ::core::iter::Iterator for SszProofIterator {
    type Item = Hash;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for SszProofIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for SszProof {
    type Item = Hash;
    type IntoIter = SszProofIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        SszProofIterator(self, 0, len)
    }
}
impl<'r> SszProofReader<'r> {
    pub fn iter<'t>(&'t self) -> SszProofReaderIterator<'t, 'r> {
        SszProofReaderIterator(&self, 0, self.len())
    }
}
pub struct SszProofReaderIterator<'t, 'r>(&'t SszProofReader<'r>, usize, usize);
impl<'t: 'r, 'r> ::core::iter::Iterator for SszProofReaderIterator<'t, 'r> {
    type Item = HashReader<'t>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::core::iter::ExactSizeIterator for SszProofReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
#[derive(Clone)]
pub struct MptProof(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for MptProof {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for MptProof {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for MptProof {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl ::core::default::Default for MptProof {
    fn default() -> Self {
        let v: Vec<u8> = vec![4, 0, 0, 0];
        MptProof::new_unchecked(v.into())
    }
}
impl MptProof {
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<Bytes> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> Bytes {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            Bytes::new_unchecked(self.0.slice(start..))
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            Bytes::new_unchecked(self.0.slice(start..end))
        }
    }
    pub fn as_reader<'r>(&'r self) -> MptProofReader<'r> {
        MptProofReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for MptProof {
    type Builder = MptProofBuilder;
    const NAME: &'static str = "MptProof";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        MptProof(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        MptProofReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        MptProofReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct MptProofReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for MptProofReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for MptProofReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for MptProofReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> MptProofReader<'r> {
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<BytesReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> BytesReader<'r> {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            BytesReader::new_unchecked(&self.as_slice()[start..])
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            BytesReader::new_unchecked(&self.as_slice()[start..end])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for MptProofReader<'r> {
    type Entity = MptProof;
    const NAME: &'static str = "MptProofReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        MptProofReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(
                Self,
                TotalSizeNotMatch,
                molecule::NUMBER_SIZE * 2,
                slice_len
            );
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        for pair in offsets.windows(2) {
            let start = pair[0];
            let end = pair[1];
            BytesReader::verify(&slice[start..end], compatible)?;
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct MptProofBuilder(pub(crate) Vec<Bytes>);
impl MptProofBuilder {
    pub fn set(mut self, v: Vec<Bytes>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: Bytes) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = Bytes>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
    pub fn replace(&mut self, index: usize, v: Bytes) -> Option<Bytes> {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v))
    }
}
impl molecule::prelude::Builder for MptProofBuilder {
    type Entity = MptProof;
    const NAME: &'static str = "MptProofBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (self.0.len() + 1)
            + self
                .0
                .iter()
                .map(|inner| inner.as_slice().len())
                .sum::<usize>()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let item_count = self.0.len();
        if item_count == 0 {
            writer.write_all(&molecule::pack_number(
                molecule::NUMBER_SIZE as molecule::Number,
            ))?;
        } else {
            let (total_size, offsets) = self.0.iter().fold(
                (
                    molecule::NUMBER_SIZE * (item_count + 1),
                    Vec::with_capacity(item_count),
                ),
                |(start, mut offsets), inner| {
                    offsets.push(start);
                    (start + inner.as_slice().len(), offsets)
                },
            );
            writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
            for offset in offsets.into_iter() {
                writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
            }
            for inner in self.0.iter() {
                writer.write_all(inner.as_slice())?;
            }
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        MptProof::new_unchecked(inner.into())
    }
}
pub struct MptProofIterator(MptProof, usize, usize);
impl ::core::iter::Iterator for MptProofIterator {
    type Item = Bytes;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for MptProofIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for MptProof {
    type Item = Bytes;
    type IntoIter = MptProofIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        MptProofIterator(self, 0, len)
    }
}
impl<'r> MptProofReader<'r> {
    pub fn iter<'t>(&'t self) -> MptProofReaderIterator<'t, 'r> {
        MptProofReaderIterator(&self, 0, self.len())
    }
}
pub struct MptProofReaderIterator<'t, 'r>(&'t MptProofReader<'r>, usize, usize);
impl<'t: 'r, 'r> ::core::iter::Iterator for MptProofReaderIterator<'t, 'r> {
    type Item = BytesReader<'t>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::core::iter::ExactSizeIterator for MptProofReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
#[derive(Clone)]
pub struct HeaderDigest(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for HeaderDigest {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for HeaderDigest {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for HeaderDigest {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "children_hash", self.children_hash())?;
        write!(f, " }}")
    }
}
impl ::core::default::Default for HeaderDigest {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0,
        ];
        HeaderDigest::new_unchecked(v.into())
    }
}
impl HeaderDigest {
    pub const TOTAL_SIZE: usize = 32;
    pub const FIELD_SIZES: [usize; 1] = [32];
    pub const FIELD_COUNT: usize = 1;
    pub fn children_hash(&self) -> Hash {
        Hash::new_unchecked(self.0.slice(0..32))
    }
    pub fn as_reader<'r>(&'r self) -> HeaderDigestReader<'r> {
        HeaderDigestReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for HeaderDigest {
    type Builder = HeaderDigestBuilder;
    const NAME: &'static str = "HeaderDigest";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        HeaderDigest(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        HeaderDigestReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        HeaderDigestReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().children_hash(self.children_hash())
    }
}
#[derive(Clone, Copy)]
pub struct HeaderDigestReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for HeaderDigestReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for HeaderDigestReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for HeaderDigestReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "children_hash", self.children_hash())?;
        write!(f, " }}")
    }
}
impl<'r> HeaderDigestReader<'r> {
    pub const TOTAL_SIZE: usize = 32;
    pub const FIELD_SIZES: [usize; 1] = [32];
    pub const FIELD_COUNT: usize = 1;
    pub fn children_hash(&self) -> HashReader<'r> {
        HashReader::new_unchecked(&self.as_slice()[0..32])
    }
}
impl<'r> molecule::prelude::Reader<'r> for HeaderDigestReader<'r> {
    type Entity = HeaderDigest;
    const NAME: &'static str = "HeaderDigestReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        HeaderDigestReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct HeaderDigestBuilder {
    pub(crate) children_hash: Hash,
}
impl HeaderDigestBuilder {
    pub const TOTAL_SIZE: usize = 32;
    pub const FIELD_SIZES: [usize; 1] = [32];
    pub const FIELD_COUNT: usize = 1;
    pub fn children_hash(mut self, v: Hash) -> Self {
        self.children_hash = v;
        self
    }
}
impl molecule::prelude::Builder for HeaderDigestBuilder {
    type Entity = HeaderDigest;
    const NAME: &'static str = "HeaderDigestBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.children_hash.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        HeaderDigest::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct MmrProof(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for MmrProof {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for MmrProof {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for MmrProof {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl ::core::default::Default for MmrProof {
    fn default() -> Self {
        let v: Vec<u8> = vec![0, 0, 0, 0];
        MmrProof::new_unchecked(v.into())
    }
}
impl MmrProof {
    pub const ITEM_SIZE: usize = 32;
    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()
    }
    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<HeaderDigest> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> HeaderDigest {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        HeaderDigest::new_unchecked(self.0.slice(start..end))
    }
    pub fn as_reader<'r>(&'r self) -> MmrProofReader<'r> {
        MmrProofReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for MmrProof {
    type Builder = MmrProofBuilder;
    const NAME: &'static str = "MmrProof";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        MmrProof(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        MmrProofReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        MmrProofReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct MmrProofReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for MmrProofReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for MmrProofReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for MmrProofReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> MmrProofReader<'r> {
    pub const ITEM_SIZE: usize = 32;
    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()
    }
    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<HeaderDigestReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> HeaderDigestReader<'r> {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        HeaderDigestReader::new_unchecked(&self.as_slice()[start..end])
    }
}
impl<'r> molecule::prelude::Reader<'r> for MmrProofReader<'r> {
    type Entity = MmrProof;
    const NAME: &'static str = "MmrProofReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        MmrProofReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_count = molecule::unpack_number(slice) as usize;
        if item_count == 0 {
            if slice_len != molecule::NUMBER_SIZE {
                return ve!(Self, TotalSizeNotMatch, molecule::NUMBER_SIZE, slice_len);
            }
            return Ok(());
        }
        let total_size = molecule::NUMBER_SIZE + Self::ITEM_SIZE * item_count;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct MmrProofBuilder(pub(crate) Vec<HeaderDigest>);
impl MmrProofBuilder {
    pub const ITEM_SIZE: usize = 32;
    pub fn set(mut self, v: Vec<HeaderDigest>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: HeaderDigest) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = HeaderDigest>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
    pub fn replace(&mut self, index: usize, v: HeaderDigest) -> Option<HeaderDigest> {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v))
    }
}
impl molecule::prelude::Builder for MmrProofBuilder {
    type Entity = MmrProof;
    const NAME: &'static str = "MmrProofBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.0.len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.len() as molecule::Number))?;
        for inner in &self.0[..] {
            writer.write_all(inner.as_slice())?;
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        MmrProof::new_unchecked(inner.into())
    }
}
pub struct MmrProofIterator(MmrProof, usize, usize);
impl ::core::iter::Iterator for MmrProofIterator {
    type Item = HeaderDigest;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for MmrProofIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for MmrProof {
    type Item = HeaderDigest;
    type IntoIter = MmrProofIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        MmrProofIterator(self, 0, len)
    }
}
impl<'r> MmrProofReader<'r> {
    pub fn iter<'t>(&'t self) -> MmrProofReaderIterator<'t, 'r> {
        MmrProofReaderIterator(&self, 0, self.len())
    }
}
pub struct MmrProofReaderIterator<'t, 'r>(&'t MmrProofReader<'r>, usize, usize);
impl<'t: 'r, 'r> ::core::iter::Iterator for MmrProofReaderIterator<'t, 'r> {
    type Item = HeaderDigestReader<'t>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::core::iter::ExactSizeIterator for MmrProofReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
#[derive(Clone)]
pub struct Header(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Header {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Header {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Header {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "slot", self.slot())?;
        write!(f, ", {}: {}", "proposer_index", self.proposer_index())?;
        write!(f, ", {}: {}", "parent_root", self.parent_root())?;
        write!(f, ", {}: {}", "state_root", self.state_root())?;
        write!(f, ", {}: {}", "body_root", self.body_root())?;
        write!(f, " }}")
    }
}
impl ::core::default::Default for Header {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        Header::new_unchecked(v.into())
    }
}
impl Header {
    pub const TOTAL_SIZE: usize = 112;
    pub const FIELD_SIZES: [usize; 5] = [8, 8, 32, 32, 32];
    pub const FIELD_COUNT: usize = 5;
    pub fn slot(&self) -> Uint64 {
        Uint64::new_unchecked(self.0.slice(0..8))
    }
    pub fn proposer_index(&self) -> Uint64 {
        Uint64::new_unchecked(self.0.slice(8..16))
    }
    pub fn parent_root(&self) -> Hash {
        Hash::new_unchecked(self.0.slice(16..48))
    }
    pub fn state_root(&self) -> Hash {
        Hash::new_unchecked(self.0.slice(48..80))
    }
    pub fn body_root(&self) -> Hash {
        Hash::new_unchecked(self.0.slice(80..112))
    }
    pub fn as_reader<'r>(&'r self) -> HeaderReader<'r> {
        HeaderReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Header {
    type Builder = HeaderBuilder;
    const NAME: &'static str = "Header";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Header(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        HeaderReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        HeaderReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .slot(self.slot())
            .proposer_index(self.proposer_index())
            .parent_root(self.parent_root())
            .state_root(self.state_root())
            .body_root(self.body_root())
    }
}
#[derive(Clone, Copy)]
pub struct HeaderReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for HeaderReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for HeaderReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for HeaderReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "slot", self.slot())?;
        write!(f, ", {}: {}", "proposer_index", self.proposer_index())?;
        write!(f, ", {}: {}", "parent_root", self.parent_root())?;
        write!(f, ", {}: {}", "state_root", self.state_root())?;
        write!(f, ", {}: {}", "body_root", self.body_root())?;
        write!(f, " }}")
    }
}
impl<'r> HeaderReader<'r> {
    pub const TOTAL_SIZE: usize = 112;
    pub const FIELD_SIZES: [usize; 5] = [8, 8, 32, 32, 32];
    pub const FIELD_COUNT: usize = 5;
    pub fn slot(&self) -> Uint64Reader<'r> {
        Uint64Reader::new_unchecked(&self.as_slice()[0..8])
    }
    pub fn proposer_index(&self) -> Uint64Reader<'r> {
        Uint64Reader::new_unchecked(&self.as_slice()[8..16])
    }
    pub fn parent_root(&self) -> HashReader<'r> {
        HashReader::new_unchecked(&self.as_slice()[16..48])
    }
    pub fn state_root(&self) -> HashReader<'r> {
        HashReader::new_unchecked(&self.as_slice()[48..80])
    }
    pub fn body_root(&self) -> HashReader<'r> {
        HashReader::new_unchecked(&self.as_slice()[80..112])
    }
}
impl<'r> molecule::prelude::Reader<'r> for HeaderReader<'r> {
    type Entity = Header;
    const NAME: &'static str = "HeaderReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        HeaderReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct HeaderBuilder {
    pub(crate) slot: Uint64,
    pub(crate) proposer_index: Uint64,
    pub(crate) parent_root: Hash,
    pub(crate) state_root: Hash,
    pub(crate) body_root: Hash,
}
impl HeaderBuilder {
    pub const TOTAL_SIZE: usize = 112;
    pub const FIELD_SIZES: [usize; 5] = [8, 8, 32, 32, 32];
    pub const FIELD_COUNT: usize = 5;
    pub fn slot(mut self, v: Uint64) -> Self {
        self.slot = v;
        self
    }
    pub fn proposer_index(mut self, v: Uint64) -> Self {
        self.proposer_index = v;
        self
    }
    pub fn parent_root(mut self, v: Hash) -> Self {
        self.parent_root = v;
        self
    }
    pub fn state_root(mut self, v: Hash) -> Self {
        self.state_root = v;
        self
    }
    pub fn body_root(mut self, v: Hash) -> Self {
        self.body_root = v;
        self
    }
}
impl molecule::prelude::Builder for HeaderBuilder {
    type Entity = Header;
    const NAME: &'static str = "HeaderBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.slot.as_slice())?;
        writer.write_all(self.proposer_index.as_slice())?;
        writer.write_all(self.parent_root.as_slice())?;
        writer.write_all(self.state_root.as_slice())?;
        writer.write_all(self.body_root.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Header::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct SyncAggregate(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for SyncAggregate {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for SyncAggregate {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for SyncAggregate {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(
            f,
            "{}: {}",
            "sync_committee_bits",
            self.sync_committee_bits()
        )?;
        write!(
            f,
            ", {}: {}",
            "sync_committee_signature",
            self.sync_committee_signature()
        )?;
        write!(f, " }}")
    }
}
impl ::core::default::Default for SyncAggregate {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        SyncAggregate::new_unchecked(v.into())
    }
}
impl SyncAggregate {
    pub const TOTAL_SIZE: usize = 160;
    pub const FIELD_SIZES: [usize; 2] = [64, 96];
    pub const FIELD_COUNT: usize = 2;
    pub fn sync_committee_bits(&self) -> Bytes64 {
        Bytes64::new_unchecked(self.0.slice(0..64))
    }
    pub fn sync_committee_signature(&self) -> BlsSignature {
        BlsSignature::new_unchecked(self.0.slice(64..160))
    }
    pub fn as_reader<'r>(&'r self) -> SyncAggregateReader<'r> {
        SyncAggregateReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for SyncAggregate {
    type Builder = SyncAggregateBuilder;
    const NAME: &'static str = "SyncAggregate";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        SyncAggregate(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SyncAggregateReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SyncAggregateReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .sync_committee_bits(self.sync_committee_bits())
            .sync_committee_signature(self.sync_committee_signature())
    }
}
#[derive(Clone, Copy)]
pub struct SyncAggregateReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for SyncAggregateReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for SyncAggregateReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for SyncAggregateReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(
            f,
            "{}: {}",
            "sync_committee_bits",
            self.sync_committee_bits()
        )?;
        write!(
            f,
            ", {}: {}",
            "sync_committee_signature",
            self.sync_committee_signature()
        )?;
        write!(f, " }}")
    }
}
impl<'r> SyncAggregateReader<'r> {
    pub const TOTAL_SIZE: usize = 160;
    pub const FIELD_SIZES: [usize; 2] = [64, 96];
    pub const FIELD_COUNT: usize = 2;
    pub fn sync_committee_bits(&self) -> Bytes64Reader<'r> {
        Bytes64Reader::new_unchecked(&self.as_slice()[0..64])
    }
    pub fn sync_committee_signature(&self) -> BlsSignatureReader<'r> {
        BlsSignatureReader::new_unchecked(&self.as_slice()[64..160])
    }
}
impl<'r> molecule::prelude::Reader<'r> for SyncAggregateReader<'r> {
    type Entity = SyncAggregate;
    const NAME: &'static str = "SyncAggregateReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        SyncAggregateReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct SyncAggregateBuilder {
    pub(crate) sync_committee_bits: Bytes64,
    pub(crate) sync_committee_signature: BlsSignature,
}
impl SyncAggregateBuilder {
    pub const TOTAL_SIZE: usize = 160;
    pub const FIELD_SIZES: [usize; 2] = [64, 96];
    pub const FIELD_COUNT: usize = 2;
    pub fn sync_committee_bits(mut self, v: Bytes64) -> Self {
        self.sync_committee_bits = v;
        self
    }
    pub fn sync_committee_signature(mut self, v: BlsSignature) -> Self {
        self.sync_committee_signature = v;
        self
    }
}
impl molecule::prelude::Builder for SyncAggregateBuilder {
    type Entity = SyncAggregate;
    const NAME: &'static str = "SyncAggregateBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.sync_committee_bits.as_slice())?;
        writer.write_all(self.sync_committee_signature.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        SyncAggregate::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct FinalityUpdate(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for FinalityUpdate {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for FinalityUpdate {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for FinalityUpdate {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "attested_header", self.attested_header())?;
        write!(f, ", {}: {}", "finalized_header", self.finalized_header())?;
        write!(f, ", {}: {}", "finality_branch", self.finality_branch())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for FinalityUpdate {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            244, 0, 0, 0, 16, 0, 0, 0, 128, 0, 0, 0, 240, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        FinalityUpdate::new_unchecked(v.into())
    }
}
impl FinalityUpdate {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn attested_header(&self) -> Header {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Header::new_unchecked(self.0.slice(start..end))
    }
    pub fn finalized_header(&self) -> Header {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Header::new_unchecked(self.0.slice(start..end))
    }
    pub fn finality_branch(&self) -> SszProof {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            SszProof::new_unchecked(self.0.slice(start..end))
        } else {
            SszProof::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> FinalityUpdateReader<'r> {
        FinalityUpdateReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for FinalityUpdate {
    type Builder = FinalityUpdateBuilder;
    const NAME: &'static str = "FinalityUpdate";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        FinalityUpdate(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        FinalityUpdateReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        FinalityUpdateReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .attested_header(self.attested_header())
            .finalized_header(self.finalized_header())
            .finality_branch(self.finality_branch())
    }
}
#[derive(Clone, Copy)]
pub struct FinalityUpdateReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for FinalityUpdateReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for FinalityUpdateReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for FinalityUpdateReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "attested_header", self.attested_header())?;
        write!(f, ", {}: {}", "finalized_header", self.finalized_header())?;
        write!(f, ", {}: {}", "finality_branch", self.finality_branch())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> FinalityUpdateReader<'r> {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn attested_header(&self) -> HeaderReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        HeaderReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn finalized_header(&self) -> HeaderReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        HeaderReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn finality_branch(&self) -> SszProofReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            SszProofReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            SszProofReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for FinalityUpdateReader<'r> {
    type Entity = FinalityUpdate;
    const NAME: &'static str = "FinalityUpdateReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        FinalityUpdateReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        HeaderReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        HeaderReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        SszProofReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct FinalityUpdateBuilder {
    pub(crate) attested_header: Header,
    pub(crate) finalized_header: Header,
    pub(crate) finality_branch: SszProof,
}
impl FinalityUpdateBuilder {
    pub const FIELD_COUNT: usize = 3;
    pub fn attested_header(mut self, v: Header) -> Self {
        self.attested_header = v;
        self
    }
    pub fn finalized_header(mut self, v: Header) -> Self {
        self.finalized_header = v;
        self
    }
    pub fn finality_branch(mut self, v: SszProof) -> Self {
        self.finality_branch = v;
        self
    }
}
impl molecule::prelude::Builder for FinalityUpdateBuilder {
    type Entity = FinalityUpdate;
    const NAME: &'static str = "FinalityUpdateBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.attested_header.as_slice().len()
            + self.finalized_header.as_slice().len()
            + self.finality_branch.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.attested_header.as_slice().len();
        offsets.push(total_size);
        total_size += self.finalized_header.as_slice().len();
        offsets.push(total_size);
        total_size += self.finality_branch.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.attested_header.as_slice())?;
        writer.write_all(self.finalized_header.as_slice())?;
        writer.write_all(self.finality_branch.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        FinalityUpdate::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct SyncCommittee(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for SyncCommittee {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for SyncCommittee {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for SyncCommittee {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "period", self.period())?;
        write!(f, ", {}: {}", "pubkeys", self.pubkeys())?;
        write!(f, ", {}: {}", "aggregate_pubkey", self.aggregate_pubkey())?;
        write!(f, " }}")
    }
}
impl ::core::default::Default for SyncCommittee {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        SyncCommittee::new_unchecked(v.into())
    }
}
impl SyncCommittee {
    pub const TOTAL_SIZE: usize = 16424;
    pub const FIELD_SIZES: [usize; 3] = [8, 16384, 32];
    pub const FIELD_COUNT: usize = 3;
    pub fn period(&self) -> Uint64 {
        Uint64::new_unchecked(self.0.slice(0..8))
    }
    pub fn pubkeys(&self) -> BlsPubkeyArray {
        BlsPubkeyArray::new_unchecked(self.0.slice(8..16392))
    }
    pub fn aggregate_pubkey(&self) -> BlsPubkey {
        BlsPubkey::new_unchecked(self.0.slice(16392..16424))
    }
    pub fn as_reader<'r>(&'r self) -> SyncCommitteeReader<'r> {
        SyncCommitteeReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for SyncCommittee {
    type Builder = SyncCommitteeBuilder;
    const NAME: &'static str = "SyncCommittee";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        SyncCommittee(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SyncCommitteeReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SyncCommitteeReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .period(self.period())
            .pubkeys(self.pubkeys())
            .aggregate_pubkey(self.aggregate_pubkey())
    }
}
#[derive(Clone, Copy)]
pub struct SyncCommitteeReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for SyncCommitteeReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for SyncCommitteeReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for SyncCommitteeReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "period", self.period())?;
        write!(f, ", {}: {}", "pubkeys", self.pubkeys())?;
        write!(f, ", {}: {}", "aggregate_pubkey", self.aggregate_pubkey())?;
        write!(f, " }}")
    }
}
impl<'r> SyncCommitteeReader<'r> {
    pub const TOTAL_SIZE: usize = 16424;
    pub const FIELD_SIZES: [usize; 3] = [8, 16384, 32];
    pub const FIELD_COUNT: usize = 3;
    pub fn period(&self) -> Uint64Reader<'r> {
        Uint64Reader::new_unchecked(&self.as_slice()[0..8])
    }
    pub fn pubkeys(&self) -> BlsPubkeyArrayReader<'r> {
        BlsPubkeyArrayReader::new_unchecked(&self.as_slice()[8..16392])
    }
    pub fn aggregate_pubkey(&self) -> BlsPubkeyReader<'r> {
        BlsPubkeyReader::new_unchecked(&self.as_slice()[16392..16424])
    }
}
impl<'r> molecule::prelude::Reader<'r> for SyncCommitteeReader<'r> {
    type Entity = SyncCommittee;
    const NAME: &'static str = "SyncCommitteeReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        SyncCommitteeReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct SyncCommitteeBuilder {
    pub(crate) period: Uint64,
    pub(crate) pubkeys: BlsPubkeyArray,
    pub(crate) aggregate_pubkey: BlsPubkey,
}
impl SyncCommitteeBuilder {
    pub const TOTAL_SIZE: usize = 16424;
    pub const FIELD_SIZES: [usize; 3] = [8, 16384, 32];
    pub const FIELD_COUNT: usize = 3;
    pub fn period(mut self, v: Uint64) -> Self {
        self.period = v;
        self
    }
    pub fn pubkeys(mut self, v: BlsPubkeyArray) -> Self {
        self.pubkeys = v;
        self
    }
    pub fn aggregate_pubkey(mut self, v: BlsPubkey) -> Self {
        self.aggregate_pubkey = v;
        self
    }
}
impl molecule::prelude::Builder for SyncCommitteeBuilder {
    type Entity = SyncCommittee;
    const NAME: &'static str = "SyncCommitteeBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.period.as_slice())?;
        writer.write_all(self.pubkeys.as_slice())?;
        writer.write_all(self.aggregate_pubkey.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        SyncCommittee::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct HeaderVec(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for HeaderVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for HeaderVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for HeaderVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl ::core::default::Default for HeaderVec {
    fn default() -> Self {
        let v: Vec<u8> = vec![0, 0, 0, 0];
        HeaderVec::new_unchecked(v.into())
    }
}
impl HeaderVec {
    pub const ITEM_SIZE: usize = 112;
    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()
    }
    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<Header> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> Header {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        Header::new_unchecked(self.0.slice(start..end))
    }
    pub fn as_reader<'r>(&'r self) -> HeaderVecReader<'r> {
        HeaderVecReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for HeaderVec {
    type Builder = HeaderVecBuilder;
    const NAME: &'static str = "HeaderVec";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        HeaderVec(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        HeaderVecReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        HeaderVecReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct HeaderVecReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for HeaderVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for HeaderVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for HeaderVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> HeaderVecReader<'r> {
    pub const ITEM_SIZE: usize = 112;
    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()
    }
    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<HeaderReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> HeaderReader<'r> {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        HeaderReader::new_unchecked(&self.as_slice()[start..end])
    }
}
impl<'r> molecule::prelude::Reader<'r> for HeaderVecReader<'r> {
    type Entity = HeaderVec;
    const NAME: &'static str = "HeaderVecReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        HeaderVecReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_count = molecule::unpack_number(slice) as usize;
        if item_count == 0 {
            if slice_len != molecule::NUMBER_SIZE {
                return ve!(Self, TotalSizeNotMatch, molecule::NUMBER_SIZE, slice_len);
            }
            return Ok(());
        }
        let total_size = molecule::NUMBER_SIZE + Self::ITEM_SIZE * item_count;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct HeaderVecBuilder(pub(crate) Vec<Header>);
impl HeaderVecBuilder {
    pub const ITEM_SIZE: usize = 112;
    pub fn set(mut self, v: Vec<Header>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: Header) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = Header>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
    pub fn replace(&mut self, index: usize, v: Header) -> Option<Header> {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v))
    }
}
impl molecule::prelude::Builder for HeaderVecBuilder {
    type Entity = HeaderVec;
    const NAME: &'static str = "HeaderVecBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.0.len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.len() as molecule::Number))?;
        for inner in &self.0[..] {
            writer.write_all(inner.as_slice())?;
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        HeaderVec::new_unchecked(inner.into())
    }
}
pub struct HeaderVecIterator(HeaderVec, usize, usize);
impl ::core::iter::Iterator for HeaderVecIterator {
    type Item = Header;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for HeaderVecIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for HeaderVec {
    type Item = Header;
    type IntoIter = HeaderVecIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        HeaderVecIterator(self, 0, len)
    }
}
impl<'r> HeaderVecReader<'r> {
    pub fn iter<'t>(&'t self) -> HeaderVecReaderIterator<'t, 'r> {
        HeaderVecReaderIterator(&self, 0, self.len())
    }
}
pub struct HeaderVecReaderIterator<'t, 'r>(&'t HeaderVecReader<'r>, usize, usize);
impl<'t: 'r, 'r> ::core::iter::Iterator for HeaderVecReaderIterator<'t, 'r> {
    type Item = HeaderReader<'t>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::core::iter::ExactSizeIterator for HeaderVecReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
#[derive(Clone)]
pub struct FinalityUpdateVec(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for FinalityUpdateVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for FinalityUpdateVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for FinalityUpdateVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl ::core::default::Default for FinalityUpdateVec {
    fn default() -> Self {
        let v: Vec<u8> = vec![4, 0, 0, 0];
        FinalityUpdateVec::new_unchecked(v.into())
    }
}
impl FinalityUpdateVec {
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<FinalityUpdate> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> FinalityUpdate {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            FinalityUpdate::new_unchecked(self.0.slice(start..))
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            FinalityUpdate::new_unchecked(self.0.slice(start..end))
        }
    }
    pub fn as_reader<'r>(&'r self) -> FinalityUpdateVecReader<'r> {
        FinalityUpdateVecReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for FinalityUpdateVec {
    type Builder = FinalityUpdateVecBuilder;
    const NAME: &'static str = "FinalityUpdateVec";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        FinalityUpdateVec(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        FinalityUpdateVecReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        FinalityUpdateVecReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct FinalityUpdateVecReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for FinalityUpdateVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for FinalityUpdateVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for FinalityUpdateVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> FinalityUpdateVecReader<'r> {
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<FinalityUpdateReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> FinalityUpdateReader<'r> {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            FinalityUpdateReader::new_unchecked(&self.as_slice()[start..])
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            FinalityUpdateReader::new_unchecked(&self.as_slice()[start..end])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for FinalityUpdateVecReader<'r> {
    type Entity = FinalityUpdateVec;
    const NAME: &'static str = "FinalityUpdateVecReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        FinalityUpdateVecReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(
                Self,
                TotalSizeNotMatch,
                molecule::NUMBER_SIZE * 2,
                slice_len
            );
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        for pair in offsets.windows(2) {
            let start = pair[0];
            let end = pair[1];
            FinalityUpdateReader::verify(&slice[start..end], compatible)?;
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct FinalityUpdateVecBuilder(pub(crate) Vec<FinalityUpdate>);
impl FinalityUpdateVecBuilder {
    pub fn set(mut self, v: Vec<FinalityUpdate>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: FinalityUpdate) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = FinalityUpdate>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
    pub fn replace(&mut self, index: usize, v: FinalityUpdate) -> Option<FinalityUpdate> {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v))
    }
}
impl molecule::prelude::Builder for FinalityUpdateVecBuilder {
    type Entity = FinalityUpdateVec;
    const NAME: &'static str = "FinalityUpdateVecBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (self.0.len() + 1)
            + self
                .0
                .iter()
                .map(|inner| inner.as_slice().len())
                .sum::<usize>()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let item_count = self.0.len();
        if item_count == 0 {
            writer.write_all(&molecule::pack_number(
                molecule::NUMBER_SIZE as molecule::Number,
            ))?;
        } else {
            let (total_size, offsets) = self.0.iter().fold(
                (
                    molecule::NUMBER_SIZE * (item_count + 1),
                    Vec::with_capacity(item_count),
                ),
                |(start, mut offsets), inner| {
                    offsets.push(start);
                    (start + inner.as_slice().len(), offsets)
                },
            );
            writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
            for offset in offsets.into_iter() {
                writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
            }
            for inner in self.0.iter() {
                writer.write_all(inner.as_slice())?;
            }
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        FinalityUpdateVec::new_unchecked(inner.into())
    }
}
pub struct FinalityUpdateVecIterator(FinalityUpdateVec, usize, usize);
impl ::core::iter::Iterator for FinalityUpdateVecIterator {
    type Item = FinalityUpdate;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for FinalityUpdateVecIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for FinalityUpdateVec {
    type Item = FinalityUpdate;
    type IntoIter = FinalityUpdateVecIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        FinalityUpdateVecIterator(self, 0, len)
    }
}
impl<'r> FinalityUpdateVecReader<'r> {
    pub fn iter<'t>(&'t self) -> FinalityUpdateVecReaderIterator<'t, 'r> {
        FinalityUpdateVecReaderIterator(&self, 0, self.len())
    }
}
pub struct FinalityUpdateVecReaderIterator<'t, 'r>(&'t FinalityUpdateVecReader<'r>, usize, usize);
impl<'t: 'r, 'r> ::core::iter::Iterator for FinalityUpdateVecReaderIterator<'t, 'r> {
    type Item = FinalityUpdateReader<'t>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::core::iter::ExactSizeIterator for FinalityUpdateVecReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
#[derive(Clone)]
pub struct Client(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Client {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Client {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Client {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "minimal_slot", self.minimal_slot())?;
        write!(f, ", {}: {}", "maximal_slot", self.maximal_slot())?;
        write!(f, ", {}: {}", "tip_header_root", self.tip_header_root())?;
        write!(f, ", {}: {}", "headers_mmr_root", self.headers_mmr_root())?;
        write!(f, " }}")
    }
}
impl ::core::default::Default for Client {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        Client::new_unchecked(v.into())
    }
}
impl Client {
    pub const TOTAL_SIZE: usize = 80;
    pub const FIELD_SIZES: [usize; 4] = [8, 8, 32, 32];
    pub const FIELD_COUNT: usize = 4;
    pub fn minimal_slot(&self) -> Uint64 {
        Uint64::new_unchecked(self.0.slice(0..8))
    }
    pub fn maximal_slot(&self) -> Uint64 {
        Uint64::new_unchecked(self.0.slice(8..16))
    }
    pub fn tip_header_root(&self) -> Hash {
        Hash::new_unchecked(self.0.slice(16..48))
    }
    pub fn headers_mmr_root(&self) -> HeaderDigest {
        HeaderDigest::new_unchecked(self.0.slice(48..80))
    }
    pub fn as_reader<'r>(&'r self) -> ClientReader<'r> {
        ClientReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Client {
    type Builder = ClientBuilder;
    const NAME: &'static str = "Client";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Client(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ClientReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ClientReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .minimal_slot(self.minimal_slot())
            .maximal_slot(self.maximal_slot())
            .tip_header_root(self.tip_header_root())
            .headers_mmr_root(self.headers_mmr_root())
    }
}
#[derive(Clone, Copy)]
pub struct ClientReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for ClientReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for ClientReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for ClientReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "minimal_slot", self.minimal_slot())?;
        write!(f, ", {}: {}", "maximal_slot", self.maximal_slot())?;
        write!(f, ", {}: {}", "tip_header_root", self.tip_header_root())?;
        write!(f, ", {}: {}", "headers_mmr_root", self.headers_mmr_root())?;
        write!(f, " }}")
    }
}
impl<'r> ClientReader<'r> {
    pub const TOTAL_SIZE: usize = 80;
    pub const FIELD_SIZES: [usize; 4] = [8, 8, 32, 32];
    pub const FIELD_COUNT: usize = 4;
    pub fn minimal_slot(&self) -> Uint64Reader<'r> {
        Uint64Reader::new_unchecked(&self.as_slice()[0..8])
    }
    pub fn maximal_slot(&self) -> Uint64Reader<'r> {
        Uint64Reader::new_unchecked(&self.as_slice()[8..16])
    }
    pub fn tip_header_root(&self) -> HashReader<'r> {
        HashReader::new_unchecked(&self.as_slice()[16..48])
    }
    pub fn headers_mmr_root(&self) -> HeaderDigestReader<'r> {
        HeaderDigestReader::new_unchecked(&self.as_slice()[48..80])
    }
}
impl<'r> molecule::prelude::Reader<'r> for ClientReader<'r> {
    type Entity = Client;
    const NAME: &'static str = "ClientReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        ClientReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct ClientBuilder {
    pub(crate) minimal_slot: Uint64,
    pub(crate) maximal_slot: Uint64,
    pub(crate) tip_header_root: Hash,
    pub(crate) headers_mmr_root: HeaderDigest,
}
impl ClientBuilder {
    pub const TOTAL_SIZE: usize = 80;
    pub const FIELD_SIZES: [usize; 4] = [8, 8, 32, 32];
    pub const FIELD_COUNT: usize = 4;
    pub fn minimal_slot(mut self, v: Uint64) -> Self {
        self.minimal_slot = v;
        self
    }
    pub fn maximal_slot(mut self, v: Uint64) -> Self {
        self.maximal_slot = v;
        self
    }
    pub fn tip_header_root(mut self, v: Hash) -> Self {
        self.tip_header_root = v;
        self
    }
    pub fn headers_mmr_root(mut self, v: HeaderDigest) -> Self {
        self.headers_mmr_root = v;
        self
    }
}
impl molecule::prelude::Builder for ClientBuilder {
    type Entity = Client;
    const NAME: &'static str = "ClientBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.minimal_slot.as_slice())?;
        writer.write_all(self.maximal_slot.as_slice())?;
        writer.write_all(self.tip_header_root.as_slice())?;
        writer.write_all(self.headers_mmr_root.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Client::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct ProofUpdate(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for ProofUpdate {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for ProofUpdate {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for ProofUpdate {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(
            f,
            "{}: {}",
            "new_headers_mmr_root",
            self.new_headers_mmr_root()
        )?;
        write!(
            f,
            ", {}: {}",
            "next_committee_ssz_proof",
            self.next_committee_ssz_proof()
        )?;
        write!(
            f,
            ", {}: {}",
            "new_headers_mmr_proof",
            self.new_headers_mmr_proof()
        )?;
        write!(f, ", {}: {}", "updates", self.updates())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for ProofUpdate {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            64, 0, 0, 0, 20, 0, 0, 0, 52, 0, 0, 0, 56, 0, 0, 0, 60, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 4, 0, 0, 0,
        ];
        ProofUpdate::new_unchecked(v.into())
    }
}
impl ProofUpdate {
    pub const FIELD_COUNT: usize = 4;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn new_headers_mmr_root(&self) -> HeaderDigest {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        HeaderDigest::new_unchecked(self.0.slice(start..end))
    }
    pub fn next_committee_ssz_proof(&self) -> SszProof {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        SszProof::new_unchecked(self.0.slice(start..end))
    }
    pub fn new_headers_mmr_proof(&self) -> MmrProof {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        MmrProof::new_unchecked(self.0.slice(start..end))
    }
    pub fn updates(&self) -> FinalityUpdateVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[20..]) as usize;
            FinalityUpdateVec::new_unchecked(self.0.slice(start..end))
        } else {
            FinalityUpdateVec::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> ProofUpdateReader<'r> {
        ProofUpdateReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for ProofUpdate {
    type Builder = ProofUpdateBuilder;
    const NAME: &'static str = "ProofUpdate";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        ProofUpdate(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ProofUpdateReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ProofUpdateReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .new_headers_mmr_root(self.new_headers_mmr_root())
            .next_committee_ssz_proof(self.next_committee_ssz_proof())
            .new_headers_mmr_proof(self.new_headers_mmr_proof())
            .updates(self.updates())
    }
}
#[derive(Clone, Copy)]
pub struct ProofUpdateReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for ProofUpdateReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for ProofUpdateReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for ProofUpdateReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(
            f,
            "{}: {}",
            "new_headers_mmr_root",
            self.new_headers_mmr_root()
        )?;
        write!(
            f,
            ", {}: {}",
            "next_committee_ssz_proof",
            self.next_committee_ssz_proof()
        )?;
        write!(
            f,
            ", {}: {}",
            "new_headers_mmr_proof",
            self.new_headers_mmr_proof()
        )?;
        write!(f, ", {}: {}", "updates", self.updates())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> ProofUpdateReader<'r> {
    pub const FIELD_COUNT: usize = 4;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn new_headers_mmr_root(&self) -> HeaderDigestReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        HeaderDigestReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn next_committee_ssz_proof(&self) -> SszProofReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        SszProofReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn new_headers_mmr_proof(&self) -> MmrProofReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        MmrProofReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn updates(&self) -> FinalityUpdateVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[20..]) as usize;
            FinalityUpdateVecReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            FinalityUpdateVecReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for ProofUpdateReader<'r> {
    type Entity = ProofUpdate;
    const NAME: &'static str = "ProofUpdateReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        ProofUpdateReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        HeaderDigestReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        SszProofReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        MmrProofReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        FinalityUpdateVecReader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct ProofUpdateBuilder {
    pub(crate) new_headers_mmr_root: HeaderDigest,
    pub(crate) next_committee_ssz_proof: SszProof,
    pub(crate) new_headers_mmr_proof: MmrProof,
    pub(crate) updates: FinalityUpdateVec,
}
impl ProofUpdateBuilder {
    pub const FIELD_COUNT: usize = 4;
    pub fn new_headers_mmr_root(mut self, v: HeaderDigest) -> Self {
        self.new_headers_mmr_root = v;
        self
    }
    pub fn next_committee_ssz_proof(mut self, v: SszProof) -> Self {
        self.next_committee_ssz_proof = v;
        self
    }
    pub fn new_headers_mmr_proof(mut self, v: MmrProof) -> Self {
        self.new_headers_mmr_proof = v;
        self
    }
    pub fn updates(mut self, v: FinalityUpdateVec) -> Self {
        self.updates = v;
        self
    }
}
impl molecule::prelude::Builder for ProofUpdateBuilder {
    type Entity = ProofUpdate;
    const NAME: &'static str = "ProofUpdateBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.new_headers_mmr_root.as_slice().len()
            + self.next_committee_ssz_proof.as_slice().len()
            + self.new_headers_mmr_proof.as_slice().len()
            + self.updates.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.new_headers_mmr_root.as_slice().len();
        offsets.push(total_size);
        total_size += self.next_committee_ssz_proof.as_slice().len();
        offsets.push(total_size);
        total_size += self.new_headers_mmr_proof.as_slice().len();
        offsets.push(total_size);
        total_size += self.updates.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.new_headers_mmr_root.as_slice())?;
        writer.write_all(self.next_committee_ssz_proof.as_slice())?;
        writer.write_all(self.new_headers_mmr_proof.as_slice())?;
        writer.write_all(self.updates.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        ProofUpdate::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct TransactionProof(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for TransactionProof {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for TransactionProof {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for TransactionProof {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "header", self.header())?;
        write!(f, ", {}: {}", "transaction_index", self.transaction_index())?;
        write!(f, ", {}: {}", "receipts_root", self.receipts_root())?;
        write!(f, ", {}: {}", "header_mmr_proof", self.header_mmr_proof())?;
        write!(
            f,
            ", {}: {}",
            "transaction_ssz_proof",
            self.transaction_ssz_proof()
        )?;
        write!(f, ", {}: {}", "receipt_mpt_proof", self.receipt_mpt_proof())?;
        write!(
            f,
            ", {}: {}",
            "receipts_root_ssz_proof",
            self.receipts_root_ssz_proof()
        )?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for TransactionProof {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            200, 0, 0, 0, 32, 0, 0, 0, 144, 0, 0, 0, 152, 0, 0, 0, 184, 0, 0, 0, 188, 0, 0, 0, 192,
            0, 0, 0, 196, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0,
            0, 0,
        ];
        TransactionProof::new_unchecked(v.into())
    }
}
impl TransactionProof {
    pub const FIELD_COUNT: usize = 7;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn header(&self) -> Header {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Header::new_unchecked(self.0.slice(start..end))
    }
    pub fn transaction_index(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn receipts_root(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Hash::new_unchecked(self.0.slice(start..end))
    }
    pub fn header_mmr_proof(&self) -> MmrProof {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        MmrProof::new_unchecked(self.0.slice(start..end))
    }
    pub fn transaction_ssz_proof(&self) -> SszProof {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        SszProof::new_unchecked(self.0.slice(start..end))
    }
    pub fn receipt_mpt_proof(&self) -> MptProof {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        let end = molecule::unpack_number(&slice[28..]) as usize;
        MptProof::new_unchecked(self.0.slice(start..end))
    }
    pub fn receipts_root_ssz_proof(&self) -> SszProof {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[28..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[32..]) as usize;
            SszProof::new_unchecked(self.0.slice(start..end))
        } else {
            SszProof::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> TransactionProofReader<'r> {
        TransactionProofReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for TransactionProof {
    type Builder = TransactionProofBuilder;
    const NAME: &'static str = "TransactionProof";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        TransactionProof(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TransactionProofReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TransactionProofReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .header(self.header())
            .transaction_index(self.transaction_index())
            .receipts_root(self.receipts_root())
            .header_mmr_proof(self.header_mmr_proof())
            .transaction_ssz_proof(self.transaction_ssz_proof())
            .receipt_mpt_proof(self.receipt_mpt_proof())
            .receipts_root_ssz_proof(self.receipts_root_ssz_proof())
    }
}
#[derive(Clone, Copy)]
pub struct TransactionProofReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for TransactionProofReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for TransactionProofReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for TransactionProofReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "header", self.header())?;
        write!(f, ", {}: {}", "transaction_index", self.transaction_index())?;
        write!(f, ", {}: {}", "receipts_root", self.receipts_root())?;
        write!(f, ", {}: {}", "header_mmr_proof", self.header_mmr_proof())?;
        write!(
            f,
            ", {}: {}",
            "transaction_ssz_proof",
            self.transaction_ssz_proof()
        )?;
        write!(f, ", {}: {}", "receipt_mpt_proof", self.receipt_mpt_proof())?;
        write!(
            f,
            ", {}: {}",
            "receipts_root_ssz_proof",
            self.receipts_root_ssz_proof()
        )?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> TransactionProofReader<'r> {
    pub const FIELD_COUNT: usize = 7;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn header(&self) -> HeaderReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        HeaderReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn transaction_index(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn receipts_root(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        HashReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn header_mmr_proof(&self) -> MmrProofReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        MmrProofReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn transaction_ssz_proof(&self) -> SszProofReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        SszProofReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn receipt_mpt_proof(&self) -> MptProofReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        let end = molecule::unpack_number(&slice[28..]) as usize;
        MptProofReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn receipts_root_ssz_proof(&self) -> SszProofReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[28..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[32..]) as usize;
            SszProofReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            SszProofReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for TransactionProofReader<'r> {
    type Entity = TransactionProof;
    const NAME: &'static str = "TransactionProofReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        TransactionProofReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        HeaderReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Uint64Reader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        HashReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        MmrProofReader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        SszProofReader::verify(&slice[offsets[4]..offsets[5]], compatible)?;
        MptProofReader::verify(&slice[offsets[5]..offsets[6]], compatible)?;
        SszProofReader::verify(&slice[offsets[6]..offsets[7]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct TransactionProofBuilder {
    pub(crate) header: Header,
    pub(crate) transaction_index: Uint64,
    pub(crate) receipts_root: Hash,
    pub(crate) header_mmr_proof: MmrProof,
    pub(crate) transaction_ssz_proof: SszProof,
    pub(crate) receipt_mpt_proof: MptProof,
    pub(crate) receipts_root_ssz_proof: SszProof,
}
impl TransactionProofBuilder {
    pub const FIELD_COUNT: usize = 7;
    pub fn header(mut self, v: Header) -> Self {
        self.header = v;
        self
    }
    pub fn transaction_index(mut self, v: Uint64) -> Self {
        self.transaction_index = v;
        self
    }
    pub fn receipts_root(mut self, v: Hash) -> Self {
        self.receipts_root = v;
        self
    }
    pub fn header_mmr_proof(mut self, v: MmrProof) -> Self {
        self.header_mmr_proof = v;
        self
    }
    pub fn transaction_ssz_proof(mut self, v: SszProof) -> Self {
        self.transaction_ssz_proof = v;
        self
    }
    pub fn receipt_mpt_proof(mut self, v: MptProof) -> Self {
        self.receipt_mpt_proof = v;
        self
    }
    pub fn receipts_root_ssz_proof(mut self, v: SszProof) -> Self {
        self.receipts_root_ssz_proof = v;
        self
    }
}
impl molecule::prelude::Builder for TransactionProofBuilder {
    type Entity = TransactionProof;
    const NAME: &'static str = "TransactionProofBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.header.as_slice().len()
            + self.transaction_index.as_slice().len()
            + self.receipts_root.as_slice().len()
            + self.header_mmr_proof.as_slice().len()
            + self.transaction_ssz_proof.as_slice().len()
            + self.receipt_mpt_proof.as_slice().len()
            + self.receipts_root_ssz_proof.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.header.as_slice().len();
        offsets.push(total_size);
        total_size += self.transaction_index.as_slice().len();
        offsets.push(total_size);
        total_size += self.receipts_root.as_slice().len();
        offsets.push(total_size);
        total_size += self.header_mmr_proof.as_slice().len();
        offsets.push(total_size);
        total_size += self.transaction_ssz_proof.as_slice().len();
        offsets.push(total_size);
        total_size += self.receipt_mpt_proof.as_slice().len();
        offsets.push(total_size);
        total_size += self.receipts_root_ssz_proof.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.header.as_slice())?;
        writer.write_all(self.transaction_index.as_slice())?;
        writer.write_all(self.receipts_root.as_slice())?;
        writer.write_all(self.header_mmr_proof.as_slice())?;
        writer.write_all(self.transaction_ssz_proof.as_slice())?;
        writer.write_all(self.receipt_mpt_proof.as_slice())?;
        writer.write_all(self.receipts_root_ssz_proof.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        TransactionProof::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct TransactionPayload(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for TransactionPayload {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for TransactionPayload {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for TransactionPayload {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "transaction", self.transaction())?;
        write!(f, ", {}: {}", "receipt", self.receipt())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for TransactionPayload {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            20, 0, 0, 0, 12, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        TransactionPayload::new_unchecked(v.into())
    }
}
impl TransactionPayload {
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn transaction(&self) -> Bytes {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Bytes::new_unchecked(self.0.slice(start..end))
    }
    pub fn receipt(&self) -> Bytes {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            Bytes::new_unchecked(self.0.slice(start..end))
        } else {
            Bytes::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> TransactionPayloadReader<'r> {
        TransactionPayloadReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for TransactionPayload {
    type Builder = TransactionPayloadBuilder;
    const NAME: &'static str = "TransactionPayload";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        TransactionPayload(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TransactionPayloadReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TransactionPayloadReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .transaction(self.transaction())
            .receipt(self.receipt())
    }
}
#[derive(Clone, Copy)]
pub struct TransactionPayloadReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for TransactionPayloadReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for TransactionPayloadReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for TransactionPayloadReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "transaction", self.transaction())?;
        write!(f, ", {}: {}", "receipt", self.receipt())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> TransactionPayloadReader<'r> {
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn transaction(&self) -> BytesReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        BytesReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn receipt(&self) -> BytesReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            BytesReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            BytesReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for TransactionPayloadReader<'r> {
    type Entity = TransactionPayload;
    const NAME: &'static str = "TransactionPayloadReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        TransactionPayloadReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        BytesReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        BytesReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct TransactionPayloadBuilder {
    pub(crate) transaction: Bytes,
    pub(crate) receipt: Bytes,
}
impl TransactionPayloadBuilder {
    pub const FIELD_COUNT: usize = 2;
    pub fn transaction(mut self, v: Bytes) -> Self {
        self.transaction = v;
        self
    }
    pub fn receipt(mut self, v: Bytes) -> Self {
        self.receipt = v;
        self
    }
}
impl molecule::prelude::Builder for TransactionPayloadBuilder {
    type Entity = TransactionPayload;
    const NAME: &'static str = "TransactionPayloadBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.transaction.as_slice().len()
            + self.receipt.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.transaction.as_slice().len();
        offsets.push(total_size);
        total_size += self.receipt.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.transaction.as_slice())?;
        writer.write_all(self.receipt.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        TransactionPayload::new_unchecked(inner.into())
    }
}
